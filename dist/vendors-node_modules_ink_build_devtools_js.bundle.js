/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendors-node_modules_ink_build_devtools_js";
exports.ids = ["vendors-node_modules_ink_build_devtools_js"];
exports.modules = {

/***/ "./node_modules/react-devtools-core/dist/backend.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-devtools-core/dist/backend.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 602:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_519__) => {\n\n\"use strict\";\nvar __webpack_unused_export__;\n/**\n * @license React\n * react-debug-tools.production.min.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar k = __nested_webpack_require_519__(206),\n    p = __nested_webpack_require_519__(189),\n    q = Object.assign,\n    w = p.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,\n    x = [],\n    y = null;\n\nfunction z() {\n  if (null === y) {\n    var a = new Map();\n\n    try {\n      A.useContext({\n        _currentValue: null\n      }), A.useState(null), A.useReducer(function (c) {\n        return c;\n      }, null), A.useRef(null), \"function\" === typeof A.useCacheRefresh && A.useCacheRefresh(), A.useLayoutEffect(function () {}), A.useInsertionEffect(function () {}), A.useEffect(function () {}), A.useImperativeHandle(void 0, function () {\n        return null;\n      }), A.useDebugValue(null), A.useCallback(function () {}), A.useMemo(function () {\n        return null;\n      }), \"function\" === typeof A.useMemoCache && A.useMemoCache(0);\n    } finally {\n      var b = x;\n      x = [];\n    }\n\n    for (var e = 0; e < b.length; e++) {\n      var g = b[e];\n      a.set(g.primitive, k.parse(g.stackError));\n    }\n\n    y = a;\n  }\n\n  return y;\n}\n\nvar B = null;\n\nfunction C() {\n  var a = B;\n  null !== a && (B = a.next);\n  return a;\n}\n\nvar A = {\n  use: function use() {\n    throw Error(\"Support for `use` not yet implemented in react-debug-tools.\");\n  },\n  readContext: function readContext(a) {\n    return a._currentValue;\n  },\n  useCacheRefresh: function useCacheRefresh() {\n    var a = C();\n    x.push({\n      primitive: \"CacheRefresh\",\n      stackError: Error(),\n      value: null !== a ? a.memoizedState : function () {}\n    });\n    return function () {};\n  },\n  useCallback: function useCallback(a) {\n    var b = C();\n    x.push({\n      primitive: \"Callback\",\n      stackError: Error(),\n      value: null !== b ? b.memoizedState[0] : a\n    });\n    return a;\n  },\n  useContext: function useContext(a) {\n    x.push({\n      primitive: \"Context\",\n      stackError: Error(),\n      value: a._currentValue\n    });\n    return a._currentValue;\n  },\n  useEffect: function useEffect(a) {\n    C();\n    x.push({\n      primitive: \"Effect\",\n      stackError: Error(),\n      value: a\n    });\n  },\n  useImperativeHandle: function useImperativeHandle(a) {\n    C();\n    var b = void 0;\n    null !== a && \"object\" === _typeof(a) && (b = a.current);\n    x.push({\n      primitive: \"ImperativeHandle\",\n      stackError: Error(),\n      value: b\n    });\n  },\n  useDebugValue: function useDebugValue(a, b) {\n    x.push({\n      primitive: \"DebugValue\",\n      stackError: Error(),\n      value: \"function\" === typeof b ? b(a) : a\n    });\n  },\n  useLayoutEffect: function useLayoutEffect(a) {\n    C();\n    x.push({\n      primitive: \"LayoutEffect\",\n      stackError: Error(),\n      value: a\n    });\n  },\n  useInsertionEffect: function useInsertionEffect(a) {\n    C();\n    x.push({\n      primitive: \"InsertionEffect\",\n      stackError: Error(),\n      value: a\n    });\n  },\n  useMemo: function useMemo(a) {\n    var b = C();\n    a = null !== b ? b.memoizedState[0] : a();\n    x.push({\n      primitive: \"Memo\",\n      stackError: Error(),\n      value: a\n    });\n    return a;\n  },\n  useMemoCache: function useMemoCache() {\n    return [];\n  },\n  useReducer: function useReducer(a, b, e) {\n    a = C();\n    b = null !== a ? a.memoizedState : void 0 !== e ? e(b) : b;\n    x.push({\n      primitive: \"Reducer\",\n      stackError: Error(),\n      value: b\n    });\n    return [b, function () {}];\n  },\n  useRef: function useRef(a) {\n    var b = C();\n    a = null !== b ? b.memoizedState : {\n      current: a\n    };\n    x.push({\n      primitive: \"Ref\",\n      stackError: Error(),\n      value: a.current\n    });\n    return a;\n  },\n  useState: function useState(a) {\n    var b = C();\n    a = null !== b ? b.memoizedState : \"function\" === typeof a ? a() : a;\n    x.push({\n      primitive: \"State\",\n      stackError: Error(),\n      value: a\n    });\n    return [a, function () {}];\n  },\n  useTransition: function useTransition() {\n    C();\n    C();\n    x.push({\n      primitive: \"Transition\",\n      stackError: Error(),\n      value: void 0\n    });\n    return [!1, function () {}];\n  },\n  useSyncExternalStore: function useSyncExternalStore(a, b) {\n    C();\n    C();\n    a = b();\n    x.push({\n      primitive: \"SyncExternalStore\",\n      stackError: Error(),\n      value: a\n    });\n    return a;\n  },\n  useDeferredValue: function useDeferredValue(a) {\n    var b = C();\n    x.push({\n      primitive: \"DeferredValue\",\n      stackError: Error(),\n      value: null !== b ? b.memoizedState : a\n    });\n    return a;\n  },\n  useId: function useId() {\n    var a = C();\n    a = null !== a ? a.memoizedState : \"\";\n    x.push({\n      primitive: \"Id\",\n      stackError: Error(),\n      value: a\n    });\n    return a;\n  }\n},\n    D = {\n  get: function get(a, b) {\n    if (a.hasOwnProperty(b)) return a[b];\n    a = Error(\"Missing method in Dispatcher: \" + b);\n    a.name = \"ReactDebugToolsUnsupportedHookError\";\n    throw a;\n  }\n},\n    E = \"undefined\" === typeof Proxy ? A : new Proxy(A, D),\n    F = 0;\n\nfunction G(a, b, e) {\n  var g = b[e].source,\n      c = 0;\n\n  a: for (; c < a.length; c++) {\n    if (a[c].source === g) {\n      for (var h = e + 1, r = c + 1; h < b.length && r < a.length; h++, r++) {\n        if (a[r].source !== b[h].source) continue a;\n      }\n\n      return c;\n    }\n  }\n\n  return -1;\n}\n\nfunction H(a, b) {\n  if (!a) return !1;\n  b = \"use\" + b;\n  return a.length < b.length ? !1 : a.lastIndexOf(b) === a.length - b.length;\n}\n\nfunction I(a, b, e) {\n  for (var g = [], c = null, h = g, r = 0, t = [], v = 0; v < b.length; v++) {\n    var u = b[v];\n    var d = a;\n    var l = k.parse(u.stackError);\n\n    b: {\n      var m = l,\n          n = G(m, d, F);\n      if (-1 !== n) d = n;else {\n        for (var f = 0; f < d.length && 5 > f; f++) {\n          if (n = G(m, d, f), -1 !== n) {\n            F = f;\n            d = n;\n            break b;\n          }\n        }\n\n        d = -1;\n      }\n    }\n\n    b: {\n      m = l;\n      n = z().get(u.primitive);\n      if (void 0 !== n) for (f = 0; f < n.length && f < m.length; f++) {\n        if (n[f].source !== m[f].source) {\n          f < m.length - 1 && H(m[f].functionName, u.primitive) && f++;\n          f < m.length - 1 && H(m[f].functionName, u.primitive) && f++;\n          m = f;\n          break b;\n        }\n      }\n      m = -1;\n    }\n\n    l = -1 === d || -1 === m || 2 > d - m ? null : l.slice(m, d - 1);\n\n    if (null !== l) {\n      d = 0;\n\n      if (null !== c) {\n        for (; d < l.length && d < c.length && l[l.length - d - 1].source === c[c.length - d - 1].source;) {\n          d++;\n        }\n\n        for (c = c.length - 1; c > d; c--) {\n          h = t.pop();\n        }\n      }\n\n      for (c = l.length - d - 1; 1 <= c; c--) {\n        d = [], m = l[c], (n = l[c - 1].functionName) ? (f = n.lastIndexOf(\".\"), -1 === f && (f = 0), \"use\" === n.slice(f, f + 3) && (f += 3), n = n.slice(f)) : n = \"\", n = {\n          id: null,\n          isStateEditable: !1,\n          name: n,\n          value: void 0,\n          subHooks: d\n        }, e && (n.hookSource = {\n          lineNumber: m.lineNumber,\n          columnNumber: m.columnNumber,\n          functionName: m.functionName,\n          fileName: m.fileName\n        }), h.push(n), t.push(h), h = d;\n      }\n\n      c = l;\n    }\n\n    d = u.primitive;\n    u = {\n      id: \"Context\" === d || \"DebugValue\" === d ? null : r++,\n      isStateEditable: \"Reducer\" === d || \"State\" === d,\n      name: d,\n      value: u.value,\n      subHooks: []\n    };\n    e && (d = {\n      lineNumber: null,\n      functionName: null,\n      fileName: null,\n      columnNumber: null\n    }, l && 1 <= l.length && (l = l[0], d.lineNumber = l.lineNumber, d.functionName = l.functionName, d.fileName = l.fileName, d.columnNumber = l.columnNumber), u.hookSource = d);\n    h.push(u);\n  }\n\n  J(g, null);\n  return g;\n}\n\nfunction J(a, b) {\n  for (var e = [], g = 0; g < a.length; g++) {\n    var c = a[g];\n    \"DebugValue\" === c.name && 0 === c.subHooks.length ? (a.splice(g, 1), g--, e.push(c)) : J(c.subHooks, c);\n  }\n\n  null !== b && (1 === e.length ? b.value = e[0].value : 1 < e.length && (b.value = e.map(function (h) {\n    return h.value;\n  })));\n}\n\nfunction K(a) {\n  if (a instanceof Error && \"ReactDebugToolsUnsupportedHookError\" === a.name) throw a;\n  var b = Error(\"Error rendering inspected component\", {\n    cause: a\n  });\n  b.name = \"ReactDebugToolsRenderError\";\n  b.cause = a;\n  throw b;\n}\n\nfunction L(a, b, e) {\n  var g = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : !1;\n  null == e && (e = w.ReactCurrentDispatcher);\n  var c = e.current;\n  e.current = E;\n\n  try {\n    var h = Error();\n    a(b);\n  } catch (t) {\n    K(t);\n  } finally {\n    var r = x;\n    x = [];\n    e.current = c;\n  }\n\n  c = k.parse(h);\n  return I(c, r, g);\n}\n\nfunction M(a) {\n  a.forEach(function (b, e) {\n    return e._currentValue = b;\n  });\n}\n\n__webpack_unused_export__ = L;\n\nexports.inspectHooksOfFiber = function (a, b) {\n  var e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !1;\n  null == b && (b = w.ReactCurrentDispatcher);\n  if (0 !== a.tag && 15 !== a.tag && 11 !== a.tag) throw Error(\"Unknown Fiber. Needs to be a function component to inspect hooks.\");\n  z();\n  var g = a.type,\n      c = a.memoizedProps;\n\n  if (g !== a.elementType && g && g.defaultProps) {\n    c = q({}, c);\n    var h = g.defaultProps;\n\n    for (r in h) {\n      void 0 === c[r] && (c[r] = h[r]);\n    }\n  }\n\n  B = a.memoizedState;\n  var r = new Map();\n\n  try {\n    for (h = a; h;) {\n      if (10 === h.tag) {\n        var t = h.type._context;\n        r.has(t) || (r.set(t, t._currentValue), t._currentValue = h.memoizedProps.value);\n      }\n\n      h = h.return;\n    }\n\n    if (11 === a.tag) {\n      var v = g.render;\n      g = c;\n      var u = a.ref;\n      t = b;\n      var d = t.current;\n      t.current = E;\n\n      try {\n        var l = Error();\n        v(g, u);\n      } catch (f) {\n        K(f);\n      } finally {\n        var m = x;\n        x = [];\n        t.current = d;\n      }\n\n      var n = k.parse(l);\n      return I(n, m, e);\n    }\n\n    return L(g, c, b, e);\n  } finally {\n    B = null, M(r);\n  }\n};\n\n/***/ }),\n\n/***/ 987:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_11283__) => {\n\n\"use strict\";\n\n\nif (true) {\n  module.exports = __nested_webpack_require_11283__(602);\n} else {}\n\n/***/ }),\n\n/***/ 9:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\nvar __webpack_unused_export__;\n/**\n * @license React\n * react-is.production.min.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar b = Symbol.for(\"react.element\"),\n    c = Symbol.for(\"react.portal\"),\n    d = Symbol.for(\"react.fragment\"),\n    e = Symbol.for(\"react.strict_mode\"),\n    f = Symbol.for(\"react.profiler\"),\n    g = Symbol.for(\"react.provider\"),\n    h = Symbol.for(\"react.context\"),\n    k = Symbol.for(\"react.server_context\"),\n    l = Symbol.for(\"react.forward_ref\"),\n    m = Symbol.for(\"react.suspense\"),\n    n = Symbol.for(\"react.suspense_list\"),\n    p = Symbol.for(\"react.memo\"),\n    q = Symbol.for(\"react.lazy\"),\n    t = Symbol.for(\"react.offscreen\"),\n    u = Symbol.for(\"react.cache\"),\n    v = Symbol.for(\"react.client.reference\");\n\nfunction w(a) {\n  if (\"object\" === _typeof(a) && null !== a) {\n    var r = a.$$typeof;\n\n    switch (r) {\n      case b:\n        switch (a = a.type, a) {\n          case d:\n          case f:\n          case e:\n          case m:\n          case n:\n            return a;\n\n          default:\n            switch (a = a && a.$$typeof, a) {\n              case k:\n              case h:\n              case l:\n              case q:\n              case p:\n              case g:\n                return a;\n\n              default:\n                return r;\n            }\n\n        }\n\n      case c:\n        return r;\n    }\n  }\n}\n\nexports.ContextConsumer = h;\nexports.ContextProvider = g;\n__webpack_unused_export__ = b;\nexports.ForwardRef = l;\nexports.Fragment = d;\nexports.Lazy = q;\nexports.Memo = p;\nexports.Portal = c;\nexports.Profiler = f;\nexports.StrictMode = e;\nexports.Suspense = m;\n__webpack_unused_export__ = n;\n\n__webpack_unused_export__ = function () {\n  return !1;\n};\n\n__webpack_unused_export__ = function () {\n  return !1;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === h;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === g;\n};\n\nexports.isElement = function (a) {\n  return \"object\" === _typeof(a) && null !== a && a.$$typeof === b;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === l;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === d;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === q;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === p;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === c;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === f;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === e;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === m;\n};\n\n__webpack_unused_export__ = function (a) {\n  return w(a) === n;\n};\n\n__webpack_unused_export__ = function (a) {\n  return \"string\" === typeof a || \"function\" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || a === u || \"object\" === _typeof(a) && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === v || void 0 !== a.getModuleId) ? !0 : !1;\n};\n\nexports.typeOf = w;\n\n/***/ }),\n\n/***/ 550:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_15093__) => {\n\n\"use strict\";\n\n\nif (true) {\n  module.exports = __nested_webpack_require_15093__(9);\n} else {}\n\n/***/ }),\n\n/***/ 978:\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar l = Symbol.for(\"react.element\"),\n    n = Symbol.for(\"react.portal\"),\n    p = Symbol.for(\"react.fragment\"),\n    q = Symbol.for(\"react.strict_mode\"),\n    r = Symbol.for(\"react.profiler\"),\n    t = Symbol.for(\"react.provider\"),\n    u = Symbol.for(\"react.context\"),\n    v = Symbol.for(\"react.server_context\"),\n    w = Symbol.for(\"react.forward_ref\"),\n    x = Symbol.for(\"react.suspense\"),\n    y = Symbol.for(\"react.suspense_list\"),\n    z = Symbol.for(\"react.memo\"),\n    A = Symbol.for(\"react.lazy\"),\n    aa = Symbol.for(\"react.debug_trace_mode\"),\n    ba = Symbol.for(\"react.offscreen\"),\n    ca = Symbol.for(\"react.cache\"),\n    B = Symbol.for(\"react.default_value\"),\n    da = Symbol.for(\"react.postpone\"),\n    C = Symbol.iterator;\n\nfunction ea(a) {\n  if (null === a || \"object\" !== _typeof(a)) return null;\n  a = C && a[C] || a[\"@@iterator\"];\n  return \"function\" === typeof a ? a : null;\n}\n\nvar D = {\n  isMounted: function isMounted() {\n    return !1;\n  },\n  enqueueForceUpdate: function enqueueForceUpdate() {},\n  enqueueReplaceState: function enqueueReplaceState() {},\n  enqueueSetState: function enqueueSetState() {}\n},\n    E = Object.assign,\n    F = {};\n\nfunction G(a, b, c) {\n  this.props = a;\n  this.context = b;\n  this.refs = F;\n  this.updater = c || D;\n}\n\nG.prototype.isReactComponent = {};\n\nG.prototype.setState = function (a, b) {\n  if (\"object\" !== _typeof(a) && \"function\" !== typeof a && null != a) throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n  this.updater.enqueueSetState(this, a, b, \"setState\");\n};\n\nG.prototype.forceUpdate = function (a) {\n  this.updater.enqueueForceUpdate(this, a, \"forceUpdate\");\n};\n\nfunction H() {}\n\nH.prototype = G.prototype;\n\nfunction I(a, b, c) {\n  this.props = a;\n  this.context = b;\n  this.refs = F;\n  this.updater = c || D;\n}\n\nvar J = I.prototype = new H();\nJ.constructor = I;\nE(J, G.prototype);\nJ.isPureReactComponent = !0;\nvar K = Array.isArray,\n    L = Object.prototype.hasOwnProperty,\n    M = {\n  current: null\n},\n    N = {\n  key: !0,\n  ref: !0,\n  __self: !0,\n  __source: !0\n};\n\nfunction O(a, b, c) {\n  var d,\n      e = {},\n      f = null,\n      g = null;\n  if (null != b) for (d in void 0 !== b.ref && (g = b.ref), void 0 !== b.key && (f = \"\" + b.key), b) {\n    L.call(b, d) && !N.hasOwnProperty(d) && (e[d] = b[d]);\n  }\n  var h = arguments.length - 2;\n  if (1 === h) e.children = c;else if (1 < h) {\n    for (var k = Array(h), m = 0; m < h; m++) {\n      k[m] = arguments[m + 2];\n    }\n\n    e.children = k;\n  }\n  if (a && a.defaultProps) for (d in h = a.defaultProps, h) {\n    void 0 === e[d] && (e[d] = h[d]);\n  }\n  return {\n    $$typeof: l,\n    type: a,\n    key: f,\n    ref: g,\n    props: e,\n    _owner: M.current\n  };\n}\n\nfunction fa(a, b) {\n  return {\n    $$typeof: l,\n    type: a.type,\n    key: b,\n    ref: a.ref,\n    props: a.props,\n    _owner: a._owner\n  };\n}\n\nfunction P(a) {\n  return \"object\" === _typeof(a) && null !== a && a.$$typeof === l;\n}\n\nfunction escape(a) {\n  var b = {\n    \"=\": \"=0\",\n    \":\": \"=2\"\n  };\n  return \"$\" + a.replace(/[=:]/g, function (c) {\n    return b[c];\n  });\n}\n\nvar Q = /\\/+/g;\n\nfunction R(a, b) {\n  return \"object\" === _typeof(a) && null !== a && null != a.key ? escape(\"\" + a.key) : b.toString(36);\n}\n\nfunction S(a, b, c, d, e) {\n  var f = _typeof(a);\n\n  if (\"undefined\" === f || \"boolean\" === f) a = null;\n  var g = !1;\n  if (null === a) g = !0;else switch (f) {\n    case \"string\":\n    case \"number\":\n      g = !0;\n      break;\n\n    case \"object\":\n      switch (a.$$typeof) {\n        case l:\n        case n:\n          g = !0;\n      }\n\n  }\n  if (g) return g = a, e = e(g), a = \"\" === d ? \".\" + R(g, 0) : d, K(e) ? (c = \"\", null != a && (c = a.replace(Q, \"$&/\") + \"/\"), S(e, b, c, \"\", function (m) {\n    return m;\n  })) : null != e && (P(e) && (e = fa(e, c + (!e.key || g && g.key === e.key ? \"\" : (\"\" + e.key).replace(Q, \"$&/\") + \"/\") + a)), b.push(e)), 1;\n  g = 0;\n  d = \"\" === d ? \".\" : d + \":\";\n  if (K(a)) for (var h = 0; h < a.length; h++) {\n    f = a[h];\n    var k = d + R(f, h);\n    g += S(f, b, c, k, e);\n  } else if (k = ea(a), \"function\" === typeof k) for (a = k.call(a), h = 0; !(f = a.next()).done;) {\n    f = f.value, k = d + R(f, h++), g += S(f, b, c, k, e);\n  } else if (\"object\" === f) throw b = String(a), Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === b ? \"object with keys {\" + Object.keys(a).join(\", \") + \"}\" : b) + \"). If you meant to render a collection of children, use an array instead.\");\n  return g;\n}\n\nfunction T(a, b, c) {\n  if (null == a) return a;\n  var d = [],\n      e = 0;\n  S(a, d, \"\", \"\", function (f) {\n    return b.call(c, f, e++);\n  });\n  return d;\n}\n\nfunction ha(a) {\n  if (-1 === a._status) {\n    var b = a._result;\n    b = b();\n    b.then(function (c) {\n      if (0 === a._status || -1 === a._status) a._status = 1, a._result = c;\n    }, function (c) {\n      if (0 === a._status || -1 === a._status) a._status = 2, a._result = c;\n    });\n    -1 === a._status && (a._status = 0, a._result = b);\n  }\n\n  if (1 === a._status) return a._result.default;\n  throw a._result;\n}\n\nvar U = {\n  current: null\n};\n\nfunction ia() {\n  return new WeakMap();\n}\n\nfunction V() {\n  return {\n    s: 0,\n    v: void 0,\n    o: null,\n    p: null\n  };\n}\n\nvar W = {\n  current: null\n};\n\nfunction X(a, b) {\n  return W.current.useOptimistic(a, b);\n}\n\nvar Y = {\n  transition: null\n},\n    Z = {},\n    ja = {\n  ReactCurrentDispatcher: W,\n  ReactCurrentCache: U,\n  ReactCurrentBatchConfig: Y,\n  ReactCurrentOwner: M,\n  ContextRegistry: Z\n};\nexports.Children = {\n  map: T,\n  forEach: function forEach(a, b, c) {\n    T(a, function () {\n      b.apply(this, arguments);\n    }, c);\n  },\n  count: function count(a) {\n    var b = 0;\n    T(a, function () {\n      b++;\n    });\n    return b;\n  },\n  toArray: function toArray(a) {\n    return T(a, function (b) {\n      return b;\n    }) || [];\n  },\n  only: function only(a) {\n    if (!P(a)) throw Error(\"React.Children.only expected to receive a single React element child.\");\n    return a;\n  }\n};\nexports.Component = G;\nexports.Fragment = p;\nexports.Profiler = r;\nexports.PureComponent = I;\nexports.StrictMode = q;\nexports.Suspense = x;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ja;\n\nexports.cache = function (a) {\n  return function () {\n    var b = U.current;\n    if (!b) return a.apply(null, arguments);\n    var c = b.getCacheForType(ia);\n    b = c.get(a);\n    void 0 === b && (b = V(), c.set(a, b));\n    c = 0;\n\n    for (var d = arguments.length; c < d; c++) {\n      var e = arguments[c];\n\n      if (\"function\" === typeof e || \"object\" === _typeof(e) && null !== e) {\n        var f = b.o;\n        null === f && (b.o = f = new WeakMap());\n        b = f.get(e);\n        void 0 === b && (b = V(), f.set(e, b));\n      } else f = b.p, null === f && (b.p = f = new Map()), b = f.get(e), void 0 === b && (b = V(), f.set(e, b));\n    }\n\n    if (1 === b.s) return b.v;\n    if (2 === b.s) throw b.v;\n\n    try {\n      var g = a.apply(null, arguments);\n      c = b;\n      c.s = 1;\n      return c.v = g;\n    } catch (h) {\n      throw g = b, g.s = 2, g.v = h, h;\n    }\n  };\n};\n\nexports.cloneElement = function (a, b, c) {\n  if (null === a || void 0 === a) throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + a + \".\");\n  var d = E({}, a.props),\n      e = a.key,\n      f = a.ref,\n      g = a._owner;\n\n  if (null != b) {\n    void 0 !== b.ref && (f = b.ref, g = M.current);\n    void 0 !== b.key && (e = \"\" + b.key);\n    if (a.type && a.type.defaultProps) var h = a.type.defaultProps;\n\n    for (k in b) {\n      L.call(b, k) && !N.hasOwnProperty(k) && (d[k] = void 0 === b[k] && void 0 !== h ? h[k] : b[k]);\n    }\n  }\n\n  var k = arguments.length - 2;\n  if (1 === k) d.children = c;else if (1 < k) {\n    h = Array(k);\n\n    for (var m = 0; m < k; m++) {\n      h[m] = arguments[m + 2];\n    }\n\n    d.children = h;\n  }\n  return {\n    $$typeof: l,\n    type: a.type,\n    key: e,\n    ref: f,\n    props: d,\n    _owner: g\n  };\n};\n\nexports.createContext = function (a) {\n  a = {\n    $$typeof: u,\n    _currentValue: a,\n    _currentValue2: a,\n    _threadCount: 0,\n    Provider: null,\n    Consumer: null,\n    _defaultValue: null,\n    _globalName: null\n  };\n  a.Provider = {\n    $$typeof: t,\n    _context: a\n  };\n  return a.Consumer = a;\n};\n\nexports.createElement = O;\n\nexports.createFactory = function (a) {\n  var b = O.bind(null, a);\n  b.type = a;\n  return b;\n};\n\nexports.createRef = function () {\n  return {\n    current: null\n  };\n};\n\nexports.createServerContext = function (a, b) {\n  var c = !0;\n\n  if (!Z[a]) {\n    c = !1;\n    var d = {\n      $$typeof: v,\n      _currentValue: b,\n      _currentValue2: b,\n      _defaultValue: b,\n      _threadCount: 0,\n      Provider: null,\n      Consumer: null,\n      _globalName: a\n    };\n    d.Provider = {\n      $$typeof: t,\n      _context: d\n    };\n    Z[a] = d;\n  }\n\n  d = Z[a];\n  if (d._defaultValue === B) d._defaultValue = b, d._currentValue === B && (d._currentValue = b), d._currentValue2 === B && (d._currentValue2 = b);else if (c) throw Error(\"ServerContext: \" + a + \" already defined\");\n  return d;\n};\n\nexports.experimental_useEffectEvent = function (a) {\n  return W.current.useEffectEvent(a);\n};\n\nexports.experimental_useOptimistic = function (a, b) {\n  return X(a, b);\n};\n\nexports.forwardRef = function (a) {\n  return {\n    $$typeof: w,\n    render: a\n  };\n};\n\nexports.isValidElement = P;\n\nexports.lazy = function (a) {\n  return {\n    $$typeof: A,\n    _payload: {\n      _status: -1,\n      _result: a\n    },\n    _init: ha\n  };\n};\n\nexports.memo = function (a, b) {\n  return {\n    $$typeof: z,\n    type: a,\n    compare: void 0 === b ? null : b\n  };\n};\n\nexports.startTransition = function (a) {\n  var b = Y.transition;\n  Y.transition = {};\n\n  try {\n    a();\n  } finally {\n    Y.transition = b;\n  }\n};\n\nexports.unstable_Cache = ca;\nexports.unstable_DebugTracingMode = aa;\nexports.unstable_Offscreen = ba;\nexports.unstable_SuspenseList = y;\n\nexports.unstable_act = function () {\n  throw Error(\"act(...) is not supported in production builds of React.\");\n};\n\nexports.unstable_getCacheForType = function (a) {\n  var b = U.current;\n  return b ? b.getCacheForType(a) : a();\n};\n\nexports.unstable_getCacheSignal = function () {\n  var a = U.current;\n  return a ? a.getCacheSignal() : (a = new AbortController(), a.abort(Error(\"This CacheSignal was requested outside React which means that it is immediately aborted.\")), a.signal);\n};\n\nexports.unstable_postpone = function (a) {\n  a = Error(a);\n  a.$$typeof = da;\n  throw a;\n};\n\nexports.unstable_useCacheRefresh = function () {\n  return W.current.useCacheRefresh();\n};\n\nexports.unstable_useMemoCache = function (a) {\n  return W.current.useMemoCache(a);\n};\n\nexports.use = function (a) {\n  return W.current.use(a);\n};\n\nexports.useCallback = function (a, b) {\n  return W.current.useCallback(a, b);\n};\n\nexports.useContext = function (a) {\n  return W.current.useContext(a);\n};\n\nexports.useDebugValue = function () {};\n\nexports.useDeferredValue = function (a, b) {\n  return W.current.useDeferredValue(a, b);\n};\n\nexports.useEffect = function (a, b) {\n  return W.current.useEffect(a, b);\n};\n\nexports.useId = function () {\n  return W.current.useId();\n};\n\nexports.useImperativeHandle = function (a, b, c) {\n  return W.current.useImperativeHandle(a, b, c);\n};\n\nexports.useInsertionEffect = function (a, b) {\n  return W.current.useInsertionEffect(a, b);\n};\n\nexports.useLayoutEffect = function (a, b) {\n  return W.current.useLayoutEffect(a, b);\n};\n\nexports.useMemo = function (a, b) {\n  return W.current.useMemo(a, b);\n};\n\nexports.useOptimistic = X;\n\nexports.useReducer = function (a, b, c) {\n  return W.current.useReducer(a, b, c);\n};\n\nexports.useRef = function (a) {\n  return W.current.useRef(a);\n};\n\nexports.useState = function (a) {\n  return W.current.useState(a);\n};\n\nexports.useSyncExternalStore = function (a, b, c) {\n  return W.current.useSyncExternalStore(a, b, c);\n};\n\nexports.useTransition = function () {\n  return W.current.useTransition();\n};\n\nexports.version = \"18.3.0-experimental-51ffd3564-20231025\";\n\n/***/ }),\n\n/***/ 189:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_28042__) => {\n\n\"use strict\";\n\n\nif (true) {\n  module.exports = __nested_webpack_require_28042__(978);\n} else {}\n\n/***/ }),\n\n/***/ 206:\n/***/ (function(module, exports, __nested_webpack_require_28208__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_28208__(430)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n        }\n\n        var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '('); // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n\n        var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/); // remove the parenthesized location from the line, if it was matched\n\n        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n        var tokens = sanitizedLine.split(/\\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token\n\n        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame({\n          functionName: functionName,\n          fileName: fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame({\n            functionName: line\n          });\n        } else {\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          var matches = line.match(functionNameRegex);\n          var functionName = matches && matches[1] ? matches[1] : undefined;\n          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n      return filtered.map(function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame({\n          functionName: functionName,\n          args: args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    }\n  };\n});\n\n/***/ }),\n\n/***/ 172:\n/***/ ((module) => {\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n/** Used as references for various `Number` constants. */\n\nvar NAN = 0 / 0;\n/** `Object#toString` result references. */\n\nvar symbolTag = '[object Symbol]';\n/** Used to match leading and trailing whitespace. */\n\nvar reTrim = /^\\s+|\\s+$/g;\n/** Used to detect bad signed hexadecimal string values. */\n\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */\n\nvar reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */\n\nvar reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */\n\nvar freeParseInt = parseInt;\n/** Detect free variable `global` from Node.js. */\n\nvar freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\n/** Detect free variable `self`. */\n\nvar freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal || freeSelf || Function('return this')();\n/** Used for built-in method references. */\n\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar objectToString = objectProto.toString;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\n\nvar now = function now() {\n  return root.Date.now();\n};\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\n\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\n\n\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\n\n\nfunction isObject(value) {\n  var type = _typeof(value);\n\n  return !!value && (type == 'object' || type == 'function');\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\n\n\nfunction isObjectLike(value) {\n  return !!value && _typeof(value) == 'object';\n}\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\n\n\nfunction isSymbol(value) {\n  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\n\n\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n\n  if (isSymbol(value)) {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? other + '' : other;\n  }\n\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nmodule.exports = throttle;\n\n/***/ }),\n\n/***/ 730:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_50078__) => {\n\n\"use strict\";\n/* provided dependency */ var process = __nested_webpack_require_50078__(169);\n\n\nmodule.exports = LRUCache; // This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\n\nvar Map = __nested_webpack_require_50078__(307);\n\nvar util = __nested_webpack_require_50078__(82); // A linked list to keep track of recently-used-ness\n\n\nvar Yallist = __nested_webpack_require_50078__(695); // use symbols if possible, otherwise just _props\n\n\nvar hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1';\nvar makeSymbol;\n\nif (hasSymbol) {\n  makeSymbol = function makeSymbol(key) {\n    return Symbol(key);\n  };\n} else {\n  makeSymbol = function makeSymbol(key) {\n    return '_' + key;\n  };\n}\n\nvar MAX = makeSymbol('max');\nvar LENGTH = makeSymbol('length');\nvar LENGTH_CALCULATOR = makeSymbol('lengthCalculator');\nvar ALLOW_STALE = makeSymbol('allowStale');\nvar MAX_AGE = makeSymbol('maxAge');\nvar DISPOSE = makeSymbol('dispose');\nvar NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet');\nvar LRU_LIST = makeSymbol('lruList');\nvar CACHE = makeSymbol('cache');\n\nfunction naiveLength() {\n  return 1;\n} // lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\n\n\nfunction LRUCache(options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options);\n  }\n\n  if (typeof options === 'number') {\n    options = {\n      max: options\n    };\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  var max = this[MAX] = options.max; // Kind of weird to have a default max of Infinity, but oh well.\n\n  if (!max || !(typeof max === 'number') || max <= 0) {\n    this[MAX] = Infinity;\n  }\n\n  var lc = options.length || naiveLength;\n\n  if (typeof lc !== 'function') {\n    lc = naiveLength;\n  }\n\n  this[LENGTH_CALCULATOR] = lc;\n  this[ALLOW_STALE] = options.stale || false;\n  this[MAX_AGE] = options.maxAge || 0;\n  this[DISPOSE] = options.dispose;\n  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n  this.reset();\n} // resize the cache when the max changes.\n\n\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function set(mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity;\n    }\n\n    this[MAX] = mL;\n    trim(this);\n  },\n  get: function get() {\n    return this[MAX];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function set(allowStale) {\n    this[ALLOW_STALE] = !!allowStale;\n  },\n  get: function get() {\n    return this[ALLOW_STALE];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function set(mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0;\n    }\n\n    this[MAX_AGE] = mA;\n    trim(this);\n  },\n  get: function get() {\n    return this[MAX_AGE];\n  },\n  enumerable: true\n}); // resize the cache when the lengthCalculator changes.\n\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function set(lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength;\n    }\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC;\n      this[LENGTH] = 0;\n      this[LRU_LIST].forEach(function (hit) {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n        this[LENGTH] += hit.length;\n      }, this);\n    }\n\n    trim(this);\n  },\n  get: function get() {\n    return this[LENGTH_CALCULATOR];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function get() {\n    return this[LENGTH];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function get() {\n    return this[LRU_LIST].length;\n  },\n  enumerable: true\n});\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this[LRU_LIST].tail; walker !== null;) {\n    var prev = walker.prev;\n    forEachStep(this, fn, walker, thisp);\n    walker = prev;\n  }\n};\n\nfunction forEachStep(self, fn, node, thisp) {\n  var hit = node.value;\n\n  if (isStale(self, hit)) {\n    del(self, node);\n\n    if (!self[ALLOW_STALE]) {\n      hit = undefined;\n    }\n  }\n\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self);\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this[LRU_LIST].head; walker !== null;) {\n    var next = walker.next;\n    forEachStep(this, fn, walker, thisp);\n    walker = next;\n  }\n};\n\nLRUCache.prototype.keys = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.key;\n  }, this);\n};\n\nLRUCache.prototype.values = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.value;\n  }, this);\n};\n\nLRUCache.prototype.reset = function () {\n  if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n    this[LRU_LIST].forEach(function (hit) {\n      this[DISPOSE](hit.key, hit.value);\n    }, this);\n  }\n\n  this[CACHE] = new Map(); // hash of items by key\n\n  this[LRU_LIST] = new Yallist(); // list of items in order of use recency\n\n  this[LENGTH] = 0; // length of items in the list\n};\n\nLRUCache.prototype.dump = function () {\n  return this[LRU_LIST].map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      };\n    }\n  }, this).toArray().filter(function (h) {\n    return h;\n  });\n};\n\nLRUCache.prototype.dumpLru = function () {\n  return this[LRU_LIST];\n};\n/* istanbul ignore next */\n\n\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {';\n  var extras = false;\n  var as = this[ALLOW_STALE];\n\n  if (as) {\n    str += '\\n  allowStale: true';\n    extras = true;\n  }\n\n  var max = this[MAX];\n\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  max: ' + util.inspect(max, opts);\n    extras = true;\n  }\n\n  var maxAge = this[MAX_AGE];\n\n  if (maxAge) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts);\n    extras = true;\n  }\n\n  var lc = this[LENGTH_CALCULATOR];\n\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  length: ' + util.inspect(this[LENGTH], opts);\n    extras = true;\n  }\n\n  var didFirst = false;\n  this[LRU_LIST].forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  ';\n    } else {\n      if (extras) {\n        str += ',\\n';\n      }\n\n      didFirst = true;\n      str += '\\n  ';\n    }\n\n    var key = util.inspect(item.key).split('\\n').join('\\n  ');\n    var val = {\n      value: item.value\n    };\n\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge;\n    }\n\n    if (lc !== naiveLength) {\n      val.length = item.length;\n    }\n\n    if (isStale(this, item)) {\n      val.stale = true;\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ');\n    str += key + ' => ' + val;\n  });\n\n  if (didFirst || extras) {\n    str += '\\n';\n  }\n\n  str += '}';\n  return str;\n};\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this[MAX_AGE];\n  var now = maxAge ? Date.now() : 0;\n  var len = this[LENGTH_CALCULATOR](value, key);\n\n  if (this[CACHE].has(key)) {\n    if (len > this[MAX]) {\n      del(this, this[CACHE].get(key));\n      return false;\n    }\n\n    var node = this[CACHE].get(key);\n    var item = node.value; // dispose of the old one before overwriting\n    // split out into 2 ifs for better coverage tracking\n\n    if (this[DISPOSE]) {\n      if (!this[NO_DISPOSE_ON_SET]) {\n        this[DISPOSE](key, item.value);\n      }\n    }\n\n    item.now = now;\n    item.maxAge = maxAge;\n    item.value = value;\n    this[LENGTH] += len - item.length;\n    item.length = len;\n    this.get(key);\n    trim(this);\n    return true;\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.\n\n  if (hit.length > this[MAX]) {\n    if (this[DISPOSE]) {\n      this[DISPOSE](key, value);\n    }\n\n    return false;\n  }\n\n  this[LENGTH] += hit.length;\n  this[LRU_LIST].unshift(hit);\n  this[CACHE].set(key, this[LRU_LIST].head);\n  trim(this);\n  return true;\n};\n\nLRUCache.prototype.has = function (key) {\n  if (!this[CACHE].has(key)) return false;\n  var hit = this[CACHE].get(key).value;\n\n  if (isStale(this, hit)) {\n    return false;\n  }\n\n  return true;\n};\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true);\n};\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false);\n};\n\nLRUCache.prototype.pop = function () {\n  var node = this[LRU_LIST].tail;\n  if (!node) return null;\n  del(this, node);\n  return node.value;\n};\n\nLRUCache.prototype.del = function (key) {\n  del(this, this[CACHE].get(key));\n};\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset();\n  var now = Date.now(); // A previous serialized cache has the most recent items first\n\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l];\n    var expiresAt = hit.e || 0;\n\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v);\n    } else {\n      var maxAge = expiresAt - now; // dont add already expired items\n\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge);\n      }\n    }\n  }\n};\n\nLRUCache.prototype.prune = function () {\n  var self = this;\n  this[CACHE].forEach(function (value, key) {\n    get(self, key, false);\n  });\n};\n\nfunction get(self, key, doUse) {\n  var node = self[CACHE].get(key);\n\n  if (node) {\n    var hit = node.value;\n\n    if (isStale(self, hit)) {\n      del(self, node);\n      if (!self[ALLOW_STALE]) hit = undefined;\n    } else {\n      if (doUse) {\n        self[LRU_LIST].unshiftNode(node);\n      }\n    }\n\n    if (hit) hit = hit.value;\n  }\n\n  return hit;\n}\n\nfunction isStale(self, hit) {\n  if (!hit || !hit.maxAge && !self[MAX_AGE]) {\n    return false;\n  }\n\n  var stale = false;\n  var diff = Date.now() - hit.now;\n\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge;\n  } else {\n    stale = self[MAX_AGE] && diff > self[MAX_AGE];\n  }\n\n  return stale;\n}\n\nfunction trim(self) {\n  if (self[LENGTH] > self[MAX]) {\n    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev;\n      del(self, walker);\n      walker = prev;\n    }\n  }\n}\n\nfunction del(self, node) {\n  if (node) {\n    var hit = node.value;\n\n    if (self[DISPOSE]) {\n      self[DISPOSE](hit.key, hit.value);\n    }\n\n    self[LENGTH] -= hit.length;\n    self[CACHE].delete(hit.key);\n    self[LRU_LIST].removeNode(node);\n  }\n} // classy, since V8 prefers predictable objects.\n\n\nfunction Entry(key, value, length, now, maxAge) {\n  this.key = key;\n  this.value = value;\n  this.length = length;\n  this.now = now;\n  this.maxAge = maxAge || 0;\n}\n\n/***/ }),\n\n/***/ 169:\n/***/ ((module) => {\n\n// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};\n\n/***/ }),\n\n/***/ 307:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_66349__) => {\n\n/* provided dependency */ var process = __nested_webpack_require_66349__(169);\nif (process.env.npm_package_name === 'pseudomap' && process.env.npm_lifecycle_script === 'test') process.env.TEST_PSEUDOMAP = 'true';\n\nif (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {\n  module.exports = Map;\n} else {\n  module.exports = __nested_webpack_require_66349__(761);\n}\n\n/***/ }),\n\n/***/ 761:\n/***/ ((module) => {\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nmodule.exports = PseudoMap;\n\nfunction PseudoMap(set) {\n  if (!(this instanceof PseudoMap)) // whyyyyyyy\n    throw new TypeError(\"Constructor PseudoMap requires 'new'\");\n  this.clear();\n\n  if (set) {\n    if (set instanceof PseudoMap || typeof Map === 'function' && set instanceof Map) set.forEach(function (value, key) {\n      this.set(key, value);\n    }, this);else if (Array.isArray(set)) set.forEach(function (kv) {\n      this.set(kv[0], kv[1]);\n    }, this);else throw new TypeError('invalid argument');\n  }\n}\n\nPseudoMap.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n  Object.keys(this._data).forEach(function (k) {\n    if (k !== 'size') fn.call(thisp, this._data[k].value, this._data[k].key);\n  }, this);\n};\n\nPseudoMap.prototype.has = function (k) {\n  return !!find(this._data, k);\n};\n\nPseudoMap.prototype.get = function (k) {\n  var res = find(this._data, k);\n  return res && res.value;\n};\n\nPseudoMap.prototype.set = function (k, v) {\n  set(this._data, k, v);\n};\n\nPseudoMap.prototype.delete = function (k) {\n  var res = find(this._data, k);\n\n  if (res) {\n    delete this._data[res._index];\n    this._data.size--;\n  }\n};\n\nPseudoMap.prototype.clear = function () {\n  var data = Object.create(null);\n  data.size = 0;\n  Object.defineProperty(this, '_data', {\n    value: data,\n    enumerable: false,\n    configurable: true,\n    writable: false\n  });\n};\n\nObject.defineProperty(PseudoMap.prototype, 'size', {\n  get: function get() {\n    return this._data.size;\n  },\n  set: function set(n) {},\n  enumerable: true,\n  configurable: true\n});\n\nPseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function () {\n  throw new Error('iterators are not implemented in this version');\n}; // Either identical, or both NaN\n\n\nfunction same(a, b) {\n  return a === b || a !== a && b !== b;\n}\n\nfunction Entry(k, v, i) {\n  this.key = k;\n  this.value = v;\n  this._index = i;\n}\n\nfunction find(data, k) {\n  for (var i = 0, s = '_' + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {\n    if (same(data[key].key, k)) return data[key];\n  }\n}\n\nfunction set(data, k, v) {\n  for (var i = 0, s = '_' + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {\n    if (same(data[key].key, k)) {\n      data[key].value = v;\n      return;\n    }\n  }\n\n  data.size++;\n  data[key] = new Entry(k, v, key);\n}\n\n/***/ }),\n\n/***/ 430:\n/***/ (function(module, exports) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  'use strict';\n\n  function _isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  }\n\n  function _getter(p) {\n    return function () {\n      return this[p];\n    };\n  }\n\n  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n  var numericProps = ['columnNumber', 'lineNumber'];\n  var stringProps = ['fileName', 'functionName', 'source'];\n  var arrayProps = ['args'];\n  var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n  function StackFrame(obj) {\n    if (!obj) return;\n\n    for (var i = 0; i < props.length; i++) {\n      if (obj[props[i]] !== undefined) {\n        this['set' + _capitalize(props[i])](obj[props[i]]);\n      }\n    }\n  }\n\n  StackFrame.prototype = {\n    getArgs: function getArgs() {\n      return this.args;\n    },\n    setArgs: function setArgs(v) {\n      if (Object.prototype.toString.call(v) !== '[object Array]') {\n        throw new TypeError('Args must be an Array');\n      }\n\n      this.args = v;\n    },\n    getEvalOrigin: function getEvalOrigin() {\n      return this.evalOrigin;\n    },\n    setEvalOrigin: function setEvalOrigin(v) {\n      if (v instanceof StackFrame) {\n        this.evalOrigin = v;\n      } else if (v instanceof Object) {\n        this.evalOrigin = new StackFrame(v);\n      } else {\n        throw new TypeError('Eval Origin must be an Object or StackFrame');\n      }\n    },\n    toString: function toString() {\n      var fileName = this.getFileName() || '';\n      var lineNumber = this.getLineNumber() || '';\n      var columnNumber = this.getColumnNumber() || '';\n      var functionName = this.getFunctionName() || '';\n\n      if (this.getIsEval()) {\n        if (fileName) {\n          return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n        }\n\n        return '[eval]:' + lineNumber + ':' + columnNumber;\n      }\n\n      if (functionName) {\n        return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n      }\n\n      return fileName + ':' + lineNumber + ':' + columnNumber;\n    }\n  };\n\n  StackFrame.fromString = function StackFrame$$fromString(str) {\n    var argsStartIndex = str.indexOf('(');\n    var argsEndIndex = str.lastIndexOf(')');\n    var functionName = str.substring(0, argsStartIndex);\n    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n    var locationString = str.substring(argsEndIndex + 1);\n\n    if (locationString.indexOf('@') === 0) {\n      var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n      var fileName = parts[1];\n      var lineNumber = parts[2];\n      var columnNumber = parts[3];\n    }\n\n    return new StackFrame({\n      functionName: functionName,\n      args: args || undefined,\n      fileName: fileName,\n      lineNumber: lineNumber || undefined,\n      columnNumber: columnNumber || undefined\n    });\n  };\n\n  for (var i = 0; i < booleanProps.length; i++) {\n    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\n    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {\n      return function (v) {\n        this[p] = Boolean(v);\n      };\n    }(booleanProps[i]);\n  }\n\n  for (var j = 0; j < numericProps.length; j++) {\n    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\n    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {\n      return function (v) {\n        if (!_isNumber(v)) {\n          throw new TypeError(p + ' must be a Number');\n        }\n\n        this[p] = Number(v);\n      };\n    }(numericProps[j]);\n  }\n\n  for (var k = 0; k < stringProps.length; k++) {\n    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\n    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {\n      return function (v) {\n        this[p] = String(v);\n      };\n    }(stringProps[k]);\n  }\n\n  return StackFrame;\n});\n\n/***/ }),\n\n/***/ 718:\n/***/ ((module) => {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n\n    var TempCtor = function TempCtor() {};\n\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}\n\n/***/ }),\n\n/***/ 715:\n/***/ ((module) => {\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nmodule.exports = function isBuffer(arg) {\n  return arg && _typeof(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';\n};\n\n/***/ }),\n\n/***/ 82:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_75702__) => {\n\n/* provided dependency */ var process = __nested_webpack_require_75702__(169);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar formatRegExp = /%[sdj%]/g;\n\nexports.format = function (f) {\n  if (!isString(f)) {\n    var objects = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function (x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n\n    switch (x) {\n      case '%s':\n        return String(args[i++]);\n\n      case '%d':\n        return Number(args[i++]);\n\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n\n      default:\n        return x;\n    }\n  });\n\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n\n  return str;\n}; // Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\n\n\nexports.deprecate = function (fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function () {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n\n      warned = true;\n    }\n\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\nvar debugs = {};\nvar debugEnviron;\n\nexports.debuglog = function (set) {\n  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n\n      debugs[set] = function () {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function () {};\n    }\n  }\n\n  return debugs[set];\n};\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n\n/* legacy: obj, showHidden, depth, colors*/\n\n\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  }; // legacy...\n\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  } // set default options\n\n\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\nexports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\ninspect.colors = {\n  'bold': [1, 22],\n  'italic': [3, 23],\n  'underline': [4, 24],\n  'inverse': [7, 27],\n  'white': [37, 39],\n  'grey': [90, 39],\n  'black': [30, 39],\n  'blue': [34, 39],\n  'cyan': [36, 39],\n  'green': [32, 39],\n  'magenta': [35, 39],\n  'red': [31, 39],\n  'yellow': [33, 39]\n}; // Don't use 'blue' not visible on cmd.exe\n\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return \"\\x1B[\" + inspect.colors[style][0] + 'm' + str + \"\\x1B[\" + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\nfunction arrayToHash(array) {\n  var hash = {};\n  array.forEach(function (val, idx) {\n    hash[val] = true;\n  });\n  return hash;\n}\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special\n  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n  !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n\n    return ret;\n  } // Primitive types cannot have properties\n\n\n  var primitive = formatPrimitive(ctx, value);\n\n  if (primitive) {\n    return primitive;\n  } // Look up the keys of the object.\n\n\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  } // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\n\n  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  } // Some type of object without properties can be shortcutted.\n\n\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '',\n      array = false,\n      braces = ['{', '}']; // Make Array say that they are Array\n\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  } // Make functions say that they are functions\n\n\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  } // Make RegExps say that they are RegExps\n\n\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  } // Make dates with properties first say the date\n\n\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  } // Make error with message first say the error\n\n\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n  var output;\n\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function (key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n  return reduceToSingleString(output, base, braces);\n}\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n\n  if (isNumber(value)) return ctx.stylize('' + value, 'number');\n  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is \"object\", so special case here.\n\n  if (isNull(value)) return ctx.stylize('null', 'null');\n}\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n\n  keys.forEach(function (key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n    }\n  });\n  return output;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || {\n    value: value[key]\n  };\n\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function (line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function (line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n\n    name = JSON.stringify('' + key);\n\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function (prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n} // NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\n\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\n\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\n\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\n\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return _typeof(arg) === 'symbol';\n}\n\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\n\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return _typeof(arg) === 'object' && arg !== null;\n}\n\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\n\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n}\n\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol\n  typeof arg === 'undefined';\n}\n\nexports.isPrimitive = isPrimitive;\nexports.isBuffer = __nested_webpack_require_75702__(715);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34\n\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n} // log is just a thin wrapper to console.log that prepends a timestamp\n\n\nexports.log = function () {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\n\n\nexports.inherits = __nested_webpack_require_75702__(718);\n\nexports._extend = function (origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n  var keys = Object.keys(add);\n  var i = keys.length;\n\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/***/ }),\n\n/***/ 695:\n/***/ ((module) => {\n\nmodule.exports = Yallist;\nYallist.Node = Node;\nYallist.create = Yallist;\n\nfunction Yallist(list) {\n  var self = this;\n\n  if (!(self instanceof Yallist)) {\n    self = new Yallist();\n  }\n\n  self.tail = null;\n  self.head = null;\n  self.length = 0;\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item);\n    });\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i]);\n    }\n  }\n\n  return self;\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list');\n  }\n\n  var next = node.next;\n  var prev = node.prev;\n\n  if (next) {\n    next.prev = prev;\n  }\n\n  if (prev) {\n    prev.next = next;\n  }\n\n  if (node === this.head) {\n    this.head = next;\n  }\n\n  if (node === this.tail) {\n    this.tail = prev;\n  }\n\n  node.list.length--;\n  node.next = null;\n  node.prev = null;\n  node.list = null;\n};\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var head = this.head;\n  node.list = this;\n  node.next = head;\n\n  if (head) {\n    head.prev = node;\n  }\n\n  this.head = node;\n\n  if (!this.tail) {\n    this.tail = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var tail = this.tail;\n  node.list = this;\n  node.prev = tail;\n\n  if (tail) {\n    tail.next = node;\n  }\n\n  this.tail = node;\n\n  if (!this.head) {\n    this.head = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined;\n  }\n\n  var res = this.tail.value;\n  this.tail = this.tail.prev;\n\n  if (this.tail) {\n    this.tail.next = null;\n  } else {\n    this.head = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined;\n  }\n\n  var res = this.head.value;\n  this.head = this.head.next;\n\n  if (this.head) {\n    this.head.prev = null;\n  } else {\n    this.tail = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.next;\n  }\n};\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.prev;\n  }\n};\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.next;\n  }\n\n  return res;\n};\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.prev;\n  }\n\n  return res;\n};\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc;\n  var walker = this.head;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.head) {\n    walker = this.head.next;\n    acc = this.head.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.next;\n  }\n\n  return acc;\n};\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc;\n  var walker = this.tail;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.tail) {\n    walker = this.tail.prev;\n    acc = this.tail.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.prev;\n  }\n\n  return acc;\n};\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.next;\n  }\n\n  return arr;\n};\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.prev;\n  }\n\n  return arr;\n};\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next;\n  }\n\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev;\n  }\n\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.reverse = function () {\n  var head = this.head;\n  var tail = this.tail;\n\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev;\n    walker.prev = walker.next;\n    walker.next = p;\n  }\n\n  this.head = tail;\n  this.tail = head;\n  return this;\n};\n\nfunction push(self, item) {\n  self.tail = new Node(item, self.tail, null, self);\n\n  if (!self.head) {\n    self.head = self.tail;\n  }\n\n  self.length++;\n}\n\nfunction unshift(self, item) {\n  self.head = new Node(item, null, self.head, self);\n\n  if (!self.tail) {\n    self.tail = self.head;\n  }\n\n  self.length++;\n}\n\nfunction Node(value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list);\n  }\n\n  this.list = list;\n  this.value = value;\n\n  if (prev) {\n    prev.next = this;\n    this.prev = prev;\n  } else {\n    this.prev = null;\n  }\n\n  if (next) {\n    next.prev = this;\n    this.next = next;\n  } else {\n    this.next = null;\n  }\n}\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_99207__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_99207__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_99207__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__nested_webpack_require_99207__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_99207__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_99207__.o(definition, key) && !__nested_webpack_require_99207__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_99207__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_99207__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n(() => {\n\"use strict\";\n// ESM COMPAT FLAG\n__nested_webpack_require_99207__.r(__nested_webpack_exports__);\n\n// EXPORTS\n__nested_webpack_require_99207__.d(__nested_webpack_exports__, {\n  \"connectToDevTools\": () => (/* binding */ connectToDevTools)\n});\n\n;// CONCATENATED MODULE: ../react-devtools-shared/src/events.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar EventEmitter = /*#__PURE__*/function () {\n  function EventEmitter() {\n    _classCallCheck(this, EventEmitter);\n\n    _defineProperty(this, \"listenersMap\", new Map());\n  }\n\n  _createClass(EventEmitter, [{\n    key: \"addListener\",\n    value: function addListener(event, listener) {\n      var listeners = this.listenersMap.get(event);\n\n      if (listeners === undefined) {\n        this.listenersMap.set(event, [listener]);\n      } else {\n        var index = listeners.indexOf(listener);\n\n        if (index < 0) {\n          listeners.push(listener);\n        }\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      var listeners = this.listenersMap.get(event);\n\n      if (listeners !== undefined) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        if (listeners.length === 1) {\n          // No need to clone or try/catch\n          var listener = listeners[0];\n          listener.apply(null, args);\n        } else {\n          var didThrow = false;\n          var caughtError = null;\n          var clonedListeners = Array.from(listeners);\n\n          for (var i = 0; i < clonedListeners.length; i++) {\n            var _listener = clonedListeners[i];\n\n            try {\n              _listener.apply(null, args);\n            } catch (error) {\n              if (caughtError === null) {\n                didThrow = true;\n                caughtError = error;\n              }\n            }\n          }\n\n          if (didThrow) {\n            throw caughtError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.listenersMap.clear();\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(event, listener) {\n      var listeners = this.listenersMap.get(event);\n\n      if (listeners !== undefined) {\n        var index = listeners.indexOf(listener);\n\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n      }\n    }\n  }]);\n\n  return EventEmitter;\n}();\n\n\n// EXTERNAL MODULE: ../../node_modules/lodash.throttle/index.js\nvar lodash_throttle = __nested_webpack_require_99207__(172);\nvar lodash_throttle_default = /*#__PURE__*/__nested_webpack_require_99207__.n(lodash_throttle);\n;// CONCATENATED MODULE: ../react-devtools-shared/src/constants.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar CHROME_WEBSTORE_EXTENSION_ID = 'fmkadmapgofadopljbjfkapdkoienihi';\nvar INTERNAL_EXTENSION_ID = 'dnjnjgbfilfphmojnmhliehogmojhclc';\nvar LOCAL_EXTENSION_ID = 'ikiahnapldjmdmpkmfhjdjilojjhgcbf'; // Flip this flag to true to enable verbose console debug logging.\n\nvar __DEBUG__ = false; // Flip this flag to true to enable performance.mark() and performance.measure() timings.\n\nvar __PERFORMANCE_PROFILE__ = false;\nvar TREE_OPERATION_ADD = 1;\nvar TREE_OPERATION_REMOVE = 2;\nvar TREE_OPERATION_REORDER_CHILDREN = 3;\nvar TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;\nvar TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;\nvar TREE_OPERATION_REMOVE_ROOT = 6;\nvar TREE_OPERATION_SET_SUBTREE_MODE = 7;\nvar PROFILING_FLAG_BASIC_SUPPORT = 1;\nvar PROFILING_FLAG_TIMELINE_SUPPORT = 2;\nvar LOCAL_STORAGE_DEFAULT_TAB_KEY = 'React::DevTools::defaultTab';\nvar constants_LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';\nvar SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';\nvar constants_LOCAL_STORAGE_OPEN_IN_EDITOR_URL = 'React::DevTools::openInEditorUrl';\nvar LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET = 'React::DevTools::openInEditorUrlPreset';\nvar LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = 'React::DevTools::parseHookNames';\nvar SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';\nvar SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';\nvar constants_LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';\nvar LOCAL_STORAGE_BROWSER_THEME = 'React::DevTools::theme';\nvar constants_LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY = 'React::DevTools::appendComponentStack';\nvar constants_LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY = 'React::DevTools::showInlineWarningsAndErrors';\nvar LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';\nvar constants_LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE = 'React::DevTools::hideConsoleLogsInStrictMode';\nvar LOCAL_STORAGE_SUPPORTS_PROFILING_KEY = 'React::DevTools::supportsProfiling';\nvar PROFILER_EXPORT_VERSION = 5;\n;// CONCATENATED MODULE: ../react-devtools-shared/src/storage.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction storage_localStorageGetItem(key) {\n  try {\n    return localStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction localStorageRemoveItem(key) {\n  try {\n    localStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction storage_localStorageSetItem(key, value) {\n  try {\n    return localStorage.setItem(key, value);\n  } catch (error) {}\n}\nfunction sessionStorageGetItem(key) {\n  try {\n    return sessionStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction sessionStorageRemoveItem(key) {\n  try {\n    sessionStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction sessionStorageSetItem(key, value) {\n  try {\n    return sessionStorage.setItem(key, value);\n  } catch (error) {}\n}\n;// CONCATENATED MODULE: ../../node_modules/memoize-one/esm/index.js\nvar simpleIsEqual = function simpleIsEqual(a, b) {\n  return a === b;\n};\n\n/* harmony default export */ function esm(resultFn) {\n  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;\n  var lastThis = void 0;\n  var lastArgs = [];\n  var lastResult = void 0;\n  var calledOnce = false;\n\n  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {\n    return isEqual(newArg, lastArgs[index]);\n  };\n\n  var result = function result() {\n    for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {\n      return lastResult;\n    }\n\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    lastResult = resultFn.apply(this, newArgs);\n    return lastResult;\n  };\n\n  return result;\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/utils.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Get the window object for the document that a node belongs to,\n// or return null if it cannot be found (node not attached to DOM,\n// etc).\nfunction getOwnerWindow(node) {\n  if (!node.ownerDocument) {\n    return null;\n  }\n\n  return node.ownerDocument.defaultView;\n} // Get the iframe containing a node, or return null if it cannot\n// be found (node not within iframe, etc).\n\nfunction getOwnerIframe(node) {\n  var nodeWindow = getOwnerWindow(node);\n\n  if (nodeWindow) {\n    return nodeWindow.frameElement;\n  }\n\n  return null;\n} // Get a bounding client rect for a node, with an\n// offset added to compensate for its border.\n\nfunction getBoundingClientRectWithBorderOffset(node) {\n  var dimensions = getElementDimensions(node);\n  return mergeRectOffsets([node.getBoundingClientRect(), {\n    top: dimensions.borderTop,\n    left: dimensions.borderLeft,\n    bottom: dimensions.borderBottom,\n    right: dimensions.borderRight,\n    // This width and height won't get used by mergeRectOffsets (since this\n    // is not the first rect in the array), but we set them so that this\n    // object type checks as a ClientRect.\n    width: 0,\n    height: 0\n  }]);\n} // Add together the top, left, bottom, and right properties of\n// each ClientRect, but keep the width and height of the first one.\n\nfunction mergeRectOffsets(rects) {\n  return rects.reduce(function (previousRect, rect) {\n    if (previousRect == null) {\n      return rect;\n    }\n\n    return {\n      top: previousRect.top + rect.top,\n      left: previousRect.left + rect.left,\n      width: previousRect.width,\n      height: previousRect.height,\n      bottom: previousRect.bottom + rect.bottom,\n      right: previousRect.right + rect.right\n    };\n  });\n} // Calculate a boundingClientRect for a node relative to boundaryWindow,\n// taking into account any offsets caused by intermediate iframes.\n\nfunction getNestedBoundingClientRect(node, boundaryWindow) {\n  var ownerIframe = getOwnerIframe(node);\n\n  if (ownerIframe && ownerIframe !== boundaryWindow) {\n    var rects = [node.getBoundingClientRect()];\n    var currentIframe = ownerIframe;\n    var onlyOneMore = false;\n\n    while (currentIframe) {\n      var rect = getBoundingClientRectWithBorderOffset(currentIframe);\n      rects.push(rect);\n      currentIframe = getOwnerIframe(currentIframe);\n\n      if (onlyOneMore) {\n        break;\n      } // We don't want to calculate iframe offsets upwards beyond\n      // the iframe containing the boundaryWindow, but we\n      // need to calculate the offset relative to the boundaryWindow.\n\n\n      if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {\n        onlyOneMore = true;\n      }\n    }\n\n    return mergeRectOffsets(rects);\n  } else {\n    return node.getBoundingClientRect();\n  }\n}\nfunction getElementDimensions(domElement) {\n  var calculatedStyle = window.getComputedStyle(domElement);\n  return {\n    borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),\n    borderRight: parseInt(calculatedStyle.borderRightWidth, 10),\n    borderTop: parseInt(calculatedStyle.borderTopWidth, 10),\n    borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),\n    marginLeft: parseInt(calculatedStyle.marginLeft, 10),\n    marginRight: parseInt(calculatedStyle.marginRight, 10),\n    marginTop: parseInt(calculatedStyle.marginTop, 10),\n    marginBottom: parseInt(calculatedStyle.marginBottom, 10),\n    paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),\n    paddingRight: parseInt(calculatedStyle.paddingRight, 10),\n    paddingTop: parseInt(calculatedStyle.paddingTop, 10),\n    paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)\n  };\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js\nfunction Overlay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction Overlay_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Overlay_createClass(Constructor, protoProps, staticProps) { if (protoProps) Overlay_defineProperties(Constructor.prototype, protoProps); if (staticProps) Overlay_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar Overlay_assign = Object.assign; // Note that the Overlay components are not affected by the active Theme,\n// because they highlight elements in the main Chrome window (outside of devtools).\n// The colors below were chosen to roughly match those used by Chrome devtools.\n\nvar OverlayRect = /*#__PURE__*/function () {\n  function OverlayRect(doc, container) {\n    Overlay_classCallCheck(this, OverlayRect);\n\n    this.node = doc.createElement('div');\n    this.border = doc.createElement('div');\n    this.padding = doc.createElement('div');\n    this.content = doc.createElement('div');\n    this.border.style.borderColor = overlayStyles.border;\n    this.padding.style.borderColor = overlayStyles.padding;\n    this.content.style.backgroundColor = overlayStyles.background;\n    Overlay_assign(this.node.style, {\n      borderColor: overlayStyles.margin,\n      pointerEvents: 'none',\n      position: 'fixed'\n    });\n    this.node.style.zIndex = '10000000';\n    this.node.appendChild(this.border);\n    this.border.appendChild(this.padding);\n    this.padding.appendChild(this.content);\n    container.appendChild(this.node);\n  }\n\n  Overlay_createClass(OverlayRect, [{\n    key: \"remove\",\n    value: function remove() {\n      if (this.node.parentNode) {\n        this.node.parentNode.removeChild(this.node);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(box, dims) {\n      boxWrap(dims, 'margin', this.node);\n      boxWrap(dims, 'border', this.border);\n      boxWrap(dims, 'padding', this.padding);\n      Overlay_assign(this.content.style, {\n        height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + 'px',\n        width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + 'px'\n      });\n      Overlay_assign(this.node.style, {\n        top: box.top - dims.marginTop + 'px',\n        left: box.left - dims.marginLeft + 'px'\n      });\n    }\n  }]);\n\n  return OverlayRect;\n}();\n\nvar OverlayTip = /*#__PURE__*/function () {\n  function OverlayTip(doc, container) {\n    Overlay_classCallCheck(this, OverlayTip);\n\n    this.tip = doc.createElement('div');\n    Overlay_assign(this.tip.style, {\n      display: 'flex',\n      flexFlow: 'row nowrap',\n      backgroundColor: '#333740',\n      borderRadius: '2px',\n      fontFamily: '\"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace',\n      fontWeight: 'bold',\n      padding: '3px 5px',\n      pointerEvents: 'none',\n      position: 'fixed',\n      fontSize: '12px',\n      whiteSpace: 'nowrap'\n    });\n    this.nameSpan = doc.createElement('span');\n    this.tip.appendChild(this.nameSpan);\n    Overlay_assign(this.nameSpan.style, {\n      color: '#ee78e6',\n      borderRight: '1px solid #aaaaaa',\n      paddingRight: '0.5rem',\n      marginRight: '0.5rem'\n    });\n    this.dimSpan = doc.createElement('span');\n    this.tip.appendChild(this.dimSpan);\n    Overlay_assign(this.dimSpan.style, {\n      color: '#d7d7d7'\n    });\n    this.tip.style.zIndex = '10000000';\n    container.appendChild(this.tip);\n  }\n\n  Overlay_createClass(OverlayTip, [{\n    key: \"remove\",\n    value: function remove() {\n      if (this.tip.parentNode) {\n        this.tip.parentNode.removeChild(this.tip);\n      }\n    }\n  }, {\n    key: \"updateText\",\n    value: function updateText(name, width, height) {\n      this.nameSpan.textContent = name;\n      this.dimSpan.textContent = Math.round(width) + 'px  ' + Math.round(height) + 'px';\n    }\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(dims, bounds) {\n      var tipRect = this.tip.getBoundingClientRect();\n      var tipPos = findTipPos(dims, bounds, {\n        width: tipRect.width,\n        height: tipRect.height\n      });\n      Overlay_assign(this.tip.style, tipPos.style);\n    }\n  }]);\n\n  return OverlayTip;\n}();\n\nvar Overlay = /*#__PURE__*/function () {\n  function Overlay(agent) {\n    Overlay_classCallCheck(this, Overlay);\n\n    // Find the root window, because overlays are positioned relative to it.\n    var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n    this.window = currentWindow; // When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.\n\n    var tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n    this.tipBoundsWindow = tipBoundsWindow;\n    var doc = currentWindow.document;\n    this.container = doc.createElement('div');\n    this.container.style.zIndex = '10000000';\n    this.tip = new OverlayTip(doc, this.container);\n    this.rects = [];\n    this.agent = agent;\n    doc.body.appendChild(this.container);\n  }\n\n  Overlay_createClass(Overlay, [{\n    key: \"remove\",\n    value: function remove() {\n      this.tip.remove();\n      this.rects.forEach(function (rect) {\n        rect.remove();\n      });\n      this.rects.length = 0;\n\n      if (this.container.parentNode) {\n        this.container.parentNode.removeChild(this.container);\n      }\n    }\n  }, {\n    key: \"inspect\",\n    value: function inspect(nodes, name) {\n      var _this = this;\n\n      // We can't get the size of text nodes or comment nodes. React as of v15\n      // heavily uses comment nodes to delimit text.\n      var elements = nodes.filter(function (node) {\n        return node.nodeType === Node.ELEMENT_NODE;\n      });\n\n      while (this.rects.length > elements.length) {\n        var rect = this.rects.pop();\n        rect.remove();\n      }\n\n      if (elements.length === 0) {\n        return;\n      }\n\n      while (this.rects.length < elements.length) {\n        this.rects.push(new OverlayRect(this.window.document, this.container));\n      }\n\n      var outerBox = {\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        left: Number.POSITIVE_INFINITY\n      };\n      elements.forEach(function (element, index) {\n        var box = getNestedBoundingClientRect(element, _this.window);\n        var dims = getElementDimensions(element);\n        outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);\n        outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);\n        outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);\n        outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);\n        var rect = _this.rects[index];\n        rect.update(box, dims);\n      });\n\n      if (!name) {\n        name = elements[0].nodeName.toLowerCase();\n        var node = elements[0];\n        var rendererInterface = this.agent.getBestMatchingRendererInterface(node);\n\n        if (rendererInterface) {\n          var id = rendererInterface.getFiberIDForNative(node, true);\n\n          if (id) {\n            var ownerName = rendererInterface.getDisplayNameForFiberID(id, true);\n\n            if (ownerName) {\n              name += ' (in ' + ownerName + ')';\n            }\n          }\n        }\n      }\n\n      this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);\n      var tipBounds = getNestedBoundingClientRect(this.tipBoundsWindow.document.documentElement, this.window);\n      this.tip.updatePosition({\n        top: outerBox.top,\n        left: outerBox.left,\n        height: outerBox.bottom - outerBox.top,\n        width: outerBox.right - outerBox.left\n      }, {\n        top: tipBounds.top + this.tipBoundsWindow.scrollY,\n        left: tipBounds.left + this.tipBoundsWindow.scrollX,\n        height: this.tipBoundsWindow.innerHeight,\n        width: this.tipBoundsWindow.innerWidth\n      });\n    }\n  }]);\n\n  return Overlay;\n}();\n\n\n\nfunction findTipPos(dims, bounds, tipSize) {\n  var tipHeight = Math.max(tipSize.height, 20);\n  var tipWidth = Math.max(tipSize.width, 60);\n  var margin = 5;\n  var top;\n\n  if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {\n    if (dims.top + dims.height < bounds.top + 0) {\n      top = bounds.top + margin;\n    } else {\n      top = dims.top + dims.height + margin;\n    }\n  } else if (dims.top - tipHeight <= bounds.top + bounds.height) {\n    if (dims.top - tipHeight - margin < bounds.top + margin) {\n      top = bounds.top + margin;\n    } else {\n      top = dims.top - tipHeight - margin;\n    }\n  } else {\n    top = bounds.top + bounds.height - tipHeight - margin;\n  }\n\n  var left = dims.left + margin;\n\n  if (dims.left < bounds.left) {\n    left = bounds.left + margin;\n  }\n\n  if (dims.left + tipWidth > bounds.left + bounds.width) {\n    left = bounds.left + bounds.width - tipWidth - margin;\n  }\n\n  top += 'px';\n  left += 'px';\n  return {\n    style: {\n      top: top,\n      left: left\n    }\n  };\n}\n\nfunction boxWrap(dims, what, node) {\n  Overlay_assign(node.style, {\n    borderTopWidth: dims[what + 'Top'] + 'px',\n    borderLeftWidth: dims[what + 'Left'] + 'px',\n    borderRightWidth: dims[what + 'Right'] + 'px',\n    borderBottomWidth: dims[what + 'Bottom'] + 'px',\n    borderStyle: 'solid'\n  });\n}\n\nvar overlayStyles = {\n  background: 'rgba(120, 170, 210, 0.7)',\n  padding: 'rgba(77, 200, 0, 0.3)',\n  margin: 'rgba(255, 155, 0, 0.3)',\n  border: 'rgba(255, 200, 50, 0.3)'\n};\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar SHOW_DURATION = 2000;\nvar timeoutID = null;\nvar overlay = null;\nfunction hideOverlay(agent) {\n  if (window.document == null) {\n    agent.emit('hideNativeHighlight');\n    return;\n  }\n\n  timeoutID = null;\n\n  if (overlay !== null) {\n    overlay.remove();\n    overlay = null;\n  }\n}\nfunction showOverlay(elements, componentName, agent, hideAfterTimeout) {\n  if (window.document == null) {\n    if (elements != null && elements[0] != null) {\n      agent.emit('showNativeHighlight', elements[0]);\n    }\n\n    return;\n  }\n\n  if (timeoutID !== null) {\n    clearTimeout(timeoutID);\n  }\n\n  if (elements == null) {\n    return;\n  }\n\n  if (overlay === null) {\n    overlay = new Overlay(agent);\n  }\n\n  overlay.inspect(elements, componentName);\n\n  if (hideAfterTimeout) {\n    timeoutID = setTimeout(function () {\n      return hideOverlay(agent);\n    }, SHOW_DURATION);\n  }\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/index.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n// This plug-in provides in-page highlighting of the selected element.\n// It is used by the browser extension and the standalone DevTools shell (when connected to a browser).\n// It is not currently the mechanism used to highlight React Native views.\n// That is done by the React Native Inspector component.\nvar iframesListeningTo = new Set();\nfunction setupHighlighter(bridge, agent) {\n  bridge.addListener('clearNativeElementHighlight', clearNativeElementHighlight);\n  bridge.addListener('highlightNativeElement', highlightNativeElement);\n  bridge.addListener('shutdown', stopInspectingNative);\n  bridge.addListener('startInspectingNative', startInspectingNative);\n  bridge.addListener('stopInspectingNative', stopInspectingNative);\n\n  function startInspectingNative() {\n    registerListenersOnWindow(window);\n  }\n\n  function registerListenersOnWindow(window) {\n    // This plug-in may run in non-DOM environments (e.g. React Native).\n    if (window && typeof window.addEventListener === 'function') {\n      window.addEventListener('click', onClick, true);\n      window.addEventListener('mousedown', onMouseEvent, true);\n      window.addEventListener('mouseover', onMouseEvent, true);\n      window.addEventListener('mouseup', onMouseEvent, true);\n      window.addEventListener('pointerdown', onPointerDown, true);\n      window.addEventListener('pointermove', onPointerMove, true);\n      window.addEventListener('pointerup', onPointerUp, true);\n    } else {\n      agent.emit('startInspectingNative');\n    }\n  }\n\n  function stopInspectingNative() {\n    hideOverlay(agent);\n    removeListenersOnWindow(window);\n    iframesListeningTo.forEach(function (frame) {\n      try {\n        removeListenersOnWindow(frame.contentWindow);\n      } catch (error) {// This can error when the iframe is on a cross-origin.\n      }\n    });\n    iframesListeningTo = new Set();\n  }\n\n  function removeListenersOnWindow(window) {\n    // This plug-in may run in non-DOM environments (e.g. React Native).\n    if (window && typeof window.removeEventListener === 'function') {\n      window.removeEventListener('click', onClick, true);\n      window.removeEventListener('mousedown', onMouseEvent, true);\n      window.removeEventListener('mouseover', onMouseEvent, true);\n      window.removeEventListener('mouseup', onMouseEvent, true);\n      window.removeEventListener('pointerdown', onPointerDown, true);\n      window.removeEventListener('pointermove', onPointerMove, true);\n      window.removeEventListener('pointerup', onPointerUp, true);\n    } else {\n      agent.emit('stopInspectingNative');\n    }\n  }\n\n  function clearNativeElementHighlight() {\n    hideOverlay(agent);\n  }\n\n  function highlightNativeElement(_ref) {\n    var displayName = _ref.displayName,\n        hideAfterTimeout = _ref.hideAfterTimeout,\n        id = _ref.id,\n        openNativeElementsPanel = _ref.openNativeElementsPanel,\n        rendererID = _ref.rendererID,\n        scrollIntoView = _ref.scrollIntoView;\n    var renderer = agent.rendererInterfaces[rendererID];\n\n    if (renderer == null) {\n      console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      hideOverlay(agent);\n      return;\n    } // In some cases fiber may already be unmounted\n\n\n    if (!renderer.hasFiberWithId(id)) {\n      hideOverlay(agent);\n      return;\n    }\n\n    var nodes = renderer.findNativeNodesForFiberID(id);\n\n    if (nodes != null && nodes[0] != null) {\n      var node = nodes[0]; // $FlowFixMe[method-unbinding]\n\n      if (scrollIntoView && typeof node.scrollIntoView === 'function') {\n        // If the node isn't visible show it before highlighting it.\n        // We may want to reconsider this; it might be a little disruptive.\n        node.scrollIntoView({\n          block: 'nearest',\n          inline: 'nearest'\n        });\n      }\n\n      showOverlay(nodes, displayName, agent, hideAfterTimeout);\n\n      if (openNativeElementsPanel) {\n        window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;\n        bridge.send('syncSelectionToNativeElementsPanel');\n      }\n    } else {\n      hideOverlay(agent);\n    }\n  }\n\n  function onClick(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    stopInspectingNative();\n    bridge.send('stopInspectingNative', true);\n  }\n\n  function onMouseEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  function onPointerDown(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    selectFiberForNode(getEventTarget(event));\n  }\n\n  var lastHoveredNode = null;\n\n  function onPointerMove(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    var target = getEventTarget(event);\n    if (lastHoveredNode === target) return;\n    lastHoveredNode = target;\n\n    if (target.tagName === 'IFRAME') {\n      var iframe = target;\n\n      try {\n        if (!iframesListeningTo.has(iframe)) {\n          var _window = iframe.contentWindow;\n          registerListenersOnWindow(_window);\n          iframesListeningTo.add(iframe);\n        }\n      } catch (error) {// This can error when the iframe is on a cross-origin.\n      }\n    } // Don't pass the name explicitly.\n    // It will be inferred from DOM tag and Fiber owner.\n\n\n    showOverlay([target], null, agent, false);\n    selectFiberForNode(target);\n  }\n\n  function onPointerUp(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  var selectFiberForNode = lodash_throttle_default()(esm(function (node) {\n    var id = agent.getIDForNode(node);\n\n    if (id !== null) {\n      bridge.send('selectFiber', id);\n    }\n  }), 200, // Don't change the selection in the very first 200ms\n  // because those are usually unintentional as you lift the cursor.\n  {\n    leading: false\n  });\n\n  function getEventTarget(event) {\n    if (event.composed) {\n      return event.composedPath()[0];\n    }\n\n    return event.target;\n  }\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar OUTLINE_COLOR = '#f0f0f0'; // Note these colors are in sync with DevTools Profiler chart colors.\n\nvar COLORS = ['#37afa9', '#63b19e', '#80b393', '#97b488', '#abb67d', '#beb771', '#cfb965', '#dfba57', '#efbb49', '#febc38'];\nvar canvas = null;\nfunction draw(nodeToData, agent) {\n  if (window.document == null) {\n    var nodesToDraw = [];\n    iterateNodes(nodeToData, function (_, color, node) {\n      nodesToDraw.push({\n        node: node,\n        color: color\n      });\n    });\n    agent.emit('drawTraceUpdates', nodesToDraw);\n    return;\n  }\n\n  if (canvas === null) {\n    initialize();\n  }\n\n  var canvasFlow = canvas;\n  canvasFlow.width = window.innerWidth;\n  canvasFlow.height = window.innerHeight;\n  var context = canvasFlow.getContext('2d');\n  context.clearRect(0, 0, canvasFlow.width, canvasFlow.height);\n  iterateNodes(nodeToData, function (rect, color) {\n    if (rect !== null) {\n      drawBorder(context, rect, color);\n    }\n  });\n}\n\nfunction iterateNodes(nodeToData, execute) {\n  nodeToData.forEach(function (_ref, node) {\n    var count = _ref.count,\n        rect = _ref.rect;\n    var colorIndex = Math.min(COLORS.length - 1, count - 1);\n    var color = COLORS[colorIndex];\n    execute(rect, color, node);\n  });\n}\n\nfunction drawBorder(context, rect, color) {\n  var height = rect.height,\n      left = rect.left,\n      top = rect.top,\n      width = rect.width; // outline\n\n  context.lineWidth = 1;\n  context.strokeStyle = OUTLINE_COLOR;\n  context.strokeRect(left - 1, top - 1, width + 2, height + 2); // inset\n\n  context.lineWidth = 1;\n  context.strokeStyle = OUTLINE_COLOR;\n  context.strokeRect(left + 1, top + 1, width - 1, height - 1);\n  context.strokeStyle = color;\n  context.setLineDash([0]); // border\n\n  context.lineWidth = 1;\n  context.strokeRect(left, top, width - 1, height - 1);\n  context.setLineDash([0]);\n}\n\nfunction destroy(agent) {\n  if (window.document == null) {\n    agent.emit('disableTraceUpdates');\n    return;\n  }\n\n  if (canvas !== null) {\n    if (canvas.parentNode != null) {\n      canvas.parentNode.removeChild(canvas);\n    }\n\n    canvas = null;\n  }\n}\n\nfunction initialize() {\n  canvas = window.document.createElement('canvas');\n  canvas.style.cssText = \"\\n    xx-background-color: red;\\n    xx-opacity: 0.5;\\n    bottom: 0;\\n    left: 0;\\n    pointer-events: none;\\n    position: fixed;\\n    right: 0;\\n    top: 0;\\n    z-index: 1000000000;\\n  \";\n  var root = window.document.documentElement;\n  root.insertBefore(canvas, root.firstChild);\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/index.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n// How long the rect should be shown for?\nvar DISPLAY_DURATION = 250; // What's the longest we are willing to show the overlay for?\n// This can be important if we're getting a flurry of events (e.g. scroll update).\n\nvar MAX_DISPLAY_DURATION = 3000; // How long should a rect be considered valid for?\n\nvar REMEASUREMENT_AFTER_DURATION = 250; // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\nvar getCurrentTime = // $FlowFixMe[method-unbinding]\n(typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nvar nodeToData = new Map();\nvar agent = null;\nvar drawAnimationFrameID = null;\nvar isEnabled = false;\nvar redrawTimeoutID = null;\nfunction TraceUpdates_initialize(injectedAgent) {\n  agent = injectedAgent;\n  agent.addListener('traceUpdates', traceUpdates);\n}\nfunction toggleEnabled(value) {\n  isEnabled = value;\n\n  if (!isEnabled) {\n    nodeToData.clear();\n\n    if (drawAnimationFrameID !== null) {\n      cancelAnimationFrame(drawAnimationFrameID);\n      drawAnimationFrameID = null;\n    }\n\n    if (redrawTimeoutID !== null) {\n      clearTimeout(redrawTimeoutID);\n      redrawTimeoutID = null;\n    }\n\n    destroy(agent);\n  }\n}\n\nfunction traceUpdates(nodes) {\n  if (!isEnabled) {\n    return;\n  }\n\n  nodes.forEach(function (node) {\n    var data = nodeToData.get(node);\n    var now = getCurrentTime();\n    var lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;\n    var rect = data != null ? data.rect : null;\n\n    if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {\n      lastMeasuredAt = now;\n      rect = measureNode(node);\n    }\n\n    nodeToData.set(node, {\n      count: data != null ? data.count + 1 : 1,\n      expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,\n      lastMeasuredAt: lastMeasuredAt,\n      rect: rect\n    });\n  });\n\n  if (redrawTimeoutID !== null) {\n    clearTimeout(redrawTimeoutID);\n    redrawTimeoutID = null;\n  }\n\n  if (drawAnimationFrameID === null) {\n    drawAnimationFrameID = requestAnimationFrame(prepareToDraw);\n  }\n}\n\nfunction prepareToDraw() {\n  drawAnimationFrameID = null;\n  redrawTimeoutID = null;\n  var now = getCurrentTime();\n  var earliestExpiration = Number.MAX_VALUE; // Remove any items that have already expired.\n\n  nodeToData.forEach(function (data, node) {\n    if (data.expirationTime < now) {\n      nodeToData.delete(node);\n    } else {\n      earliestExpiration = Math.min(earliestExpiration, data.expirationTime);\n    }\n  });\n  draw(nodeToData, agent);\n\n  if (earliestExpiration !== Number.MAX_VALUE) {\n    redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);\n  }\n}\n\nfunction measureNode(node) {\n  if (!node || typeof node.getBoundingClientRect !== 'function') {\n    return null;\n  }\n\n  var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n  return getNestedBoundingClientRect(node, currentWindow);\n}\n;// CONCATENATED MODULE: ../../node_modules/compare-versions/lib/esm/index.js\nfunction esm_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { esm_typeof = function _typeof(obj) { return typeof obj; }; } else { esm_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return esm_typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nvar compareVersions = function compareVersions(v1, v2) {\n  // validate input and split into segments\n  var n1 = validateAndParse(v1);\n  var n2 = validateAndParse(v2); // pop off the patch\n\n  var p1 = n1.pop();\n  var p2 = n2.pop(); // validate numbers\n\n  var r = compareSegments(n1, n2);\n  if (r !== 0) return r; // validate pre-release\n\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\n\nvar validate = function validate(version) {\n  return typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n};\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\n\nvar compare = function compare(v1, v2, operator) {\n  // validate input operator\n  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n\n  var res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\n\nvar satisfies = function satisfies(version, range) {\n  // if no range operator then \"=\"\n  var m = range.match(/^([<>=~^]+)/);\n  var op = m ? m[1] : '='; // if gt/lt/eq then operator compare\n\n  if (op !== '^' && op !== '~') return compare(version, range, op); // else range of either \"~\" or \"^\" is assumed\n\n  var _validateAndParse = validateAndParse(version),\n      _validateAndParse2 = _slicedToArray(_validateAndParse, 5),\n      v1 = _validateAndParse2[0],\n      v2 = _validateAndParse2[1],\n      v3 = _validateAndParse2[2],\n      vp = _validateAndParse2[4];\n\n  var _validateAndParse3 = validateAndParse(range),\n      _validateAndParse4 = _slicedToArray(_validateAndParse3, 5),\n      r1 = _validateAndParse4[0],\n      r2 = _validateAndParse4[1],\n      r3 = _validateAndParse4[2],\n      rp = _validateAndParse4[4];\n\n  var v = [v1, v2, v3];\n  var r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x']; // validate pre-release\n\n  if (rp) {\n    if (!vp) return false;\n    if (compareSegments(v, r) !== 0) return false;\n    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;\n  } // first non-zero number\n\n\n  var nonZero = r.findIndex(function (v) {\n    return v !== '0';\n  }) + 1; // pointer to where segments can be >=\n\n  var i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1; // before pointer must be equal\n\n  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false; // after pointer must be >=\n\n  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;\n  return true;\n};\nvar semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nvar validateAndParse = function validateAndParse(version) {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n\n  var match = version.match(semver);\n\n  if (!match) {\n    throw new Error(\"Invalid argument not valid semver ('\".concat(version, \"' received)\"));\n  }\n\n  match.shift();\n  return match;\n};\n\nvar isWildcard = function isWildcard(s) {\n  return s === '*' || s === 'x' || s === 'X';\n};\n\nvar tryParse = function tryParse(v) {\n  var n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nvar forceType = function forceType(a, b) {\n  return esm_typeof(a) !== esm_typeof(b) ? [String(a), String(b)] : [a, b];\n};\n\nvar compareStrings = function compareStrings(a, b) {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n\n  var _forceType = forceType(tryParse(a), tryParse(b)),\n      _forceType2 = _slicedToArray(_forceType, 2),\n      ap = _forceType2[0],\n      bp = _forceType2[1];\n\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nvar compareSegments = function compareSegments(a, b) {\n  for (var i = 0; i < Math.max(a.length, b.length); i++) {\n    var r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n\n  return 0;\n};\n\nvar operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nvar allowedOperators = Object.keys(operatorResMap);\n\nvar assertValidOperator = function assertValidOperator(op) {\n  if (typeof op !== 'string') {\n    throw new TypeError(\"Invalid operator type, expected string but got \".concat(esm_typeof(op)));\n  }\n\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\"Invalid operator, expected one of \".concat(allowedOperators.join('|')));\n  }\n};\n// EXTERNAL MODULE: ../../node_modules/lru-cache/index.js\nvar lru_cache = __nested_webpack_require_99207__(730);\nvar lru_cache_default = /*#__PURE__*/__nested_webpack_require_99207__.n(lru_cache);\n// EXTERNAL MODULE: ../../build/oss-experimental/react-is/index.js\nvar react_is = __nested_webpack_require_99207__(550);\n;// CONCATENATED MODULE: ../shared/ReactSymbols.js\nfunction ReactSymbols_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { ReactSymbols_typeof = function _typeof(obj) { return typeof obj; }; } else { ReactSymbols_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return ReactSymbols_typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_SCOPE_TYPE = Symbol.for('react.scope');\nvar REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\nvar REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');\nvar REACT_POSTPONE_TYPE = Symbol.for('react.postpone');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || ReactSymbols_typeof(maybeIterable) !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/frontend/types.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * WARNING:\n * This file contains types that are designed for React DevTools UI and how it interacts with the backend.\n * They might be used in different versions of DevTools backends.\n * Be mindful of backwards compatibility when making changes.\n */\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new element types are added, use new numbers rather than re-ordering existing ones.\n//\n// Changing these types is also a backwards breaking change for the standalone shell,\n// since the frontend and backend must share the same values-\n// and the backend is embedded in certain environments (like React Native).\nvar types_ElementTypeClass = 1;\nvar ElementTypeContext = 2;\nvar types_ElementTypeFunction = 5;\nvar types_ElementTypeForwardRef = 6;\nvar ElementTypeHostComponent = 7;\nvar types_ElementTypeMemo = 8;\nvar ElementTypeOtherOrUnknown = 9;\nvar ElementTypeProfiler = 10;\nvar ElementTypeRoot = 11;\nvar ElementTypeSuspense = 12;\nvar ElementTypeSuspenseList = 13;\nvar ElementTypeTracingMarker = 14; // Different types of elements displayed in the Elements tree.\n// These types may be used to visually distinguish types,\n// or to enable/disable certain functionality.\n\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new filter types are added, use new numbers rather than re-ordering existing ones.\nvar ComponentFilterElementType = 1;\nvar ComponentFilterDisplayName = 2;\nvar ComponentFilterLocation = 3;\nvar ComponentFilterHOC = 4;\nvar StrictMode = 1; // Each element on the frontend corresponds to a Fiber on the backend.\n// Some of its information (e.g. id, type, displayName) come from the backend.\n// Other bits (e.g. weight and depth) are computed on the frontend for windowing and display purposes.\n// Elements are updated on a push basis meaning the backend pushes updates to the frontend when needed.\n;// CONCATENATED MODULE: ../react-devtools-shared/src/isArray.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar isArray = Array.isArray;\n/* harmony default export */ const src_isArray = (isArray);\n;// CONCATENATED MODULE: ../react-devtools-shared/src/utils.js\n/* provided dependency */ var process = __nested_webpack_require_99207__(169);\nfunction utils_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return utils_typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || utils_unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return utils_arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return utils_arrayLikeToArray(arr); }\n\nfunction utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n// $FlowFixMe[method-unbinding]\nvar utils_hasOwnProperty = Object.prototype.hasOwnProperty;\nvar cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.\n// Try to reuse the already encoded strings.\n\nvar encodedStringCache = new (lru_cache_default())({\n  max: 1000\n});\nfunction alphaSortKeys(a, b) {\n  if (a.toString() > b.toString()) {\n    return 1;\n  } else if (b.toString() > a.toString()) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\nfunction getAllEnumerableKeys(obj) {\n  var keys = new Set();\n  var current = obj;\n\n  var _loop = function _loop() {\n    var currentKeys = [].concat(_toConsumableArray(Object.keys(current)), _toConsumableArray(Object.getOwnPropertySymbols(current)));\n    var descriptors = Object.getOwnPropertyDescriptors(current);\n    currentKeys.forEach(function (key) {\n      // $FlowFixMe[incompatible-type]: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n      if (descriptors[key].enumerable) {\n        keys.add(key);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  };\n\n  while (current != null) {\n    _loop();\n  }\n\n  return keys;\n} // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37\n\nfunction getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {\n  var displayName = outerType.displayName;\n  return displayName || \"\".concat(wrapperName, \"(\").concat(getDisplayName(innerType, fallbackName), \")\");\n}\nfunction getDisplayName(type) {\n  var fallbackName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Anonymous';\n  var nameFromCache = cachedDisplayNames.get(type);\n\n  if (nameFromCache != null) {\n    return nameFromCache;\n  }\n\n  var displayName = fallbackName; // The displayName property is not guaranteed to be a string.\n  // It's only safe to use for our purposes if it's a string.\n  // github.com/facebook/react-devtools/issues/803\n\n  if (typeof type.displayName === 'string') {\n    displayName = type.displayName;\n  } else if (typeof type.name === 'string' && type.name !== '') {\n    displayName = type.name;\n  }\n\n  cachedDisplayNames.set(type, displayName);\n  return displayName;\n}\nvar uidCounter = 0;\nfunction getUID() {\n  return ++uidCounter;\n}\nfunction utfDecodeString(array) {\n  // Avoid spreading the array (e.g. String.fromCodePoint(...array))\n  // Functions arguments are first placed on the stack before the function is called\n  // which throws a RangeError for large arrays.\n  // See github.com/facebook/react/issues/22293\n  var string = '';\n\n  for (var i = 0; i < array.length; i++) {\n    var char = array[i];\n    string += String.fromCodePoint(char);\n  }\n\n  return string;\n}\n\nfunction surrogatePairToCodePoint(charCode1, charCode2) {\n  return ((charCode1 & 0x3ff) << 10) + (charCode2 & 0x3ff) + 0x10000;\n} // Credit for this encoding approach goes to Tim Down:\n// https://stackoverflow.com/questions/4877326/how-can-i-tell-if-a-string-contains-multibyte-characters-in-javascript\n\n\nfunction utfEncodeString(string) {\n  var cached = encodedStringCache.get(string);\n\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  var encoded = [];\n  var i = 0;\n  var charCode;\n\n  while (i < string.length) {\n    charCode = string.charCodeAt(i); // Handle multibyte unicode characters (like emoji).\n\n    if ((charCode & 0xf800) === 0xd800) {\n      encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));\n    } else {\n      encoded.push(charCode);\n    }\n\n    ++i;\n  }\n\n  encodedStringCache.set(string, encoded);\n  return encoded;\n}\nfunction printOperationsArray(operations) {\n  // The first two values are always rendererID and rootID\n  var rendererID = operations[0];\n  var rootID = operations[1];\n  var logs = [\"operations for renderer:\".concat(rendererID, \" and root:\").concat(rootID)];\n  var i = 2; // Reassemble the string table.\n\n  var stringTable = [null // ID = 0 corresponds to the null string.\n  ];\n  var stringTableSize = operations[i++];\n  var stringTableEnd = i + stringTableSize;\n\n  while (i < stringTableEnd) {\n    var nextLength = operations[i++];\n    var nextString = utfDecodeString(operations.slice(i, i + nextLength));\n    stringTable.push(nextString);\n    i += nextLength;\n  }\n\n  while (i < operations.length) {\n    var operation = operations[i];\n\n    switch (operation) {\n      case TREE_OPERATION_ADD:\n        {\n          var _id = operations[i + 1];\n          var type = operations[i + 2];\n          i += 3;\n\n          if (type === ElementTypeRoot) {\n            logs.push(\"Add new root node \".concat(_id));\n            i++; // isStrictModeCompliant\n\n            i++; // supportsProfiling\n\n            i++; // supportsStrictMode\n\n            i++; // hasOwnerMetadata\n          } else {\n            var parentID = operations[i];\n            i++;\n            i++; // ownerID\n\n            var displayNameStringID = operations[i];\n            var displayName = stringTable[displayNameStringID];\n            i++;\n            i++; // key\n\n            logs.push(\"Add node \".concat(_id, \" (\").concat(displayName || 'null', \") as child of \").concat(parentID));\n          }\n\n          break;\n        }\n\n      case TREE_OPERATION_REMOVE:\n        {\n          var removeLength = operations[i + 1];\n          i += 2;\n\n          for (var removeIndex = 0; removeIndex < removeLength; removeIndex++) {\n            var _id2 = operations[i];\n            i += 1;\n            logs.push(\"Remove node \".concat(_id2));\n          }\n\n          break;\n        }\n\n      case TREE_OPERATION_REMOVE_ROOT:\n        {\n          i += 1;\n          logs.push(\"Remove root \".concat(rootID));\n          break;\n        }\n\n      case TREE_OPERATION_SET_SUBTREE_MODE:\n        {\n          var _id3 = operations[i + 1];\n          var mode = operations[i + 1];\n          i += 3;\n          logs.push(\"Mode \".concat(mode, \" set for subtree with root \").concat(_id3));\n          break;\n        }\n\n      case TREE_OPERATION_REORDER_CHILDREN:\n        {\n          var _id4 = operations[i + 1];\n          var numChildren = operations[i + 2];\n          i += 3;\n          var children = operations.slice(i, i + numChildren);\n          i += numChildren;\n          logs.push(\"Re-order node \".concat(_id4, \" children \").concat(children.join(',')));\n          break;\n        }\n\n      case TREE_OPERATION_UPDATE_TREE_BASE_DURATION:\n        // Base duration updates are only sent while profiling is in progress.\n        // We can ignore them at this point.\n        // The profiler UI uses them lazily in order to generate the tree.\n        i += 3;\n        break;\n\n      case TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:\n        var id = operations[i + 1];\n        var numErrors = operations[i + 2];\n        var numWarnings = operations[i + 3];\n        i += 4;\n        logs.push(\"Node \".concat(id, \" has \").concat(numErrors, \" errors and \").concat(numWarnings, \" warnings\"));\n        break;\n\n      default:\n        throw Error(\"Unsupported Bridge operation \\\"\".concat(operation, \"\\\"\"));\n    }\n  }\n\n  console.log(logs.join('\\n  '));\n}\nfunction getDefaultComponentFilters() {\n  return [{\n    type: ComponentFilterElementType,\n    value: ElementTypeHostComponent,\n    isEnabled: true\n  }];\n}\nfunction getSavedComponentFilters() {\n  try {\n    var raw = localStorageGetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return getDefaultComponentFilters();\n}\nfunction setSavedComponentFilters(componentFilters) {\n  localStorageSetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY, JSON.stringify(componentFilters));\n}\n\nfunction parseBool(s) {\n  if (s === 'true') {\n    return true;\n  }\n\n  if (s === 'false') {\n    return false;\n  }\n}\n\nfunction castBool(v) {\n  if (v === true || v === false) {\n    return v;\n  }\n}\nfunction castBrowserTheme(v) {\n  if (v === 'light' || v === 'dark' || v === 'auto') {\n    return v;\n  }\n}\nfunction getAppendComponentStack() {\n  var _parseBool;\n\n  var raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY);\n  return (_parseBool = parseBool(raw)) !== null && _parseBool !== void 0 ? _parseBool : true;\n}\nfunction getBreakOnConsoleErrors() {\n  var _parseBool2;\n\n  var raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS);\n  return (_parseBool2 = parseBool(raw)) !== null && _parseBool2 !== void 0 ? _parseBool2 : false;\n}\nfunction getHideConsoleLogsInStrictMode() {\n  var _parseBool3;\n\n  var raw = localStorageGetItem(LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE);\n  return (_parseBool3 = parseBool(raw)) !== null && _parseBool3 !== void 0 ? _parseBool3 : false;\n}\nfunction getShowInlineWarningsAndErrors() {\n  var _parseBool4;\n\n  var raw = localStorageGetItem(LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY);\n  return (_parseBool4 = parseBool(raw)) !== null && _parseBool4 !== void 0 ? _parseBool4 : true;\n}\nfunction getDefaultOpenInEditorURL() {\n  return typeof process.env.EDITOR_URL === 'string' ? process.env.EDITOR_URL : '';\n}\nfunction getOpenInEditorURL() {\n  try {\n    var raw = localStorageGetItem(LOCAL_STORAGE_OPEN_IN_EDITOR_URL);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return getDefaultOpenInEditorURL();\n}\nfunction separateDisplayNameAndHOCs(displayName, type) {\n  if (displayName === null) {\n    return [null, null];\n  }\n\n  var hocDisplayNames = null;\n\n  switch (type) {\n    case ElementTypeClass:\n    case ElementTypeForwardRef:\n    case ElementTypeFunction:\n    case ElementTypeMemo:\n      if (displayName.indexOf('(') >= 0) {\n        var matches = displayName.match(/[^()]+/g);\n\n        if (matches != null) {\n          displayName = matches.pop();\n          hocDisplayNames = matches;\n        }\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  return [displayName, hocDisplayNames];\n} // Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction utils_getInObject(object, path) {\n  return path.reduce(function (reduced, attr) {\n    if (reduced) {\n      if (utils_hasOwnProperty.call(reduced, attr)) {\n        return reduced[attr];\n      }\n\n      if (typeof reduced[Symbol.iterator] === 'function') {\n        // Convert iterable to array and return array[index]\n        //\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        return Array.from(reduced)[attr];\n      }\n    }\n\n    return null;\n  }, object);\n}\nfunction deletePathInObject(object, path) {\n  var length = path.length;\n  var last = path[length - 1];\n\n  if (object != null) {\n    var parent = utils_getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      if (src_isArray(parent)) {\n        parent.splice(last, 1);\n      } else {\n        delete parent[last];\n      }\n    }\n  }\n}\nfunction renamePathInObject(object, oldPath, newPath) {\n  var length = oldPath.length;\n\n  if (object != null) {\n    var parent = utils_getInObject(object, oldPath.slice(0, length - 1));\n\n    if (parent) {\n      var lastOld = oldPath[length - 1];\n      var lastNew = newPath[length - 1];\n      parent[lastNew] = parent[lastOld];\n\n      if (src_isArray(parent)) {\n        parent.splice(lastOld, 1);\n      } else {\n        delete parent[lastOld];\n      }\n    }\n  }\n}\nfunction utils_setInObject(object, path, value) {\n  var length = path.length;\n  var last = path[length - 1];\n\n  if (object != null) {\n    var parent = utils_getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      parent[last] = value;\n    }\n  }\n}\n\n/**\n * Get a enhanced/artificial type string based on the object instance\n */\nfunction getDataType(data) {\n  if (data === null) {\n    return 'null';\n  } else if (data === undefined) {\n    return 'undefined';\n  }\n\n  if ((0,react_is.isElement)(data)) {\n    return 'react_element';\n  }\n\n  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {\n    return 'html_element';\n  }\n\n  var type = utils_typeof(data);\n\n  switch (type) {\n    case 'bigint':\n      return 'bigint';\n\n    case 'boolean':\n      return 'boolean';\n\n    case 'function':\n      return 'function';\n\n    case 'number':\n      if (Number.isNaN(data)) {\n        return 'nan';\n      } else if (!Number.isFinite(data)) {\n        return 'infinity';\n      } else {\n        return 'number';\n      }\n\n    case 'object':\n      if (src_isArray(data)) {\n        return 'array';\n      } else if (ArrayBuffer.isView(data)) {\n        return utils_hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';\n      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {\n        // HACK This ArrayBuffer check is gross; is there a better way?\n        // We could try to create a new DataView with the value.\n        // If it doesn't error, we know it's an ArrayBuffer,\n        // but this seems kind of awkward and expensive.\n        return 'array_buffer';\n      } else if (typeof data[Symbol.iterator] === 'function') {\n        var iterator = data[Symbol.iterator]();\n\n        if (!iterator) {// Proxies might break assumptoins about iterators.\n          // See github.com/facebook/react/issues/21654\n        } else {\n          return iterator === data ? 'opaque_iterator' : 'iterator';\n        }\n      } else if (data.constructor && data.constructor.name === 'RegExp') {\n        return 'regexp';\n      } else {\n        // $FlowFixMe[method-unbinding]\n        var toStringValue = Object.prototype.toString.call(data);\n\n        if (toStringValue === '[object Date]') {\n          return 'date';\n        } else if (toStringValue === '[object HTMLAllCollection]') {\n          return 'html_all_collection';\n        }\n      }\n\n      if (!isPlainObject(data)) {\n        return 'class_instance';\n      }\n\n      return 'object';\n\n    case 'string':\n      return 'string';\n\n    case 'symbol':\n      return 'symbol';\n\n    case 'undefined':\n      if ( // $FlowFixMe[method-unbinding]\n      Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {\n        return 'html_all_collection';\n      }\n\n      return 'undefined';\n\n    default:\n      return 'unknown';\n  }\n}\nfunction getDisplayNameForReactElement(element) {\n  var elementType = (0,react_is.typeOf)(element);\n\n  switch (elementType) {\n    case react_is.ContextConsumer:\n      return 'ContextConsumer';\n\n    case react_is.ContextProvider:\n      return 'ContextProvider';\n\n    case react_is.ForwardRef:\n      return 'ForwardRef';\n\n    case react_is.Fragment:\n      return 'Fragment';\n\n    case react_is.Lazy:\n      return 'Lazy';\n\n    case react_is.Memo:\n      return 'Memo';\n\n    case react_is.Portal:\n      return 'Portal';\n\n    case react_is.Profiler:\n      return 'Profiler';\n\n    case react_is.StrictMode:\n      return 'StrictMode';\n\n    case react_is.Suspense:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_TRACING_MARKER_TYPE:\n      return 'TracingMarker';\n\n    default:\n      var type = element.type;\n\n      if (typeof type === 'string') {\n        return type;\n      } else if (typeof type === 'function') {\n        return getDisplayName(type, 'Anonymous');\n      } else if (type != null) {\n        return 'NotImplementedInDevtools';\n      } else {\n        return 'Element';\n      }\n\n  }\n}\nvar MAX_PREVIEW_STRING_LENGTH = 50;\n\nfunction truncateForDisplay(string) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_PREVIEW_STRING_LENGTH;\n\n  if (string.length > length) {\n    return string.slice(0, length) + '';\n  } else {\n    return string;\n  }\n} // Attempts to mimic Chrome's inline preview for values.\n// For example, the following value...\n//   {\n//      foo: 123,\n//      bar: \"abc\",\n//      baz: [true, false],\n//      qux: { ab: 1, cd: 2 }\n//   };\n//\n// Would show a preview of...\n//   {foo: 123, bar: \"abc\", baz: Array(2), qux: {}}\n//\n// And the following value...\n//   [\n//     123,\n//     \"abc\",\n//     [true, false],\n//     { foo: 123, bar: \"abc\" }\n//   ];\n//\n// Would show a preview of...\n//   [123, \"abc\", Array(2), {}]\n\n\nfunction formatDataForPreview(data, showFormattedValue) {\n  if (data != null && utils_hasOwnProperty.call(data, meta.type)) {\n    return showFormattedValue ? data[meta.preview_long] : data[meta.preview_short];\n  }\n\n  var type = getDataType(data);\n\n  switch (type) {\n    case 'html_element':\n      return \"<\".concat(truncateForDisplay(data.tagName.toLowerCase()), \" />\");\n\n    case 'function':\n      return truncateForDisplay(\"\\u0192 \".concat(typeof data.name === 'function' ? '' : data.name, \"() {}\"));\n\n    case 'string':\n      return \"\\\"\".concat(data, \"\\\"\");\n\n    case 'bigint':\n      return truncateForDisplay(data.toString() + 'n');\n\n    case 'regexp':\n      return truncateForDisplay(data.toString());\n\n    case 'symbol':\n      return truncateForDisplay(data.toString());\n\n    case 'react_element':\n      return \"<\".concat(truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown'), \" />\");\n\n    case 'array_buffer':\n      return \"ArrayBuffer(\".concat(data.byteLength, \")\");\n\n    case 'data_view':\n      return \"DataView(\".concat(data.buffer.byteLength, \")\");\n\n    case 'array':\n      if (showFormattedValue) {\n        var formatted = '';\n\n        for (var i = 0; i < data.length; i++) {\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += formatDataForPreview(data[i], false);\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return \"[\".concat(truncateForDisplay(formatted), \"]\");\n      } else {\n        var length = utils_hasOwnProperty.call(data, meta.size) ? data[meta.size] : data.length;\n        return \"Array(\".concat(length, \")\");\n      }\n\n    case 'typed_array':\n      var shortName = \"\".concat(data.constructor.name, \"(\").concat(data.length, \")\");\n\n      if (showFormattedValue) {\n        var _formatted = '';\n\n        for (var _i = 0; _i < data.length; _i++) {\n          if (_i > 0) {\n            _formatted += ', ';\n          }\n\n          _formatted += data[_i];\n\n          if (_formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return \"\".concat(shortName, \" [\").concat(truncateForDisplay(_formatted), \"]\");\n      } else {\n        return shortName;\n      }\n\n    case 'iterator':\n      var name = data.constructor.name;\n\n      if (showFormattedValue) {\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        var array = Array.from(data);\n        var _formatted2 = '';\n\n        for (var _i2 = 0; _i2 < array.length; _i2++) {\n          var entryOrEntries = array[_i2];\n\n          if (_i2 > 0) {\n            _formatted2 += ', ';\n          } // TRICKY\n          // Browsers display Maps and Sets differently.\n          // To mimic their behavior, detect if we've been given an entries tuple.\n          //   Map(2) {\"abc\" => 123, \"def\" => 123}\n          //   Set(2) {\"abc\", 123}\n\n\n          if (src_isArray(entryOrEntries)) {\n            var key = formatDataForPreview(entryOrEntries[0], true);\n            var value = formatDataForPreview(entryOrEntries[1], false);\n            _formatted2 += \"\".concat(key, \" => \").concat(value);\n          } else {\n            _formatted2 += formatDataForPreview(entryOrEntries, false);\n          }\n\n          if (_formatted2.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return \"\".concat(name, \"(\").concat(data.size, \") {\").concat(truncateForDisplay(_formatted2), \"}\");\n      } else {\n        return \"\".concat(name, \"(\").concat(data.size, \")\");\n      }\n\n    case 'opaque_iterator':\n      {\n        return data[Symbol.toStringTag];\n      }\n\n    case 'date':\n      return data.toString();\n\n    case 'class_instance':\n      return data.constructor.name;\n\n    case 'object':\n      if (showFormattedValue) {\n        var keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);\n        var _formatted3 = '';\n\n        for (var _i3 = 0; _i3 < keys.length; _i3++) {\n          var _key = keys[_i3];\n\n          if (_i3 > 0) {\n            _formatted3 += ', ';\n          }\n\n          _formatted3 += \"\".concat(_key.toString(), \": \").concat(formatDataForPreview(data[_key], false));\n\n          if (_formatted3.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return \"{\".concat(truncateForDisplay(_formatted3), \"}\");\n      } else {\n        return '{}';\n      }\n\n    case 'boolean':\n    case 'number':\n    case 'infinity':\n    case 'nan':\n    case 'null':\n    case 'undefined':\n      return data;\n\n    default:\n      try {\n        return truncateForDisplay(String(data));\n      } catch (error) {\n        return 'unserializable';\n      }\n\n  }\n} // Basically checking that the object only has Object in its prototype chain\n\nvar isPlainObject = function isPlainObject(object) {\n  var objectPrototype = Object.getPrototypeOf(object);\n  if (!objectPrototype) return true;\n  var objectParentPrototype = Object.getPrototypeOf(objectPrototype);\n  return !objectParentPrototype;\n};\n;// CONCATENATED MODULE: ../react-devtools-shared/src/hydration.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { hydration_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction hydration_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar meta = {\n  inspectable: Symbol('inspectable'),\n  inspected: Symbol('inspected'),\n  name: Symbol('name'),\n  preview_long: Symbol('preview_long'),\n  preview_short: Symbol('preview_short'),\n  readonly: Symbol('readonly'),\n  size: Symbol('size'),\n  type: Symbol('type'),\n  unserializable: Symbol('unserializable')\n};\n// This threshold determines the depth at which the bridge \"dehydrates\" nested data.\n// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,\n// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).\n//\n// Reducing this threshold will improve the speed of initial component inspection,\n// but may decrease the responsiveness of expanding objects/arrays to inspect further.\nvar LEVEL_THRESHOLD = 2;\n/**\n * Generate the dehydrated metadata for complex object instances\n */\n\nfunction createDehydrated(type, inspectable, data, cleaned, path) {\n  cleaned.push(path);\n  var dehydrated = {\n    inspectable: inspectable,\n    type: type,\n    preview_long: formatDataForPreview(data, true),\n    preview_short: formatDataForPreview(data, false),\n    name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name\n  };\n\n  if (type === 'array' || type === 'typed_array') {\n    dehydrated.size = data.length;\n  } else if (type === 'object') {\n    dehydrated.size = Object.keys(data).length;\n  }\n\n  if (type === 'iterator' || type === 'typed_array') {\n    dehydrated.readonly = true;\n  }\n\n  return dehydrated;\n}\n/**\n * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).\n * The paths of the stripped out objects are appended to the `cleaned` list.\n * On the other side of the barrier, the cleaned list is used to \"re-hydrate\" the cleaned representation into\n * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.\n *\n * Input: {\"some\": {\"attr\": fn()}, \"other\": AnInstance}\n * Output: {\n *   \"some\": {\n *     \"attr\": {\"name\": the fn.name, type: \"function\"}\n *   },\n *   \"other\": {\n *     \"name\": \"AnInstance\",\n *     \"type\": \"object\",\n *   },\n * }\n * and cleaned = [[\"some\", \"attr\"], [\"other\"]]\n */\n\n\nfunction dehydrate(data, cleaned, unserializable, path, isPathAllowed) {\n  var level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var type = getDataType(data);\n  var isPathAllowedCheck;\n\n  switch (type) {\n    case 'html_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: data.tagName,\n        type: type\n      };\n\n    case 'function':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,\n        type: type\n      };\n\n    case 'string':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (isPathAllowedCheck) {\n        return data;\n      } else {\n        return data.length <= 500 ? data : data.slice(0, 500) + '...';\n      }\n\n    case 'bigint':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: data.toString(),\n        type: type\n      };\n\n    case 'symbol':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: data.toString(),\n        type: type\n      };\n    // React Elements aren't very inspector-friendly,\n    // and often contain private fields or circular references.\n\n    case 'react_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: getDisplayNameForReactElement(data) || 'Unknown',\n        type: type\n      };\n    // ArrayBuffers error if you try to inspect them.\n\n    case 'array_buffer':\n    case 'data_view':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',\n        size: data.byteLength,\n        type: type\n      };\n\n    case 'array':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      }\n\n      return data.map(function (item, i) {\n        return dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n      });\n\n    case 'html_all_collection':\n    case 'typed_array':\n    case 'iterator':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        var unserializableValue = {\n          unserializable: true,\n          type: type,\n          readonly: true,\n          size: type === 'typed_array' ? data.length : undefined,\n          preview_short: formatDataForPreview(data, false),\n          preview_long: formatDataForPreview(data, true),\n          name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name\n        }; // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n\n        Array.from(data).forEach(function (item, i) {\n          return unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n        });\n        unserializable.push(path);\n        return unserializableValue;\n      }\n\n    case 'opaque_iterator':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: data[Symbol.toStringTag],\n        type: type\n      };\n\n    case 'date':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: data.toString(),\n        type: type\n      };\n\n    case 'regexp':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: data.toString(),\n        type: type\n      };\n\n    case 'object':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        var object = {};\n        getAllEnumerableKeys(data).forEach(function (key) {\n          var name = key.toString();\n          object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n        });\n        return object;\n      }\n\n    case 'class_instance':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      }\n\n      var value = {\n        unserializable: true,\n        type: type,\n        readonly: true,\n        preview_short: formatDataForPreview(data, false),\n        preview_long: formatDataForPreview(data, true),\n        name: data.constructor.name\n      };\n      getAllEnumerableKeys(data).forEach(function (key) {\n        var keyAsString = key.toString();\n        value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n      });\n      unserializable.push(path);\n      return value;\n\n    case 'infinity':\n    case 'nan':\n    case 'undefined':\n      // Some values are lossy when sent through a WebSocket.\n      // We dehydrate+rehydrate them to preserve their type.\n      cleaned.push(path);\n      return {\n        type: type\n      };\n\n    default:\n      return data;\n  }\n}\nfunction fillInPath(object, data, path, value) {\n  var target = getInObject(object, path);\n\n  if (target != null) {\n    if (!target[meta.unserializable]) {\n      delete target[meta.inspectable];\n      delete target[meta.inspected];\n      delete target[meta.name];\n      delete target[meta.preview_long];\n      delete target[meta.preview_short];\n      delete target[meta.readonly];\n      delete target[meta.size];\n      delete target[meta.type];\n    }\n  }\n\n  if (value !== null && data.unserializable.length > 0) {\n    var unserializablePath = data.unserializable[0];\n    var isMatch = unserializablePath.length === path.length;\n\n    for (var i = 0; i < path.length; i++) {\n      if (path[i] !== unserializablePath[i]) {\n        isMatch = false;\n        break;\n      }\n    }\n\n    if (isMatch) {\n      upgradeUnserializable(value, value);\n    }\n  }\n\n  setInObject(object, path, value);\n}\nfunction hydrate(object, cleaned, unserializable) {\n  cleaned.forEach(function (path) {\n    var length = path.length;\n    var last = path[length - 1];\n    var parent = getInObject(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    var value = parent[last];\n\n    if (!value) {\n      return;\n    } else if (value.type === 'infinity') {\n      parent[last] = Infinity;\n    } else if (value.type === 'nan') {\n      parent[last] = NaN;\n    } else if (value.type === 'undefined') {\n      parent[last] = undefined;\n    } else {\n      // Replace the string keys with Symbols so they're non-enumerable.\n      var replaced = {};\n      replaced[meta.inspectable] = !!value.inspectable;\n      replaced[meta.inspected] = false;\n      replaced[meta.name] = value.name;\n      replaced[meta.preview_long] = value.preview_long;\n      replaced[meta.preview_short] = value.preview_short;\n      replaced[meta.size] = value.size;\n      replaced[meta.readonly] = !!value.readonly;\n      replaced[meta.type] = value.type;\n      parent[last] = replaced;\n    }\n  });\n  unserializable.forEach(function (path) {\n    var length = path.length;\n    var last = path[length - 1];\n    var parent = getInObject(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    var node = parent[last];\n\n    var replacement = _objectSpread({}, node);\n\n    upgradeUnserializable(replacement, node);\n    parent[last] = replacement;\n  });\n  return object;\n}\n\nfunction upgradeUnserializable(destination, source) {\n  var _Object$definePropert;\n\n  Object.defineProperties(destination, (_Object$definePropert = {}, hydration_defineProperty(_Object$definePropert, meta.inspected, {\n    configurable: true,\n    enumerable: false,\n    value: !!source.inspected\n  }), hydration_defineProperty(_Object$definePropert, meta.name, {\n    configurable: true,\n    enumerable: false,\n    value: source.name\n  }), hydration_defineProperty(_Object$definePropert, meta.preview_long, {\n    configurable: true,\n    enumerable: false,\n    value: source.preview_long\n  }), hydration_defineProperty(_Object$definePropert, meta.preview_short, {\n    configurable: true,\n    enumerable: false,\n    value: source.preview_short\n  }), hydration_defineProperty(_Object$definePropert, meta.size, {\n    configurable: true,\n    enumerable: false,\n    value: source.size\n  }), hydration_defineProperty(_Object$definePropert, meta.readonly, {\n    configurable: true,\n    enumerable: false,\n    value: !!source.readonly\n  }), hydration_defineProperty(_Object$definePropert, meta.type, {\n    configurable: true,\n    enumerable: false,\n    value: source.type\n  }), hydration_defineProperty(_Object$definePropert, meta.unserializable, {\n    configurable: true,\n    enumerable: false,\n    value: !!source.unserializable\n  }), _Object$definePropert));\n  delete destination.inspected;\n  delete destination.name;\n  delete destination.preview_long;\n  delete destination.preview_short;\n  delete destination.size;\n  delete destination.readonly;\n  delete destination.type;\n  delete destination.unserializable;\n}\n;// CONCATENATED MODULE: ../shared/isArray.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray_isArray(a) {\n  return isArrayImpl(a);\n}\n\n/* harmony default export */ const shared_isArray = (isArray_isArray);\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/utils.js\nfunction utils_toConsumableArray(arr) { return utils_arrayWithoutHoles(arr) || utils_iterableToArray(arr) || backend_utils_unsupportedIterableToArray(arr) || utils_nonIterableSpread(); }\n\nfunction utils_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction backend_utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return backend_utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return backend_utils_arrayLikeToArray(o, minLen); }\n\nfunction utils_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction utils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return backend_utils_arrayLikeToArray(arr); }\n\nfunction backend_utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction backend_utils_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { backend_utils_typeof = function _typeof(obj) { return typeof obj; }; } else { backend_utils_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return backend_utils_typeof(obj); }\n\nfunction utils_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction utils_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { utils_ownKeys(Object(source), true).forEach(function (key) { utils_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { utils_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n// TODO: update this to the first React version that has a corresponding DevTools backend\nvar FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER = '999.9.9';\nfunction hasAssignedBackend(version) {\n  if (version == null || version === '') {\n    return false;\n  }\n\n  return gte(version, FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER);\n}\nfunction cleanForBridge(data, isPathAllowed) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (data !== null) {\n    var cleanedPaths = [];\n    var unserializablePaths = [];\n    var cleanedData = dehydrate(data, cleanedPaths, unserializablePaths, path, isPathAllowed);\n    return {\n      data: cleanedData,\n      cleaned: cleanedPaths,\n      unserializable: unserializablePaths\n    };\n  } else {\n    return null;\n  }\n}\nfunction copyWithDelete(obj, path) {\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var key = path[index];\n  var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);\n\n  if (index + 1 === path.length) {\n    if (shared_isArray(updated)) {\n      updated.splice(key, 1);\n    } else {\n      delete updated[key];\n    }\n  } else {\n    // $FlowFixMe[incompatible-use] number or string is fine here\n    updated[key] = copyWithDelete(obj[key], path, index + 1);\n  }\n\n  return updated;\n} // This function expects paths to be the same except for the final value.\n// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']\n\nfunction copyWithRename(obj, oldPath, newPath) {\n  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var oldKey = oldPath[index];\n  var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);\n\n  if (index + 1 === oldPath.length) {\n    var newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here\n\n    updated[newKey] = updated[oldKey];\n\n    if (shared_isArray(updated)) {\n      updated.splice(oldKey, 1);\n    } else {\n      delete updated[oldKey];\n    }\n  } else {\n    // $FlowFixMe[incompatible-use] number or string is fine here\n    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);\n  }\n\n  return updated;\n}\nfunction copyWithSet(obj, path, value) {\n  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (index >= path.length) {\n    return value;\n  }\n\n  var key = path[index];\n  var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj); // $FlowFixMe[incompatible-use] number or string is fine here\n\n  updated[key] = copyWithSet(obj[key], path, value, index + 1);\n  return updated;\n}\nfunction getEffectDurations(root) {\n  // Profiling durations are only available for certain builds.\n  // If available, they'll be stored on the HostRoot.\n  var effectDuration = null;\n  var passiveEffectDuration = null;\n  var hostRoot = root.current;\n\n  if (hostRoot != null) {\n    var stateNode = hostRoot.stateNode;\n\n    if (stateNode != null) {\n      effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;\n      passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;\n    }\n  }\n\n  return {\n    effectDuration: effectDuration,\n    passiveEffectDuration: passiveEffectDuration\n  };\n}\nfunction serializeToString(data) {\n  if (data === undefined) {\n    return 'undefined';\n  }\n\n  var cache = new Set(); // Use a custom replacer function to protect against circular references.\n\n  return JSON.stringify(data, function (key, value) {\n    if (backend_utils_typeof(value) === 'object' && value !== null) {\n      if (cache.has(value)) {\n        return;\n      }\n\n      cache.add(value);\n    }\n\n    if (typeof value === 'bigint') {\n      return value.toString() + 'n';\n    }\n\n    return value;\n  }, 2);\n} // Formats an array of args with a style for console methods, using\n// the following algorithm:\n//     1. The first param is a string that contains %c\n//          - Bail out and return the args without modifying the styles.\n//            We don't want to affect styles that the developer deliberately set.\n//     2. The first param is a string that doesn't contain %c but contains\n//        string formatting\n//          - [`%c${args[0]}`, style, ...args.slice(1)]\n//          - Note: we assume that the string formatting that the developer uses\n//            is correct.\n//     3. The first param is a string that doesn't contain string formatting\n//        OR is not a string\n//          - Create a formatting string where:\n//                 boolean, string, symbol -> %s\n//                 number -> %f OR %i depending on if it's an int or float\n//                 default -> %o\n\nfunction formatWithStyles(inputArgs, style) {\n  if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c\n  typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {\n    return inputArgs;\n  } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)\n\n\n  var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;\n\n  if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {\n    return [\"%c\".concat(inputArgs[0]), style].concat(utils_toConsumableArray(inputArgs.slice(1)));\n  } else {\n    var firstArg = inputArgs.reduce(function (formatStr, elem, i) {\n      if (i > 0) {\n        formatStr += ' ';\n      }\n\n      switch (backend_utils_typeof(elem)) {\n        case 'string':\n        case 'boolean':\n        case 'symbol':\n          return formatStr += '%s';\n\n        case 'number':\n          var formatting = Number.isInteger(elem) ? '%i' : '%f';\n          return formatStr += formatting;\n\n        default:\n          return formatStr += '%o';\n      }\n    }, '%c');\n    return [firstArg, style].concat(utils_toConsumableArray(inputArgs));\n  }\n} // based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1\n// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions\n// Implements s, d, i and f placeholders\n// NOTE: KEEP IN SYNC with src/hook.js\n\nfunction format(maybeMessage) {\n  for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    inputArgs[_key - 1] = arguments[_key];\n  }\n\n  var args = inputArgs.slice();\n  var formatted = String(maybeMessage); // If the first argument is a string, check for substitutions.\n\n  if (typeof maybeMessage === 'string') {\n    if (args.length) {\n      var REGEXP = /(%?)(%([jds]))/g;\n      formatted = formatted.replace(REGEXP, function (match, escaped, ptn, flag) {\n        var arg = args.shift();\n\n        switch (flag) {\n          case 's':\n            arg += '';\n            break;\n\n          case 'd':\n          case 'i':\n            arg = parseInt(arg, 10).toString();\n            break;\n\n          case 'f':\n            arg = parseFloat(arg).toString();\n            break;\n        }\n\n        if (!escaped) {\n          return arg;\n        }\n\n        args.unshift(arg);\n        return match;\n      });\n    }\n  } // Arguments that remain after formatting.\n\n\n  if (args.length) {\n    for (var i = 0; i < args.length; i++) {\n      formatted += ' ' + String(args[i]);\n    }\n  } // Update escaped %% values.\n\n\n  formatted = formatted.replace(/%{2,2}/g, '%');\n  return String(formatted);\n}\nfunction isSynchronousXHRSupported() {\n  return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature('sync-xhr'));\n}\nfunction gt() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return compareVersions(a, b) === 1;\n}\nfunction gte() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return compareVersions(a, b) > -1;\n}\n// EXTERNAL MODULE: ../../build/oss-experimental/react-debug-tools/index.js\nvar react_debug_tools = __nested_webpack_require_99207__(987);\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.\n// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:\n// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)\n// 2. DevTools must support both Symbol and numeric forms of each symbol;\n//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.\nvar CONCURRENT_MODE_NUMBER = 0xeacf;\nvar CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';\nvar CONTEXT_NUMBER = 0xeace;\nvar CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';\nvar SERVER_CONTEXT_SYMBOL_STRING = 'Symbol(react.server_context)';\nvar DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';\nvar ELEMENT_NUMBER = 0xeac7;\nvar ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';\nvar DEBUG_TRACING_MODE_NUMBER = 0xeae1;\nvar DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';\nvar ReactSymbols_FORWARD_REF_NUMBER = 0xead0;\nvar ReactSymbols_FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';\nvar FRAGMENT_NUMBER = 0xeacb;\nvar FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';\nvar ReactSymbols_LAZY_NUMBER = 0xead4;\nvar ReactSymbols_LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';\nvar ReactSymbols_MEMO_NUMBER = 0xead3;\nvar ReactSymbols_MEMO_SYMBOL_STRING = 'Symbol(react.memo)';\nvar PORTAL_NUMBER = 0xeaca;\nvar PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';\nvar PROFILER_NUMBER = 0xead2;\nvar PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';\nvar PROVIDER_NUMBER = 0xeacd;\nvar PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';\nvar SCOPE_NUMBER = 0xead7;\nvar SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';\nvar STRICT_MODE_NUMBER = 0xeacc;\nvar STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';\nvar ReactSymbols_SUSPENSE_NUMBER = 0xead1;\nvar ReactSymbols_SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';\nvar ReactSymbols_SUSPENSE_LIST_NUMBER = 0xead8;\nvar ReactSymbols_SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';\nvar SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING = 'Symbol(react.server_context.defaultValue)';\n;// CONCATENATED MODULE: ../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/************************************************************************\n * This file is forked between different DevTools implementations.\n * It should never be imported directly!\n * It should always be imported from \"react-devtools-feature-flags\".\n ************************************************************************/\nvar consoleManagedByDevToolsDuringStrictMode = false;\nvar enableLogger = false;\nvar enableStyleXFeatures = false;\nvar isInternalFacebookBuild = false;\n/************************************************************************\n * Do not edit the code below.\n * It ensures this fork exports the same types as the default flags file.\n ************************************************************************/\n\n// Flow magic to verify the exports of this file match the original version.\nnull;\n;// CONCATENATED MODULE: ../shared/objectIs.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = // $FlowFixMe[method-unbinding]\ntypeof Object.is === 'function' ? Object.is : is;\n/* harmony default export */ const shared_objectIs = (objectIs);\n;// CONCATENATED MODULE: ../shared/hasOwnProperty.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty_hasOwnProperty = Object.prototype.hasOwnProperty;\n/* harmony default export */ const shared_hasOwnProperty = (hasOwnProperty_hasOwnProperty);\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/StyleX/utils.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar cachedStyleNameToValueMap = new Map();\nfunction getStyleXData(data) {\n  var sources = new Set();\n  var resolvedStyles = {};\n  crawlData(data, sources, resolvedStyles);\n  return {\n    sources: Array.from(sources).sort(),\n    resolvedStyles: resolvedStyles\n  };\n}\nfunction crawlData(data, sources, resolvedStyles) {\n  if (data == null) {\n    return;\n  }\n\n  if (src_isArray(data)) {\n    data.forEach(function (entry) {\n      if (entry == null) {\n        return;\n      }\n\n      if (src_isArray(entry)) {\n        crawlData(entry, sources, resolvedStyles);\n      } else {\n        crawlObjectProperties(entry, sources, resolvedStyles);\n      }\n    });\n  } else {\n    crawlObjectProperties(data, sources, resolvedStyles);\n  }\n\n  resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());\n}\n\nfunction crawlObjectProperties(entry, sources, resolvedStyles) {\n  var keys = Object.keys(entry);\n  keys.forEach(function (key) {\n    var value = entry[key];\n\n    if (typeof value === 'string') {\n      if (key === value) {\n        // Special case; this key is the name of the style's source/file/module.\n        sources.add(key);\n      } else {\n        var propertyValue = getPropertyValueForStyleName(value);\n\n        if (propertyValue != null) {\n          resolvedStyles[key] = propertyValue;\n        }\n      }\n    } else {\n      var nestedStyle = {};\n      resolvedStyles[key] = nestedStyle;\n      crawlData([value], sources, nestedStyle);\n    }\n  });\n}\n\nfunction getPropertyValueForStyleName(styleName) {\n  if (cachedStyleNameToValueMap.has(styleName)) {\n    return cachedStyleNameToValueMap.get(styleName);\n  }\n\n  for (var styleSheetIndex = 0; styleSheetIndex < document.styleSheets.length; styleSheetIndex++) {\n    var styleSheet = document.styleSheets[styleSheetIndex];\n    var rules = null; // this might throw if CORS rules are enforced https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n\n    try {\n      rules = styleSheet.cssRules;\n    } catch (_e) {\n      continue;\n    }\n\n    for (var ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n      if (!(rules[ruleIndex] instanceof CSSStyleRule)) {\n        continue;\n      }\n\n      var rule = rules[ruleIndex];\n      var cssText = rule.cssText,\n          selectorText = rule.selectorText,\n          style = rule.style;\n\n      if (selectorText != null) {\n        if (selectorText.startsWith(\".\".concat(styleName))) {\n          var match = cssText.match(/{ *([a-z\\-]+):/);\n\n          if (match !== null) {\n            var property = match[1];\n            var value = style.getPropertyValue(property);\n            cachedStyleNameToValueMap.set(styleName, value);\n            return value;\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n\n  return null;\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/constants.js\nvar CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md';\nvar UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back';\nvar REACT_DEVTOOLS_WORKPLACE_URL = 'https://fburl.com/react-devtools-workplace-group';\nvar THEME_STYLES = {\n  light: {\n    '--color-attribute-name': '#ef6632',\n    '--color-attribute-name-not-editable': '#23272f',\n    '--color-attribute-name-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-attribute-value': '#1a1aa6',\n    '--color-attribute-value-inverted': '#ffffff',\n    '--color-attribute-editable-value': '#1a1aa6',\n    '--color-background': '#ffffff',\n    '--color-background-hover': 'rgba(0, 136, 250, 0.1)',\n    '--color-background-inactive': '#e5e5e5',\n    '--color-background-invalid': '#fff0f0',\n    '--color-background-selected': '#0088fa',\n    '--color-button-background': '#ffffff',\n    '--color-button-background-focus': '#ededed',\n    '--color-button': '#5f6673',\n    '--color-button-disabled': '#cfd1d5',\n    '--color-button-active': '#0088fa',\n    '--color-button-focus': '#23272f',\n    '--color-button-hover': '#23272f',\n    '--color-border': '#eeeeee',\n    '--color-commit-did-not-render-fill': '#cfd1d5',\n    '--color-commit-did-not-render-fill-text': '#000000',\n    '--color-commit-did-not-render-pattern': '#cfd1d5',\n    '--color-commit-did-not-render-pattern-text': '#333333',\n    '--color-commit-gradient-0': '#37afa9',\n    '--color-commit-gradient-1': '#63b19e',\n    '--color-commit-gradient-2': '#80b393',\n    '--color-commit-gradient-3': '#97b488',\n    '--color-commit-gradient-4': '#abb67d',\n    '--color-commit-gradient-5': '#beb771',\n    '--color-commit-gradient-6': '#cfb965',\n    '--color-commit-gradient-7': '#dfba57',\n    '--color-commit-gradient-8': '#efbb49',\n    '--color-commit-gradient-9': '#febc38',\n    '--color-commit-gradient-text': '#000000',\n    '--color-component-name': '#6a51b2',\n    '--color-component-name-inverted': '#ffffff',\n    '--color-component-badge-background': 'rgba(0, 0, 0, 0.1)',\n    '--color-component-badge-background-inverted': 'rgba(255, 255, 255, 0.25)',\n    '--color-component-badge-count': '#777d88',\n    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-console-error-badge-text': '#ffffff',\n    '--color-console-error-background': '#fff0f0',\n    '--color-console-error-border': '#ffd6d6',\n    '--color-console-error-icon': '#eb3941',\n    '--color-console-error-text': '#fe2e31',\n    '--color-console-warning-badge-text': '#000000',\n    '--color-console-warning-background': '#fffbe5',\n    '--color-console-warning-border': '#fff5c1',\n    '--color-console-warning-icon': '#f4bd00',\n    '--color-console-warning-text': '#64460c',\n    '--color-context-background': 'rgba(0,0,0,.9)',\n    '--color-context-background-hover': 'rgba(255, 255, 255, 0.1)',\n    '--color-context-background-selected': '#178fb9',\n    '--color-context-border': '#3d424a',\n    '--color-context-text': '#ffffff',\n    '--color-context-text-selected': '#ffffff',\n    '--color-dim': '#777d88',\n    '--color-dimmer': '#cfd1d5',\n    '--color-dimmest': '#eff0f1',\n    '--color-error-background': 'hsl(0, 100%, 97%)',\n    '--color-error-border': 'hsl(0, 100%, 92%)',\n    '--color-error-text': '#ff0000',\n    '--color-expand-collapse-toggle': '#777d88',\n    '--color-link': '#0000ff',\n    '--color-modal-background': 'rgba(255, 255, 255, 0.75)',\n    '--color-bridge-version-npm-background': '#eff0f1',\n    '--color-bridge-version-npm-text': '#000000',\n    '--color-bridge-version-number': '#0088fa',\n    '--color-primitive-hook-badge-background': '#e5e5e5',\n    '--color-primitive-hook-badge-text': '#5f6673',\n    '--color-record-active': '#fc3a4b',\n    '--color-record-hover': '#3578e5',\n    '--color-record-inactive': '#0088fa',\n    '--color-resize-bar': '#eeeeee',\n    '--color-resize-bar-active': '#dcdcdc',\n    '--color-resize-bar-border': '#d1d1d1',\n    '--color-resize-bar-dot': '#333333',\n    '--color-timeline-internal-module': '#d1d1d1',\n    '--color-timeline-internal-module-hover': '#c9c9c9',\n    '--color-timeline-internal-module-text': '#444',\n    '--color-timeline-native-event': '#ccc',\n    '--color-timeline-native-event-hover': '#aaa',\n    '--color-timeline-network-primary': '#fcf3dc',\n    '--color-timeline-network-primary-hover': '#f0e7d1',\n    '--color-timeline-network-secondary': '#efc457',\n    '--color-timeline-network-secondary-hover': '#e3ba52',\n    '--color-timeline-priority-background': '#f6f6f6',\n    '--color-timeline-priority-border': '#eeeeee',\n    '--color-timeline-user-timing': '#c9cacd',\n    '--color-timeline-user-timing-hover': '#93959a',\n    '--color-timeline-react-idle': '#d3e5f6',\n    '--color-timeline-react-idle-hover': '#c3d9ef',\n    '--color-timeline-react-render': '#9fc3f3',\n    '--color-timeline-react-render-hover': '#83afe9',\n    '--color-timeline-react-render-text': '#11365e',\n    '--color-timeline-react-commit': '#c88ff0',\n    '--color-timeline-react-commit-hover': '#b281d6',\n    '--color-timeline-react-commit-text': '#3e2c4a',\n    '--color-timeline-react-layout-effects': '#b281d6',\n    '--color-timeline-react-layout-effects-hover': '#9d71bd',\n    '--color-timeline-react-layout-effects-text': '#3e2c4a',\n    '--color-timeline-react-passive-effects': '#b281d6',\n    '--color-timeline-react-passive-effects-hover': '#9d71bd',\n    '--color-timeline-react-passive-effects-text': '#3e2c4a',\n    '--color-timeline-react-schedule': '#9fc3f3',\n    '--color-timeline-react-schedule-hover': '#2683E2',\n    '--color-timeline-react-suspense-rejected': '#f1cc14',\n    '--color-timeline-react-suspense-rejected-hover': '#ffdf37',\n    '--color-timeline-react-suspense-resolved': '#a6e59f',\n    '--color-timeline-react-suspense-resolved-hover': '#89d281',\n    '--color-timeline-react-suspense-unresolved': '#c9cacd',\n    '--color-timeline-react-suspense-unresolved-hover': '#93959a',\n    '--color-timeline-thrown-error': '#ee1638',\n    '--color-timeline-thrown-error-hover': '#da1030',\n    '--color-timeline-text-color': '#000000',\n    '--color-timeline-text-dim-color': '#ccc',\n    '--color-timeline-react-work-border': '#eeeeee',\n    '--color-search-match': 'yellow',\n    '--color-search-match-current': '#f7923b',\n    '--color-selected-tree-highlight-active': 'rgba(0, 136, 250, 0.1)',\n    '--color-selected-tree-highlight-inactive': 'rgba(0, 0, 0, 0.05)',\n    '--color-scroll-caret': 'rgba(150, 150, 150, 0.5)',\n    '--color-tab-selected-border': '#0088fa',\n    '--color-text': '#000000',\n    '--color-text-invalid': '#ff0000',\n    '--color-text-selected': '#ffffff',\n    '--color-toggle-background-invalid': '#fc3a4b',\n    '--color-toggle-background-on': '#0088fa',\n    '--color-toggle-background-off': '#cfd1d5',\n    '--color-toggle-text': '#ffffff',\n    '--color-warning-background': '#fb3655',\n    '--color-warning-background-hover': '#f82042',\n    '--color-warning-text-color': '#ffffff',\n    '--color-warning-text-color-inverted': '#fd4d69',\n    // The styles below should be kept in sync with 'root.css'\n    // They are repeated there because they're used by e.g. tooltips or context menus\n    // which get rendered outside of the DOM subtree (where normal theme/styles are written).\n    '--color-scroll-thumb': '#c2c2c2',\n    '--color-scroll-track': '#fafafa',\n    '--color-tooltip-background': 'rgba(0, 0, 0, 0.9)',\n    '--color-tooltip-text': '#ffffff'\n  },\n  dark: {\n    '--color-attribute-name': '#9d87d2',\n    '--color-attribute-name-not-editable': '#ededed',\n    '--color-attribute-name-inverted': '#282828',\n    '--color-attribute-value': '#cedae0',\n    '--color-attribute-value-inverted': '#ffffff',\n    '--color-attribute-editable-value': 'yellow',\n    '--color-background': '#282c34',\n    '--color-background-hover': 'rgba(255, 255, 255, 0.1)',\n    '--color-background-inactive': '#3d424a',\n    '--color-background-invalid': '#5c0000',\n    '--color-background-selected': '#178fb9',\n    '--color-button-background': '#282c34',\n    '--color-button-background-focus': '#3d424a',\n    '--color-button': '#afb3b9',\n    '--color-button-active': '#61dafb',\n    '--color-button-disabled': '#4f5766',\n    '--color-button-focus': '#a2e9fc',\n    '--color-button-hover': '#ededed',\n    '--color-border': '#3d424a',\n    '--color-commit-did-not-render-fill': '#777d88',\n    '--color-commit-did-not-render-fill-text': '#000000',\n    '--color-commit-did-not-render-pattern': '#666c77',\n    '--color-commit-did-not-render-pattern-text': '#ffffff',\n    '--color-commit-gradient-0': '#37afa9',\n    '--color-commit-gradient-1': '#63b19e',\n    '--color-commit-gradient-2': '#80b393',\n    '--color-commit-gradient-3': '#97b488',\n    '--color-commit-gradient-4': '#abb67d',\n    '--color-commit-gradient-5': '#beb771',\n    '--color-commit-gradient-6': '#cfb965',\n    '--color-commit-gradient-7': '#dfba57',\n    '--color-commit-gradient-8': '#efbb49',\n    '--color-commit-gradient-9': '#febc38',\n    '--color-commit-gradient-text': '#000000',\n    '--color-component-name': '#61dafb',\n    '--color-component-name-inverted': '#282828',\n    '--color-component-badge-background': 'rgba(255, 255, 255, 0.25)',\n    '--color-component-badge-background-inverted': 'rgba(0, 0, 0, 0.25)',\n    '--color-component-badge-count': '#8f949d',\n    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-console-error-badge-text': '#000000',\n    '--color-console-error-background': '#290000',\n    '--color-console-error-border': '#5c0000',\n    '--color-console-error-icon': '#eb3941',\n    '--color-console-error-text': '#fc7f7f',\n    '--color-console-warning-badge-text': '#000000',\n    '--color-console-warning-background': '#332b00',\n    '--color-console-warning-border': '#665500',\n    '--color-console-warning-icon': '#f4bd00',\n    '--color-console-warning-text': '#f5f2ed',\n    '--color-context-background': 'rgba(255,255,255,.95)',\n    '--color-context-background-hover': 'rgba(0, 136, 250, 0.1)',\n    '--color-context-background-selected': '#0088fa',\n    '--color-context-border': '#eeeeee',\n    '--color-context-text': '#000000',\n    '--color-context-text-selected': '#ffffff',\n    '--color-dim': '#8f949d',\n    '--color-dimmer': '#777d88',\n    '--color-dimmest': '#4f5766',\n    '--color-error-background': '#200',\n    '--color-error-border': '#900',\n    '--color-error-text': '#f55',\n    '--color-expand-collapse-toggle': '#8f949d',\n    '--color-link': '#61dafb',\n    '--color-modal-background': 'rgba(0, 0, 0, 0.75)',\n    '--color-bridge-version-npm-background': 'rgba(0, 0, 0, 0.25)',\n    '--color-bridge-version-npm-text': '#ffffff',\n    '--color-bridge-version-number': 'yellow',\n    '--color-primitive-hook-badge-background': 'rgba(0, 0, 0, 0.25)',\n    '--color-primitive-hook-badge-text': 'rgba(255, 255, 255, 0.7)',\n    '--color-record-active': '#fc3a4b',\n    '--color-record-hover': '#a2e9fc',\n    '--color-record-inactive': '#61dafb',\n    '--color-resize-bar': '#282c34',\n    '--color-resize-bar-active': '#31363f',\n    '--color-resize-bar-border': '#3d424a',\n    '--color-resize-bar-dot': '#cfd1d5',\n    '--color-timeline-internal-module': '#303542',\n    '--color-timeline-internal-module-hover': '#363b4a',\n    '--color-timeline-internal-module-text': '#7f8899',\n    '--color-timeline-native-event': '#b2b2b2',\n    '--color-timeline-native-event-hover': '#949494',\n    '--color-timeline-network-primary': '#fcf3dc',\n    '--color-timeline-network-primary-hover': '#e3dbc5',\n    '--color-timeline-network-secondary': '#efc457',\n    '--color-timeline-network-secondary-hover': '#d6af4d',\n    '--color-timeline-priority-background': '#1d2129',\n    '--color-timeline-priority-border': '#282c34',\n    '--color-timeline-user-timing': '#c9cacd',\n    '--color-timeline-user-timing-hover': '#93959a',\n    '--color-timeline-react-idle': '#3d485b',\n    '--color-timeline-react-idle-hover': '#465269',\n    '--color-timeline-react-render': '#2683E2',\n    '--color-timeline-react-render-hover': '#1a76d4',\n    '--color-timeline-react-render-text': '#11365e',\n    '--color-timeline-react-commit': '#731fad',\n    '--color-timeline-react-commit-hover': '#611b94',\n    '--color-timeline-react-commit-text': '#e5c1ff',\n    '--color-timeline-react-layout-effects': '#611b94',\n    '--color-timeline-react-layout-effects-hover': '#51167a',\n    '--color-timeline-react-layout-effects-text': '#e5c1ff',\n    '--color-timeline-react-passive-effects': '#611b94',\n    '--color-timeline-react-passive-effects-hover': '#51167a',\n    '--color-timeline-react-passive-effects-text': '#e5c1ff',\n    '--color-timeline-react-schedule': '#2683E2',\n    '--color-timeline-react-schedule-hover': '#1a76d4',\n    '--color-timeline-react-suspense-rejected': '#f1cc14',\n    '--color-timeline-react-suspense-rejected-hover': '#e4c00f',\n    '--color-timeline-react-suspense-resolved': '#a6e59f',\n    '--color-timeline-react-suspense-resolved-hover': '#89d281',\n    '--color-timeline-react-suspense-unresolved': '#c9cacd',\n    '--color-timeline-react-suspense-unresolved-hover': '#93959a',\n    '--color-timeline-thrown-error': '#fb3655',\n    '--color-timeline-thrown-error-hover': '#f82042',\n    '--color-timeline-text-color': '#282c34',\n    '--color-timeline-text-dim-color': '#555b66',\n    '--color-timeline-react-work-border': '#3d424a',\n    '--color-search-match': 'yellow',\n    '--color-search-match-current': '#f7923b',\n    '--color-selected-tree-highlight-active': 'rgba(23, 143, 185, 0.15)',\n    '--color-selected-tree-highlight-inactive': 'rgba(255, 255, 255, 0.05)',\n    '--color-scroll-caret': '#4f5766',\n    '--color-shadow': 'rgba(0, 0, 0, 0.5)',\n    '--color-tab-selected-border': '#178fb9',\n    '--color-text': '#ffffff',\n    '--color-text-invalid': '#ff8080',\n    '--color-text-selected': '#ffffff',\n    '--color-toggle-background-invalid': '#fc3a4b',\n    '--color-toggle-background-on': '#178fb9',\n    '--color-toggle-background-off': '#777d88',\n    '--color-toggle-text': '#ffffff',\n    '--color-warning-background': '#ee1638',\n    '--color-warning-background-hover': '#da1030',\n    '--color-warning-text-color': '#ffffff',\n    '--color-warning-text-color-inverted': '#ee1638',\n    // The styles below should be kept in sync with 'root.css'\n    // They are repeated there because they're used by e.g. tooltips or context menus\n    // which get rendered outside of the DOM subtree (where normal theme/styles are written).\n    '--color-scroll-thumb': '#afb3b9',\n    '--color-scroll-track': '#313640',\n    '--color-tooltip-background': 'rgba(255, 255, 255, 0.95)',\n    '--color-tooltip-text': '#000000'\n  },\n  compact: {\n    '--font-size-monospace-small': '9px',\n    '--font-size-monospace-normal': '11px',\n    '--font-size-monospace-large': '15px',\n    '--font-size-sans-small': '10px',\n    '--font-size-sans-normal': '12px',\n    '--font-size-sans-large': '14px',\n    '--line-height-data': '18px'\n  },\n  comfortable: {\n    '--font-size-monospace-small': '10px',\n    '--font-size-monospace-normal': '13px',\n    '--font-size-monospace-large': '17px',\n    '--font-size-sans-small': '12px',\n    '--font-size-sans-normal': '14px',\n    '--font-size-sans-large': '16px',\n    '--line-height-data': '22px'\n  }\n}; // HACK\n//\n// Sometimes the inline target is rendered before root styles are applied,\n// which would result in e.g. NaN itemSize being passed to react-window list.\n\nvar COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable['--line-height-data'], 10);\nvar COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact['--line-height-data'], 10);\n\n;// CONCATENATED MODULE: ../react-devtools-timeline/src/constants.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar REACT_TOTAL_NUM_LANES = 31; // Increment this number any time a backwards breaking change is made to the profiler metadata.\n\nvar SCHEDULING_PROFILER_VERSION = 1;\nvar SNAPSHOT_MAX_HEIGHT = 60;\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsConsolePatching.js\nfunction DevToolsConsolePatching_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction DevToolsConsolePatching_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DevToolsConsolePatching_ownKeys(Object(source), true).forEach(function (key) { DevToolsConsolePatching_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DevToolsConsolePatching_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction DevToolsConsolePatching_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of shared/ConsolePatchingDev.\n// The shared console patching code is DEV-only.\n// We can't use it since DevTools only ships production builds.\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  if (disabledDepth === 0) {\n    /* eslint-disable react-internal/no-production-logging */\n    prevLog = console.log;\n    prevInfo = console.info;\n    prevWarn = console.warn;\n    prevError = console.error;\n    prevGroup = console.group;\n    prevGroupCollapsed = console.groupCollapsed;\n    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n    var props = {\n      configurable: true,\n      enumerable: true,\n      value: disabledLog,\n      writable: true\n    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n    Object.defineProperties(console, {\n      info: props,\n      log: props,\n      warn: props,\n      error: props,\n      group: props,\n      groupCollapsed: props,\n      groupEnd: props\n    });\n    /* eslint-enable react-internal/no-production-logging */\n  }\n\n  disabledDepth++;\n}\nfunction reenableLogs() {\n  disabledDepth--;\n\n  if (disabledDepth === 0) {\n    /* eslint-disable react-internal/no-production-logging */\n    var props = {\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n    Object.defineProperties(console, {\n      log: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {\n        value: prevLog\n      }),\n      info: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {\n        value: prevInfo\n      }),\n      warn: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {\n        value: prevWarn\n      }),\n      error: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {\n        value: prevError\n      }),\n      group: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {\n        value: prevGroup\n      }),\n      groupCollapsed: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {\n        value: prevGroupCollapsed\n      }),\n      groupEnd: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {\n        value: prevGroupEnd\n      })\n    });\n    /* eslint-enable react-internal/no-production-logging */\n  }\n\n  if (disabledDepth < 0) {\n    console.error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n  }\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js\nfunction DevToolsComponentStackFrame_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { DevToolsComponentStackFrame_typeof = function _typeof(obj) { return typeof obj; }; } else { DevToolsComponentStackFrame_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return DevToolsComponentStackFrame_typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactComponentStackFrame.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n // The shared console patching code is DEV-only.\n// We can't use it since DevTools only ships production builds.\n\n\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  if (prefix === undefined) {\n    // Extract the VM specific prefix used by each line.\n    try {\n      throw Error();\n    } catch (x) {\n      var match = x.stack.trim().match(/\\n( *(at )?)/);\n      prefix = match && match[1] || '';\n    }\n  } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n  return '\\n' + prefix + name;\n}\nvar reentry = false;\nvar componentFrameCache;\n\nif (false) { var PossiblyWeakMap; }\n\nfunction describeNativeComponentFrame(fn, construct, currentDispatcherRef) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  if (false) { var frame; }\n\n  var control;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  reentry = true; // Override the dispatcher so effects scheduled by this shallow render are thrown away.\n  //\n  // Note that unlike the code this was forked from (in ReactComponentStackFrame)\n  // DevTools should override the dispatcher even when DevTools is compiled in production mode,\n  // because the app itself may be in development mode and log errors/warnings.\n\n  var previousDispatcher = currentDispatcherRef.current;\n  currentDispatcherRef.current = null;\n  disableLogs();\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function Fake() {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function set() {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if ((typeof Reflect === \"undefined\" ? \"undefined\" : DevToolsComponentStackFrame_typeof(Reflect)) === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                if (false) {} // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n    Error.prepareStackTrace = previousPrepareStackTrace;\n    currentDispatcherRef.current = previousDispatcher;\n    reenableLogs();\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  if (false) {}\n\n  return syntheticFrame;\n}\nfunction describeClassComponentFrame(ctor, ownerFn, currentDispatcherRef) {\n  return describeNativeComponentFrame(ctor, true, currentDispatcherRef);\n}\nfunction describeFunctionComponentFrame(fn, ownerFn, currentDispatcherRef) {\n  return describeNativeComponentFrame(fn, false, currentDispatcherRef);\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn, currentDispatcherRef) {\n  if (true) {\n    return '';\n  }\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type, ownerFn);\n  }\n\n  switch (type) {\n    case SUSPENSE_NUMBER:\n    case SUSPENSE_SYMBOL_STRING:\n      return describeBuiltInComponentFrame('Suspense', ownerFn);\n\n    case SUSPENSE_LIST_NUMBER:\n    case SUSPENSE_LIST_SYMBOL_STRING:\n      return describeBuiltInComponentFrame('SuspenseList', ownerFn);\n  }\n\n  if (DevToolsComponentStackFrame_typeof(type) === 'object') {\n    switch (type.$$typeof) {\n      case FORWARD_REF_NUMBER:\n      case FORWARD_REF_SYMBOL_STRING:\n        return describeFunctionComponentFrame(type.render, ownerFn, currentDispatcherRef);\n\n      case MEMO_NUMBER:\n      case MEMO_SYMBOL_STRING:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn, currentDispatcherRef);\n\n      case LAZY_NUMBER:\n      case LAZY_SYMBOL_STRING:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn, currentDispatcherRef);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactFiberComponentStack.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n\nfunction describeFiber(workTagMap, workInProgress, currentDispatcherRef) {\n  var HostComponent = workTagMap.HostComponent,\n      LazyComponent = workTagMap.LazyComponent,\n      SuspenseComponent = workTagMap.SuspenseComponent,\n      SuspenseListComponent = workTagMap.SuspenseListComponent,\n      FunctionComponent = workTagMap.FunctionComponent,\n      IndeterminateComponent = workTagMap.IndeterminateComponent,\n      SimpleMemoComponent = workTagMap.SimpleMemoComponent,\n      ForwardRef = workTagMap.ForwardRef,\n      ClassComponent = workTagMap.ClassComponent;\n  var owner =   false ? 0 : null;\n\n  switch (workInProgress.tag) {\n    case HostComponent:\n      return describeBuiltInComponentFrame(workInProgress.type, owner);\n\n    case LazyComponent:\n      return describeBuiltInComponentFrame('Lazy', owner);\n\n    case SuspenseComponent:\n      return describeBuiltInComponentFrame('Suspense', owner);\n\n    case SuspenseListComponent:\n      return describeBuiltInComponentFrame('SuspenseList', owner);\n\n    case FunctionComponent:\n    case IndeterminateComponent:\n    case SimpleMemoComponent:\n      return describeFunctionComponentFrame(workInProgress.type, owner, currentDispatcherRef);\n\n    case ForwardRef:\n      return describeFunctionComponentFrame(workInProgress.type.render, owner, currentDispatcherRef);\n\n    case ClassComponent:\n      return describeClassComponentFrame(workInProgress.type, owner, currentDispatcherRef);\n\n    default:\n      return '';\n  }\n}\nfunction getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {\n  try {\n    var info = '';\n    var node = workInProgress;\n\n    do {\n      info += describeFiber(workTagMap, node, currentDispatcherRef); // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n      node = node.return;\n    } while (node);\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/profilingHooks.js\nfunction profilingHooks_slicedToArray(arr, i) { return profilingHooks_arrayWithHoles(arr) || profilingHooks_iterableToArrayLimit(arr, i) || profilingHooks_unsupportedIterableToArray(arr, i) || profilingHooks_nonIterableRest(); }\n\nfunction profilingHooks_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction profilingHooks_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return profilingHooks_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return profilingHooks_arrayLikeToArray(o, minLen); }\n\nfunction profilingHooks_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction profilingHooks_iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction profilingHooks_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction profilingHooks_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { profilingHooks_typeof = function _typeof(obj) { return typeof obj; }; } else { profilingHooks_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return profilingHooks_typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n // Add padding to the start/stop time of the profile.\n// This makes the UI nicer to use.\n\nvar TIME_OFFSET = 10;\nvar performanceTarget = null; // If performance exists and supports the subset of the User Timing API that we require.\n\nvar supportsUserTiming = typeof performance !== 'undefined' && // $FlowFixMe[method-unbinding]\ntypeof performance.mark === 'function' && // $FlowFixMe[method-unbinding]\ntypeof performance.clearMarks === 'function';\nvar supportsUserTimingV3 = false;\n\nif (supportsUserTiming) {\n  var CHECK_V3_MARK = '__v3';\n  var markOptions = {};\n  Object.defineProperty(markOptions, 'startTime', {\n    get: function get() {\n      supportsUserTimingV3 = true;\n      return 0;\n    },\n    set: function set() {}\n  });\n\n  try {\n    performance.mark(CHECK_V3_MARK, markOptions);\n  } catch (error) {// Ignore\n  } finally {\n    performance.clearMarks(CHECK_V3_MARK);\n  }\n}\n\nif (supportsUserTimingV3) {\n  performanceTarget = performance;\n} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n\nvar profilingHooks_getCurrentTime = // $FlowFixMe[method-unbinding]\n(typeof performance === \"undefined\" ? \"undefined\" : profilingHooks_typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n}; // Mocking the Performance Object (and User Timing APIs) for testing is fragile.\n// This API allows tests to directly override the User Timing APIs.\n\nfunction setPerformanceMock_ONLY_FOR_TESTING(performanceMock) {\n  performanceTarget = performanceMock;\n  supportsUserTiming = performanceMock !== null;\n  supportsUserTimingV3 = performanceMock !== null;\n}\nfunction createProfilingHooks(_ref) {\n  var getDisplayNameForFiber = _ref.getDisplayNameForFiber,\n      getIsProfiling = _ref.getIsProfiling,\n      getLaneLabelMap = _ref.getLaneLabelMap,\n      workTagMap = _ref.workTagMap,\n      currentDispatcherRef = _ref.currentDispatcherRef,\n      reactVersion = _ref.reactVersion;\n  var currentBatchUID = 0;\n  var currentReactComponentMeasure = null;\n  var currentReactMeasuresStack = [];\n  var currentTimelineData = null;\n  var currentFiberStacks = new Map();\n  var isProfiling = false;\n  var nextRenderShouldStartNewBatch = false;\n\n  function getRelativeTime() {\n    var currentTime = profilingHooks_getCurrentTime();\n\n    if (currentTimelineData) {\n      if (currentTimelineData.startTime === 0) {\n        currentTimelineData.startTime = currentTime - TIME_OFFSET;\n      }\n\n      return currentTime - currentTimelineData.startTime;\n    }\n\n    return 0;\n  }\n\n  function getInternalModuleRanges() {\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === 'function') {\n      // Ask the DevTools hook for module ranges that may have been reported by the current renderer(s).\n      // Don't do this eagerly like the laneToLabelMap,\n      // because some modules might not yet have registered their boundaries when the renderer is injected.\n      var ranges = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges(); // This check would not be required,\n      // except that it's possible for things to override __REACT_DEVTOOLS_GLOBAL_HOOK__.\n\n\n      if (shared_isArray(ranges)) {\n        return ranges;\n      }\n    }\n\n    return null;\n  }\n\n  function getTimelineData() {\n    return currentTimelineData;\n  }\n\n  function laneToLanesArray(lanes) {\n    var lanesArray = [];\n    var lane = 1;\n\n    for (var index = 0; index < REACT_TOTAL_NUM_LANES; index++) {\n      if (lane & lanes) {\n        lanesArray.push(lane);\n      }\n\n      lane *= 2;\n    }\n\n    return lanesArray;\n  }\n\n  var laneToLabelMap = typeof getLaneLabelMap === 'function' ? getLaneLabelMap() : null;\n\n  function markMetadata() {\n    markAndClear(\"--react-version-\".concat(reactVersion));\n    markAndClear(\"--profiler-version-\".concat(SCHEDULING_PROFILER_VERSION));\n    var ranges = getInternalModuleRanges();\n\n    if (ranges) {\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n\n        if (shared_isArray(range) && range.length === 2) {\n          var _ranges$i = profilingHooks_slicedToArray(ranges[i], 2),\n              startStackFrame = _ranges$i[0],\n              stopStackFrame = _ranges$i[1];\n\n          markAndClear(\"--react-internal-module-start-\".concat(startStackFrame));\n          markAndClear(\"--react-internal-module-stop-\".concat(stopStackFrame));\n        }\n      }\n    }\n\n    if (laneToLabelMap != null) {\n      var labels = Array.from(laneToLabelMap.values()).join(',');\n      markAndClear(\"--react-lane-labels-\".concat(labels));\n    }\n  }\n\n  function markAndClear(markName) {\n    // This method won't be called unless these functions are defined, so we can skip the extra typeof check.\n    performanceTarget.mark(markName);\n    performanceTarget.clearMarks(markName);\n  }\n\n  function recordReactMeasureStarted(type, lanes) {\n    // Decide what depth thi work should be rendered at, based on what's on the top of the stack.\n    // It's okay to render over top of \"idle\" work but everything else should be on its own row.\n    var depth = 0;\n\n    if (currentReactMeasuresStack.length > 0) {\n      var top = currentReactMeasuresStack[currentReactMeasuresStack.length - 1];\n      depth = top.type === 'render-idle' ? top.depth : top.depth + 1;\n    }\n\n    var lanesArray = laneToLanesArray(lanes);\n    var reactMeasure = {\n      type: type,\n      batchUID: currentBatchUID,\n      depth: depth,\n      lanes: lanesArray,\n      timestamp: getRelativeTime(),\n      duration: 0\n    };\n    currentReactMeasuresStack.push(reactMeasure);\n\n    if (currentTimelineData) {\n      var _currentTimelineData = currentTimelineData,\n          batchUIDToMeasuresMap = _currentTimelineData.batchUIDToMeasuresMap,\n          laneToReactMeasureMap = _currentTimelineData.laneToReactMeasureMap;\n      var reactMeasures = batchUIDToMeasuresMap.get(currentBatchUID);\n\n      if (reactMeasures != null) {\n        reactMeasures.push(reactMeasure);\n      } else {\n        batchUIDToMeasuresMap.set(currentBatchUID, [reactMeasure]);\n      }\n\n      lanesArray.forEach(function (lane) {\n        reactMeasures = laneToReactMeasureMap.get(lane);\n\n        if (reactMeasures) {\n          reactMeasures.push(reactMeasure);\n        }\n      });\n    }\n  }\n\n  function recordReactMeasureCompleted(type) {\n    var currentTime = getRelativeTime();\n\n    if (currentReactMeasuresStack.length === 0) {\n      console.error('Unexpected type \"%s\" completed at %sms while currentReactMeasuresStack is empty.', type, currentTime); // Ignore work \"completion\" user timing mark that doesn't complete anything\n\n      return;\n    }\n\n    var top = currentReactMeasuresStack.pop();\n\n    if (top.type !== type) {\n      console.error('Unexpected type \"%s\" completed at %sms before \"%s\" completed.', type, currentTime, top.type);\n    } // $FlowFixMe[cannot-write] This property should not be writable outside of this function.\n\n\n    top.duration = currentTime - top.timestamp;\n\n    if (currentTimelineData) {\n      currentTimelineData.duration = getRelativeTime() + TIME_OFFSET;\n    }\n  }\n\n  function markCommitStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('commit', lanes); // TODO (timeline) Re-think this approach to \"batching\"; I don't think it works for Suspense or pre-rendering.\n      // This issue applies to the User Timing data also.\n\n      nextRenderShouldStartNewBatch = true;\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--commit-start-\".concat(lanes)); // Some metadata only needs to be logged once per session,\n      // but if profiling information is being recorded via the Performance tab,\n      // DevTools has no way of knowing when the recording starts.\n      // Because of that, we log thie type of data periodically (once per commit).\n\n      markMetadata();\n    }\n  }\n\n  function markCommitStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('commit');\n      recordReactMeasureCompleted('render-idle');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--commit-stop');\n    }\n  }\n\n  function markComponentRenderStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'render',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-render-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentRenderStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-render-stop');\n    }\n  }\n\n  function markComponentLayoutEffectMountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'layout-effect-mount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-layout-effect-mount-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentLayoutEffectMountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-layout-effect-mount-stop');\n    }\n  }\n\n  function markComponentLayoutEffectUnmountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'layout-effect-unmount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-layout-effect-unmount-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentLayoutEffectUnmountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-layout-effect-unmount-stop');\n    }\n  }\n\n  function markComponentPassiveEffectMountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'passive-effect-mount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-passive-effect-mount-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentPassiveEffectMountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-passive-effect-mount-stop');\n    }\n  }\n\n  function markComponentPassiveEffectUnmountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'passive-effect-unmount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-passive-effect-unmount-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentPassiveEffectUnmountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-passive-effect-unmount-stop');\n    }\n  }\n\n  function markComponentErrored(fiber, thrownValue, lanes) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n      var phase = fiber.alternate === null ? 'mount' : 'update';\n      var message = '';\n\n      if (thrownValue !== null && profilingHooks_typeof(thrownValue) === 'object' && typeof thrownValue.message === 'string') {\n        message = thrownValue.message;\n      } else if (typeof thrownValue === 'string') {\n        message = thrownValue;\n      }\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          currentTimelineData.thrownErrors.push({\n            componentName: componentName,\n            message: message,\n            phase: phase,\n            timestamp: getRelativeTime(),\n            type: 'thrown-error'\n          });\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--error-\".concat(componentName, \"-\").concat(phase, \"-\").concat(message));\n      }\n    }\n  }\n\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // $FlowFixMe[incompatible-type]: Flow cannot handle polymorphic WeakMaps\n\n  var wakeableIDs = new PossiblyWeakMap();\n  var wakeableID = 0;\n\n  function getWakeableID(wakeable) {\n    if (!wakeableIDs.has(wakeable)) {\n      wakeableIDs.set(wakeable, wakeableID++);\n    }\n\n    return wakeableIDs.get(wakeable);\n  }\n\n  function markComponentSuspended(fiber, wakeable, lanes) {\n    if (isProfiling || supportsUserTimingV3) {\n      var eventType = wakeableIDs.has(wakeable) ? 'resuspend' : 'suspend';\n      var id = getWakeableID(wakeable);\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n      var phase = fiber.alternate === null ? 'mount' : 'update'; // Following the non-standard fn.displayName convention,\n      // frameworks like Relay may also annotate Promises with a displayName,\n      // describing what operation/data the thrown Promise is related to.\n      // When this is available we should pass it along to the Timeline.\n\n      var displayName = wakeable.displayName || '';\n      var suspenseEvent = null;\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        suspenseEvent = {\n          componentName: componentName,\n          depth: 0,\n          duration: 0,\n          id: \"\".concat(id),\n          phase: phase,\n          promiseName: displayName,\n          resolution: 'unresolved',\n          timestamp: getRelativeTime(),\n          type: 'suspense',\n          warning: null\n        };\n\n        if (currentTimelineData) {\n          currentTimelineData.suspenseEvents.push(suspenseEvent);\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--suspense-\".concat(eventType, \"-\").concat(id, \"-\").concat(componentName, \"-\").concat(phase, \"-\").concat(lanes, \"-\").concat(displayName));\n      }\n\n      wakeable.then(function () {\n        if (suspenseEvent) {\n          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;\n          suspenseEvent.resolution = 'resolved';\n        }\n\n        if (supportsUserTimingV3) {\n          markAndClear(\"--suspense-resolved-\".concat(id, \"-\").concat(componentName));\n        }\n      }, function () {\n        if (suspenseEvent) {\n          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;\n          suspenseEvent.resolution = 'rejected';\n        }\n\n        if (supportsUserTimingV3) {\n          markAndClear(\"--suspense-rejected-\".concat(id, \"-\").concat(componentName));\n        }\n      });\n    }\n  }\n\n  function markLayoutEffectsStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('layout-effects', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--layout-effects-start-\".concat(lanes));\n    }\n  }\n\n  function markLayoutEffectsStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('layout-effects');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--layout-effects-stop');\n    }\n  }\n\n  function markPassiveEffectsStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('passive-effects', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--passive-effects-start-\".concat(lanes));\n    }\n  }\n\n  function markPassiveEffectsStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('passive-effects');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--passive-effects-stop');\n    }\n  }\n\n  function markRenderStarted(lanes) {\n    if (isProfiling) {\n      if (nextRenderShouldStartNewBatch) {\n        nextRenderShouldStartNewBatch = false;\n        currentBatchUID++;\n      } // If this is a new batch of work, wrap an \"idle\" measure around it.\n      // Log it before the \"render\" measure to preserve the stack ordering.\n\n\n      if (currentReactMeasuresStack.length === 0 || currentReactMeasuresStack[currentReactMeasuresStack.length - 1].type !== 'render-idle') {\n        recordReactMeasureStarted('render-idle', lanes);\n      }\n\n      recordReactMeasureStarted('render', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--render-start-\".concat(lanes));\n    }\n  }\n\n  function markRenderYielded() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('render');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--render-yield');\n    }\n  }\n\n  function markRenderStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('render');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--render-stop');\n    }\n  }\n\n  function markRenderScheduled(lane) {\n    if (isProfiling) {\n      if (currentTimelineData) {\n        currentTimelineData.schedulingEvents.push({\n          lanes: laneToLanesArray(lane),\n          timestamp: getRelativeTime(),\n          type: 'schedule-render',\n          warning: null\n        });\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--schedule-render-\".concat(lane));\n    }\n  }\n\n  function markForceUpdateScheduled(fiber, lane) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          currentTimelineData.schedulingEvents.push({\n            componentName: componentName,\n            lanes: laneToLanesArray(lane),\n            timestamp: getRelativeTime(),\n            type: 'schedule-force-update',\n            warning: null\n          });\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--schedule-forced-update-\".concat(lane, \"-\").concat(componentName));\n      }\n    }\n  }\n\n  function getParentFibers(fiber) {\n    var parents = [];\n    var parent = fiber;\n\n    while (parent !== null) {\n      parents.push(parent);\n      parent = parent.return;\n    }\n\n    return parents;\n  }\n\n  function markStateUpdateScheduled(fiber, lane) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          var event = {\n            componentName: componentName,\n            // Store the parent fibers so we can post process\n            // them after we finish profiling\n            lanes: laneToLanesArray(lane),\n            timestamp: getRelativeTime(),\n            type: 'schedule-state-update',\n            warning: null\n          };\n          currentFiberStacks.set(event, getParentFibers(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n          currentTimelineData.schedulingEvents.push(event);\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--schedule-state-update-\".concat(lane, \"-\").concat(componentName));\n      }\n    }\n  }\n\n  function toggleProfilingStatus(value) {\n    if (isProfiling !== value) {\n      isProfiling = value;\n\n      if (isProfiling) {\n        var internalModuleSourceToRanges = new Map();\n\n        if (supportsUserTimingV3) {\n          var ranges = getInternalModuleRanges();\n\n          if (ranges) {\n            for (var i = 0; i < ranges.length; i++) {\n              var range = ranges[i];\n\n              if (shared_isArray(range) && range.length === 2) {\n                var _ranges$i2 = profilingHooks_slicedToArray(ranges[i], 2),\n                    startStackFrame = _ranges$i2[0],\n                    stopStackFrame = _ranges$i2[1];\n\n                markAndClear(\"--react-internal-module-start-\".concat(startStackFrame));\n                markAndClear(\"--react-internal-module-stop-\".concat(stopStackFrame));\n              }\n            }\n          }\n        }\n\n        var laneToReactMeasureMap = new Map();\n        var lane = 1;\n\n        for (var index = 0; index < REACT_TOTAL_NUM_LANES; index++) {\n          laneToReactMeasureMap.set(lane, []);\n          lane *= 2;\n        }\n\n        currentBatchUID = 0;\n        currentReactComponentMeasure = null;\n        currentReactMeasuresStack = [];\n        currentFiberStacks = new Map();\n        currentTimelineData = {\n          // Session wide metadata; only collected once.\n          internalModuleSourceToRanges: internalModuleSourceToRanges,\n          laneToLabelMap: laneToLabelMap || new Map(),\n          reactVersion: reactVersion,\n          // Data logged by React during profiling session.\n          componentMeasures: [],\n          schedulingEvents: [],\n          suspenseEvents: [],\n          thrownErrors: [],\n          // Data inferred based on what React logs.\n          batchUIDToMeasuresMap: new Map(),\n          duration: 0,\n          laneToReactMeasureMap: laneToReactMeasureMap,\n          startTime: 0,\n          // Data only available in Chrome profiles.\n          flamechart: [],\n          nativeEvents: [],\n          networkMeasures: [],\n          otherUserTimingMarks: [],\n          snapshots: [],\n          snapshotHeight: 0\n        };\n        nextRenderShouldStartNewBatch = true;\n      } else {\n        // Postprocess Profile data\n        if (currentTimelineData !== null) {\n          currentTimelineData.schedulingEvents.forEach(function (event) {\n            if (event.type === 'schedule-state-update') {\n              // TODO(luna): We can optimize this by creating a map of\n              // fiber to component stack instead of generating the stack\n              // for every fiber every time\n              var fiberStack = currentFiberStacks.get(event);\n\n              if (fiberStack && currentDispatcherRef != null) {\n                event.componentStack = fiberStack.reduce(function (trace, fiber) {\n                  return trace + describeFiber(workTagMap, fiber, currentDispatcherRef);\n                }, '');\n              }\n            }\n          });\n        } // Clear the current fiber stacks so we don't hold onto the fibers\n        // in memory after profiling finishes\n\n\n        currentFiberStacks.clear();\n      }\n    }\n  }\n\n  return {\n    getTimelineData: getTimelineData,\n    profilingHooks: {\n      markCommitStarted: markCommitStarted,\n      markCommitStopped: markCommitStopped,\n      markComponentRenderStarted: markComponentRenderStarted,\n      markComponentRenderStopped: markComponentRenderStopped,\n      markComponentPassiveEffectMountStarted: markComponentPassiveEffectMountStarted,\n      markComponentPassiveEffectMountStopped: markComponentPassiveEffectMountStopped,\n      markComponentPassiveEffectUnmountStarted: markComponentPassiveEffectUnmountStarted,\n      markComponentPassiveEffectUnmountStopped: markComponentPassiveEffectUnmountStopped,\n      markComponentLayoutEffectMountStarted: markComponentLayoutEffectMountStarted,\n      markComponentLayoutEffectMountStopped: markComponentLayoutEffectMountStopped,\n      markComponentLayoutEffectUnmountStarted: markComponentLayoutEffectUnmountStarted,\n      markComponentLayoutEffectUnmountStopped: markComponentLayoutEffectUnmountStopped,\n      markComponentErrored: markComponentErrored,\n      markComponentSuspended: markComponentSuspended,\n      markLayoutEffectsStarted: markLayoutEffectsStarted,\n      markLayoutEffectsStopped: markLayoutEffectsStopped,\n      markPassiveEffectsStarted: markPassiveEffectsStarted,\n      markPassiveEffectsStopped: markPassiveEffectsStopped,\n      markRenderStarted: markRenderStarted,\n      markRenderYielded: markRenderYielded,\n      markRenderStopped: markRenderStopped,\n      markRenderScheduled: markRenderScheduled,\n      markForceUpdateScheduled: markForceUpdateScheduled,\n      markStateUpdateScheduled: markStateUpdateScheduled\n    },\n    toggleProfilingStatus: toggleProfilingStatus\n  };\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/renderer.js\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction renderer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction renderer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { renderer_ownKeys(Object(source), true).forEach(function (key) { renderer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { renderer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction renderer_slicedToArray(arr, i) { return renderer_arrayWithHoles(arr) || renderer_iterableToArrayLimit(arr, i) || renderer_unsupportedIterableToArray(arr, i) || renderer_nonIterableRest(); }\n\nfunction renderer_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction renderer_iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction renderer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction renderer_toConsumableArray(arr) { return renderer_arrayWithoutHoles(arr) || renderer_iterableToArray(arr) || renderer_unsupportedIterableToArray(arr) || renderer_nonIterableSpread(); }\n\nfunction renderer_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction renderer_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction renderer_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return renderer_arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = renderer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction renderer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return renderer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return renderer_arrayLikeToArray(o, minLen); }\n\nfunction renderer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction renderer_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return renderer_typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getFiberFlags(fiber) {\n  // The name of this field changed from \"effectTag\" to \"flags\"\n  return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;\n} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n\nvar renderer_getCurrentTime = // $FlowFixMe[method-unbinding]\n(typeof performance === \"undefined\" ? \"undefined\" : renderer_typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction getInternalReactConstants(version) {\n  // **********************************************************\n  // The section below is copied from files in React repo.\n  // Keep it in sync, and add version guards if it changes.\n  //\n  // Technically these priority levels are invalid for versions before 16.9,\n  // but 16.9 is the first version to report priority level to DevTools,\n  // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.\n  var ReactPriorityLevels = {\n    ImmediatePriority: 99,\n    UserBlockingPriority: 98,\n    NormalPriority: 97,\n    LowPriority: 96,\n    IdlePriority: 95,\n    NoPriority: 90\n  };\n\n  if (gt(version, '17.0.2')) {\n    ReactPriorityLevels = {\n      ImmediatePriority: 1,\n      UserBlockingPriority: 2,\n      NormalPriority: 3,\n      LowPriority: 4,\n      IdlePriority: 5,\n      NoPriority: 0\n    };\n  }\n\n  var StrictModeBits = 0;\n\n  if (gte(version, '18.0.0-alpha')) {\n    // 18+\n    StrictModeBits = 24;\n  } else if (gte(version, '16.9.0')) {\n    // 16.9 - 17\n    StrictModeBits = 1;\n  } else if (gte(version, '16.3.0')) {\n    // 16.3 - 16.8\n    StrictModeBits = 2;\n  }\n\n  var ReactTypeOfWork = null; // **********************************************************\n  // The section below is copied from files in React repo.\n  // Keep it in sync, and add version guards if it changes.\n  //\n  // TODO Update the gt() check below to be gte() whichever the next version number is.\n  // Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).\n\n  if (gt(version, '17.0.1')) {\n    ReactTypeOfWork = {\n      CacheComponent: 24,\n      // Experimental\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostHoistable: 26,\n      // In reality, 18.2+. But doesn't hurt to include it here\n      HostSingleton: 27,\n      // Same as above\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: 23,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: 22,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: 21,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: 25,\n      // Experimental - This is technically in 18 but we don't\n      // want to fork again so we're adding it here instead\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (gte(version, '17.0.0-alpha')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostHoistable: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: 24,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: 23,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: 21,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (gte(version, '16.6.0-beta.0')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostHoistable: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: -1,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (gte(version, '16.4.3-alpha')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 2,\n      ContextConsumer: 11,\n      ContextProvider: 12,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: -1,\n      // Doesn't exist yet\n      ForwardRef: 13,\n      Fragment: 9,\n      FunctionComponent: 0,\n      HostComponent: 7,\n      HostPortal: 6,\n      HostRoot: 5,\n      HostHoistable: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 8,\n      IncompleteClassComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 4,\n      LazyComponent: -1,\n      // Doesn't exist yet\n      LegacyHiddenComponent: -1,\n      MemoComponent: -1,\n      // Doesn't exist yet\n      Mode: 10,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 15,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: -1,\n      // Doesn't exist yet\n      SuspenseComponent: 16,\n      SuspenseListComponent: -1,\n      // Doesn't exist yet\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1 // Removed\n\n    };\n  } else {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 2,\n      ContextConsumer: 12,\n      ContextProvider: 13,\n      CoroutineComponent: 7,\n      CoroutineHandlerPhase: 8,\n      DehydratedSuspenseComponent: -1,\n      // Doesn't exist yet\n      ForwardRef: 14,\n      Fragment: 10,\n      FunctionComponent: 1,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostHoistable: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 0,\n      LazyComponent: -1,\n      // Doesn't exist yet\n      LegacyHiddenComponent: -1,\n      MemoComponent: -1,\n      // Doesn't exist yet\n      Mode: 11,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 15,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: -1,\n      // Doesn't exist yet\n      SuspenseComponent: 16,\n      SuspenseListComponent: -1,\n      // Doesn't exist yet\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: 9\n    };\n  } // **********************************************************\n  // End of copied code.\n  // **********************************************************\n\n\n  function getTypeSymbol(type) {\n    var symbolOrNumber = renderer_typeof(type) === 'object' && type !== null ? type.$$typeof : type;\n    return renderer_typeof(symbolOrNumber) === 'symbol' ? // $FlowFixMe[incompatible-return] `toString()` doesn't match the type signature?\n    symbolOrNumber.toString() : symbolOrNumber;\n  }\n\n  var _ReactTypeOfWork = ReactTypeOfWork,\n      CacheComponent = _ReactTypeOfWork.CacheComponent,\n      ClassComponent = _ReactTypeOfWork.ClassComponent,\n      IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent,\n      FunctionComponent = _ReactTypeOfWork.FunctionComponent,\n      IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent,\n      ForwardRef = _ReactTypeOfWork.ForwardRef,\n      HostRoot = _ReactTypeOfWork.HostRoot,\n      HostHoistable = _ReactTypeOfWork.HostHoistable,\n      HostSingleton = _ReactTypeOfWork.HostSingleton,\n      HostComponent = _ReactTypeOfWork.HostComponent,\n      HostPortal = _ReactTypeOfWork.HostPortal,\n      HostText = _ReactTypeOfWork.HostText,\n      Fragment = _ReactTypeOfWork.Fragment,\n      LazyComponent = _ReactTypeOfWork.LazyComponent,\n      LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent,\n      MemoComponent = _ReactTypeOfWork.MemoComponent,\n      OffscreenComponent = _ReactTypeOfWork.OffscreenComponent,\n      Profiler = _ReactTypeOfWork.Profiler,\n      ScopeComponent = _ReactTypeOfWork.ScopeComponent,\n      SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent,\n      SuspenseComponent = _ReactTypeOfWork.SuspenseComponent,\n      SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent,\n      TracingMarkerComponent = _ReactTypeOfWork.TracingMarkerComponent;\n\n  function resolveFiberType(type) {\n    var typeSymbol = getTypeSymbol(type);\n\n    switch (typeSymbol) {\n      case ReactSymbols_MEMO_NUMBER:\n      case ReactSymbols_MEMO_SYMBOL_STRING:\n        // recursively resolving memo type in case of memo(forwardRef(Component))\n        return resolveFiberType(type.type);\n\n      case ReactSymbols_FORWARD_REF_NUMBER:\n      case ReactSymbols_FORWARD_REF_SYMBOL_STRING:\n        return type.render;\n\n      default:\n        return type;\n    }\n  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n  function getDisplayNameForFiber(fiber) {\n    var elementType = fiber.elementType,\n        type = fiber.type,\n        tag = fiber.tag;\n    var resolvedType = type;\n\n    if (renderer_typeof(type) === 'object' && type !== null) {\n      resolvedType = resolveFiberType(type);\n    }\n\n    var resolvedContext = null;\n\n    switch (tag) {\n      case CacheComponent:\n        return 'Cache';\n\n      case ClassComponent:\n      case IncompleteClassComponent:\n        return getDisplayName(resolvedType);\n\n      case FunctionComponent:\n      case IndeterminateComponent:\n        return getDisplayName(resolvedType);\n\n      case ForwardRef:\n        return getWrappedDisplayName(elementType, resolvedType, 'ForwardRef', 'Anonymous');\n\n      case HostRoot:\n        var fiberRoot = fiber.stateNode;\n\n        if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n          return fiberRoot._debugRootType;\n        }\n\n        return null;\n\n      case HostComponent:\n      case HostSingleton:\n      case HostHoistable:\n        return type;\n\n      case HostPortal:\n      case HostText:\n        return null;\n\n      case Fragment:\n        return 'Fragment';\n\n      case LazyComponent:\n        // This display name will not be user visible.\n        // Once a Lazy component loads its inner component, React replaces the tag and type.\n        // This display name will only show up in console logs when DevTools DEBUG mode is on.\n        return 'Lazy';\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        // Display name in React does not use `Memo` as a wrapper but fallback name.\n        return getWrappedDisplayName(elementType, resolvedType, 'Memo', 'Anonymous');\n\n      case SuspenseComponent:\n        return 'Suspense';\n\n      case LegacyHiddenComponent:\n        return 'LegacyHidden';\n\n      case OffscreenComponent:\n        return 'Offscreen';\n\n      case ScopeComponent:\n        return 'Scope';\n\n      case SuspenseListComponent:\n        return 'SuspenseList';\n\n      case Profiler:\n        return 'Profiler';\n\n      case TracingMarkerComponent:\n        return 'TracingMarker';\n\n      default:\n        var typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case CONCURRENT_MODE_NUMBER:\n          case CONCURRENT_MODE_SYMBOL_STRING:\n          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:\n            return null;\n\n          case PROVIDER_NUMBER:\n          case PROVIDER_SYMBOL_STRING:\n            // 16.3.0 exposed the context object as \"context\"\n            // PR #12501 changed it to \"_context\" for 16.3.1+\n            // NOTE Keep in sync with inspectElementRaw()\n            resolvedContext = fiber.type._context || fiber.type.context;\n            return \"\".concat(resolvedContext.displayName || 'Context', \".Provider\");\n\n          case CONTEXT_NUMBER:\n          case CONTEXT_SYMBOL_STRING:\n          case SERVER_CONTEXT_SYMBOL_STRING:\n            // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n            // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n            // NOTE Keep in sync with inspectElementRaw()\n            resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'\n            // If you change the name, figure out a more resilient way to detect it.\n\n            return \"\".concat(resolvedContext.displayName || 'Context', \".Consumer\");\n\n          case STRICT_MODE_NUMBER:\n          case STRICT_MODE_SYMBOL_STRING:\n            return null;\n\n          case PROFILER_NUMBER:\n          case PROFILER_SYMBOL_STRING:\n            return \"Profiler(\".concat(fiber.memoizedProps.id, \")\");\n\n          case SCOPE_NUMBER:\n          case SCOPE_SYMBOL_STRING:\n            return 'Scope';\n\n          default:\n            // Unknown element type.\n            // This may mean a new element type that has not yet been added to DevTools.\n            return null;\n        }\n\n    }\n  }\n\n  return {\n    getDisplayNameForFiber: getDisplayNameForFiber,\n    getTypeSymbol: getTypeSymbol,\n    ReactPriorityLevels: ReactPriorityLevels,\n    ReactTypeOfWork: ReactTypeOfWork,\n    StrictModeBits: StrictModeBits\n  };\n} // Map of one or more Fibers in a pair to their unique id number.\n// We track both Fibers to support Fast Refresh,\n// which may forcefully replace one of the pair as part of hot reloading.\n// In that case it's still important to be able to locate the previous ID during subsequent renders.\n\nvar fiberToIDMap = new Map(); // Map of id to one (arbitrary) Fiber in a pair.\n// This Map is used to e.g. get the display name for a Fiber or schedule an update,\n// operations that should be the same whether the current and work-in-progress Fiber is used.\n\nvar idToArbitraryFiberMap = new Map();\nfunction attach(hook, rendererID, renderer, global) {\n  // Newer versions of the reconciler package also specific reconciler version.\n  // If that version number is present, use it.\n  // Third party renderer versions may not match the reconciler version,\n  // and the latter is what's important in terms of tags and symbols.\n  var version = renderer.reconcilerVersion || renderer.version;\n\n  var _getInternalReactCons = getInternalReactConstants(version),\n      getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber,\n      getTypeSymbol = _getInternalReactCons.getTypeSymbol,\n      ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels,\n      ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,\n      StrictModeBits = _getInternalReactCons.StrictModeBits;\n\n  var CacheComponent = ReactTypeOfWork.CacheComponent,\n      ClassComponent = ReactTypeOfWork.ClassComponent,\n      ContextConsumer = ReactTypeOfWork.ContextConsumer,\n      DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent,\n      ForwardRef = ReactTypeOfWork.ForwardRef,\n      Fragment = ReactTypeOfWork.Fragment,\n      FunctionComponent = ReactTypeOfWork.FunctionComponent,\n      HostRoot = ReactTypeOfWork.HostRoot,\n      HostHoistable = ReactTypeOfWork.HostHoistable,\n      HostSingleton = ReactTypeOfWork.HostSingleton,\n      HostPortal = ReactTypeOfWork.HostPortal,\n      HostComponent = ReactTypeOfWork.HostComponent,\n      HostText = ReactTypeOfWork.HostText,\n      IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent,\n      IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,\n      LegacyHiddenComponent = ReactTypeOfWork.LegacyHiddenComponent,\n      MemoComponent = ReactTypeOfWork.MemoComponent,\n      OffscreenComponent = ReactTypeOfWork.OffscreenComponent,\n      SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent,\n      SuspenseComponent = ReactTypeOfWork.SuspenseComponent,\n      SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent,\n      TracingMarkerComponent = ReactTypeOfWork.TracingMarkerComponent;\n  var ImmediatePriority = ReactPriorityLevels.ImmediatePriority,\n      UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority,\n      NormalPriority = ReactPriorityLevels.NormalPriority,\n      LowPriority = ReactPriorityLevels.LowPriority,\n      IdlePriority = ReactPriorityLevels.IdlePriority,\n      NoPriority = ReactPriorityLevels.NoPriority;\n  var getLaneLabelMap = renderer.getLaneLabelMap,\n      injectProfilingHooks = renderer.injectProfilingHooks,\n      overrideHookState = renderer.overrideHookState,\n      overrideHookStateDeletePath = renderer.overrideHookStateDeletePath,\n      overrideHookStateRenamePath = renderer.overrideHookStateRenamePath,\n      overrideProps = renderer.overrideProps,\n      overridePropsDeletePath = renderer.overridePropsDeletePath,\n      overridePropsRenamePath = renderer.overridePropsRenamePath,\n      scheduleRefresh = renderer.scheduleRefresh,\n      setErrorHandler = renderer.setErrorHandler,\n      setSuspenseHandler = renderer.setSuspenseHandler,\n      scheduleUpdate = renderer.scheduleUpdate;\n  var supportsTogglingError = typeof setErrorHandler === 'function' && typeof scheduleUpdate === 'function';\n  var supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function';\n\n  if (typeof scheduleRefresh === 'function') {\n    // When Fast Refresh updates a component, the frontend may need to purge cached information.\n    // For example, ASTs cached for the component (for named hooks) may no longer be valid.\n    // Send a signal to the frontend to purge this cached information.\n    // The \"fastRefreshScheduled\" dispatched is global (not Fiber or even Renderer specific).\n    // This is less effecient since it means the front-end will need to purge the entire cache,\n    // but this is probably an okay trade off in order to reduce coupling between the DevTools and Fast Refresh.\n    renderer.scheduleRefresh = function () {\n      try {\n        hook.emit('fastRefreshScheduled');\n      } finally {\n        return scheduleRefresh.apply(void 0, arguments);\n      }\n    };\n  }\n\n  var getTimelineData = null;\n  var toggleProfilingStatus = null;\n\n  if (typeof injectProfilingHooks === 'function') {\n    var response = createProfilingHooks({\n      getDisplayNameForFiber: getDisplayNameForFiber,\n      getIsProfiling: function getIsProfiling() {\n        return isProfiling;\n      },\n      getLaneLabelMap: getLaneLabelMap,\n      currentDispatcherRef: renderer.currentDispatcherRef,\n      workTagMap: ReactTypeOfWork,\n      reactVersion: version\n    }); // Pass the Profiling hooks to the reconciler for it to call during render.\n\n    injectProfilingHooks(response.profilingHooks); // Hang onto this toggle so we can notify the external methods of profiling status changes.\n\n    getTimelineData = response.getTimelineData;\n    toggleProfilingStatus = response.toggleProfilingStatus;\n  } // Tracks Fibers with recently changed number of error/warning messages.\n  // These collections store the Fiber rather than the ID,\n  // in order to avoid generating an ID for Fibers that never get mounted\n  // (due to e.g. Suspense or error boundaries).\n  // onErrorOrWarning() adds Fibers and recordPendingErrorsAndWarnings() later clears them.\n\n\n  var fibersWithChangedErrorOrWarningCounts = new Set();\n  var pendingFiberToErrorsMap = new Map();\n  var pendingFiberToWarningsMap = new Map(); // Mapping of fiber IDs to error/warning messages and counts.\n\n  var fiberIDToErrorsMap = new Map();\n  var fiberIDToWarningsMap = new Map();\n\n  function clearErrorsAndWarnings() {\n    // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n    var _iterator = _createForOfIteratorHelper(fiberIDToErrorsMap.keys()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var id = _step.value;\n\n        var _fiber = idToArbitraryFiberMap.get(id);\n\n        if (_fiber != null) {\n          fibersWithChangedErrorOrWarningCounts.add(_fiber);\n          updateMostRecentlyInspectedElementIfNecessary(id);\n        }\n      } // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(fiberIDToWarningsMap.keys()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _id = _step2.value;\n\n        var _fiber2 = idToArbitraryFiberMap.get(_id);\n\n        if (_fiber2 != null) {\n          fibersWithChangedErrorOrWarningCounts.add(_fiber2);\n          updateMostRecentlyInspectedElementIfNecessary(_id);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    fiberIDToErrorsMap.clear();\n    fiberIDToWarningsMap.clear();\n    flushPendingEvents();\n  }\n\n  function clearMessageCountHelper(fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {\n    var fiber = idToArbitraryFiberMap.get(fiberID);\n\n    if (fiber != null) {\n      // Throw out any pending changes.\n      pendingFiberToErrorsMap.delete(fiber);\n\n      if (fiberIDToMessageCountMap.has(fiberID)) {\n        fiberIDToMessageCountMap.delete(fiberID); // If previous flushed counts have changed, schedule an update too.\n\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n        flushPendingEvents();\n        updateMostRecentlyInspectedElementIfNecessary(fiberID);\n      } else {\n        fibersWithChangedErrorOrWarningCounts.delete(fiber);\n      }\n    }\n  }\n\n  function clearErrorsForFiberID(fiberID) {\n    clearMessageCountHelper(fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);\n  }\n\n  function clearWarningsForFiberID(fiberID) {\n    clearMessageCountHelper(fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);\n  }\n\n  function updateMostRecentlyInspectedElementIfNecessary(fiberID) {\n    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {\n      hasElementUpdatedSinceLastInspected = true;\n    }\n  } // Called when an error or warning is logged during render, commit, or passive (including unmount functions).\n\n\n  function onErrorOrWarning(fiber, type, args) {\n    if (type === 'error') {\n      var maybeID = getFiberIDUnsafe(fiber); // if this is an error simulated by us to trigger error boundary, ignore\n\n      if (maybeID != null && forceErrorForFiberIDs.get(maybeID) === true) {\n        return;\n      }\n    }\n\n    var message = format.apply(void 0, renderer_toConsumableArray(args));\n\n    if (__DEBUG__) {\n      debug('onErrorOrWarning', fiber, null, \"\".concat(type, \": \\\"\").concat(message, \"\\\"\"));\n    } // Mark this Fiber as needed its warning/error count updated during the next flush.\n\n\n    fibersWithChangedErrorOrWarningCounts.add(fiber); // Track the warning/error for later.\n\n    var fiberMap = type === 'error' ? pendingFiberToErrorsMap : pendingFiberToWarningsMap;\n    var messageMap = fiberMap.get(fiber);\n\n    if (messageMap != null) {\n      var count = messageMap.get(message) || 0;\n      messageMap.set(message, count + 1);\n    } else {\n      fiberMap.set(fiber, new Map([[message, 1]]));\n    } // Passive effects may trigger errors or warnings too;\n    // In this case, we should wait until the rest of the passive effects have run,\n    // but we shouldn't wait until the next commit because that might be a long time.\n    // This would also cause \"tearing\" between an inspected Component and the tree view.\n    // Then again we don't want to flush too soon because this could be an error during async rendering.\n    // Use a debounce technique to ensure that we'll eventually flush.\n\n\n    flushPendingErrorsAndWarningsAfterDelay();\n  } // Patching the console enables DevTools to do a few useful things:\n  // * Append component stacks to warnings and error messages\n  // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)\n\n\n  registerRenderer(renderer, onErrorOrWarning); // The renderer interface can't read these preferences directly,\n  // because it is stored in localStorage within the context of the extension.\n  // It relies on the extension to pass the preference through via the global.\n\n  patchConsoleUsingWindowValues();\n\n  var debug = function debug(name, fiber, parentFiber) {\n    var extraString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n    if (__DEBUG__) {\n      var displayName = fiber.tag + ':' + (getDisplayNameForFiber(fiber) || 'null');\n      var maybeID = getFiberIDUnsafe(fiber) || '<no id>';\n      var parentDisplayName = parentFiber ? parentFiber.tag + ':' + (getDisplayNameForFiber(parentFiber) || 'null') : '';\n      var maybeParentID = parentFiber ? getFiberIDUnsafe(parentFiber) || '<no-id>' : '';\n      console.groupCollapsed(\"[renderer] %c\".concat(name, \" %c\").concat(displayName, \" (\").concat(maybeID, \") %c\").concat(parentFiber ? \"\".concat(parentDisplayName, \" (\").concat(maybeParentID, \")\") : '', \" %c\").concat(extraString), 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;', 'color: black;');\n      console.log(new Error().stack.split('\\n').slice(1).join('\\n'));\n      console.groupEnd();\n    }\n  }; // Configurable Components tree filters.\n\n\n  var hideElementsWithDisplayNames = new Set();\n  var hideElementsWithPaths = new Set();\n  var hideElementsWithTypes = new Set(); // Highlight updates\n\n  var traceUpdatesEnabled = false;\n  var traceUpdatesForNodes = new Set();\n\n  function applyComponentFilters(componentFilters) {\n    hideElementsWithTypes.clear();\n    hideElementsWithDisplayNames.clear();\n    hideElementsWithPaths.clear();\n    componentFilters.forEach(function (componentFilter) {\n      if (!componentFilter.isEnabled) {\n        return;\n      }\n\n      switch (componentFilter.type) {\n        case ComponentFilterDisplayName:\n          if (componentFilter.isValid && componentFilter.value !== '') {\n            hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));\n          }\n\n          break;\n\n        case ComponentFilterElementType:\n          hideElementsWithTypes.add(componentFilter.value);\n          break;\n\n        case ComponentFilterLocation:\n          if (componentFilter.isValid && componentFilter.value !== '') {\n            hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));\n          }\n\n          break;\n\n        case ComponentFilterHOC:\n          hideElementsWithDisplayNames.add(new RegExp('\\\\('));\n          break;\n\n        default:\n          console.warn(\"Invalid component filter type \\\"\".concat(componentFilter.type, \"\\\"\"));\n          break;\n      }\n    });\n  } // The renderer interface can't read saved component filters directly,\n  // because they are stored in localStorage within the context of the extension.\n  // Instead it relies on the extension to pass filters through.\n\n\n  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {\n    applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);\n  } else {\n    // Unfortunately this feature is not expected to work for React Native for now.\n    // It would be annoying for us to spam YellowBox warnings with unactionable stuff,\n    // so for now just skip this message...\n    //console.warn(' DevTools: Could not locate saved component filters');\n    // Fallback to assuming the default filters in this case.\n    applyComponentFilters(getDefaultComponentFilters());\n  } // If necessary, we can revisit optimizing this operation.\n  // For example, we could add a new recursive unmount tree operation.\n  // The unmount operations are already significantly smaller than mount operations though.\n  // This is something to keep in mind for later.\n\n\n  function updateComponentFilters(componentFilters) {\n    if (isProfiling) {\n      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.\n      // If necessary, we could support this- but it doesn't seem like a necessary use case.\n      throw Error('Cannot modify filter preferences while profiling');\n    } // Recursively unmount all roots.\n\n\n    hook.getFiberRoots(rendererID).forEach(function (root) {\n      currentRootID = getOrGenerateFiberID(root.current); // The TREE_OPERATION_REMOVE_ROOT operation serves two purposes:\n      // 1. It avoids sending unnecessary bridge traffic to clear a root.\n      // 2. It preserves Fiber IDs when remounting (below) which in turn ID to error/warning mapping.\n\n      pushOperation(TREE_OPERATION_REMOVE_ROOT);\n      flushPendingEvents(root);\n      currentRootID = -1;\n    });\n    applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.\n\n    rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.\n\n    hook.getFiberRoots(rendererID).forEach(function (root) {\n      currentRootID = getOrGenerateFiberID(root.current);\n      setRootPseudoKey(currentRootID, root.current);\n      mountFiberRecursively(root.current, null, false, false);\n      flushPendingEvents(root);\n      currentRootID = -1;\n    }); // Also re-evaluate all error and warning counts given the new filters.\n\n    reevaluateErrorsAndWarnings();\n    flushPendingEvents();\n  } // NOTICE Keep in sync with get*ForFiber methods\n\n\n  function shouldFilterFiber(fiber) {\n    var _debugSource = fiber._debugSource,\n        tag = fiber.tag,\n        type = fiber.type,\n        key = fiber.key;\n\n    switch (tag) {\n      case DehydratedSuspenseComponent:\n        // TODO: ideally we would show dehydrated Suspense immediately.\n        // However, it has some special behavior (like disconnecting\n        // an alternate and turning into real Suspense) which breaks DevTools.\n        // For now, ignore it, and only show it once it gets hydrated.\n        // https://github.com/bvaughn/react-devtools-experimental/issues/197\n        return true;\n\n      case HostPortal:\n      case HostText:\n      case LegacyHiddenComponent:\n      case OffscreenComponent:\n        return true;\n\n      case HostRoot:\n        // It is never valid to filter the root element.\n        return false;\n\n      case Fragment:\n        return key === null;\n\n      default:\n        var typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case CONCURRENT_MODE_NUMBER:\n          case CONCURRENT_MODE_SYMBOL_STRING:\n          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:\n          case STRICT_MODE_NUMBER:\n          case STRICT_MODE_SYMBOL_STRING:\n            return true;\n\n          default:\n            break;\n        }\n\n    }\n\n    var elementType = getElementTypeForFiber(fiber);\n\n    if (hideElementsWithTypes.has(elementType)) {\n      return true;\n    }\n\n    if (hideElementsWithDisplayNames.size > 0) {\n      var displayName = getDisplayNameForFiber(fiber);\n\n      if (displayName != null) {\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n        var _iterator3 = _createForOfIteratorHelper(hideElementsWithDisplayNames),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var displayNameRegExp = _step3.value;\n\n            if (displayNameRegExp.test(displayName)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n\n    if (_debugSource != null && hideElementsWithPaths.size > 0) {\n      var fileName = _debugSource.fileName; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n      var _iterator4 = _createForOfIteratorHelper(hideElementsWithPaths),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var pathRegExp = _step4.value;\n\n          if (pathRegExp.test(fileName)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n\n    return false;\n  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n  function getElementTypeForFiber(fiber) {\n    var type = fiber.type,\n        tag = fiber.tag;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n        return types_ElementTypeClass;\n\n      case FunctionComponent:\n      case IndeterminateComponent:\n        return types_ElementTypeFunction;\n\n      case ForwardRef:\n        return types_ElementTypeForwardRef;\n\n      case HostRoot:\n        return ElementTypeRoot;\n\n      case HostComponent:\n      case HostHoistable:\n      case HostSingleton:\n        return ElementTypeHostComponent;\n\n      case HostPortal:\n      case HostText:\n      case Fragment:\n        return ElementTypeOtherOrUnknown;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        return types_ElementTypeMemo;\n\n      case SuspenseComponent:\n        return ElementTypeSuspense;\n\n      case SuspenseListComponent:\n        return ElementTypeSuspenseList;\n\n      case TracingMarkerComponent:\n        return ElementTypeTracingMarker;\n\n      default:\n        var typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case CONCURRENT_MODE_NUMBER:\n          case CONCURRENT_MODE_SYMBOL_STRING:\n          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:\n            return ElementTypeOtherOrUnknown;\n\n          case PROVIDER_NUMBER:\n          case PROVIDER_SYMBOL_STRING:\n            return ElementTypeContext;\n\n          case CONTEXT_NUMBER:\n          case CONTEXT_SYMBOL_STRING:\n            return ElementTypeContext;\n\n          case STRICT_MODE_NUMBER:\n          case STRICT_MODE_SYMBOL_STRING:\n            return ElementTypeOtherOrUnknown;\n\n          case PROFILER_NUMBER:\n          case PROFILER_SYMBOL_STRING:\n            return ElementTypeProfiler;\n\n          default:\n            return ElementTypeOtherOrUnknown;\n        }\n\n    }\n  } // When profiling is supported, we store the latest tree base durations for each Fiber.\n  // This is so that we can quickly capture a snapshot of those values if profiling starts.\n  // If we didn't store these values, we'd have to crawl the tree when profiling started,\n  // and use a slow path to find each of the current Fibers.\n\n\n  var idToTreeBaseDurationMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.\n  // This map enables us to filter these times by root when sending them to the frontend.\n\n  var idToRootMap = new Map(); // When a mount or update is in progress, this value tracks the root that is being operated on.\n\n  var currentRootID = -1; // Returns the unique ID for a Fiber or generates and caches a new one if the Fiber hasn't been seen before.\n  // Once this method has been called for a Fiber, untrackFiberID() should always be called later to avoid leaking.\n\n  function getOrGenerateFiberID(fiber) {\n    var id = null;\n\n    if (fiberToIDMap.has(fiber)) {\n      id = fiberToIDMap.get(fiber);\n    } else {\n      var _alternate = fiber.alternate;\n\n      if (_alternate !== null && fiberToIDMap.has(_alternate)) {\n        id = fiberToIDMap.get(_alternate);\n      }\n    }\n\n    var didGenerateID = false;\n\n    if (id === null) {\n      didGenerateID = true;\n      id = getUID();\n    } // This refinement is for Flow purposes only.\n\n\n    var refinedID = id; // Make sure we're tracking this Fiber\n    // e.g. if it just mounted or an error was logged during initial render.\n\n    if (!fiberToIDMap.has(fiber)) {\n      fiberToIDMap.set(fiber, refinedID);\n      idToArbitraryFiberMap.set(refinedID, fiber);\n    } // Also make sure we're tracking its alternate,\n    // e.g. in case this is the first update after mount.\n\n\n    var alternate = fiber.alternate;\n\n    if (alternate !== null) {\n      if (!fiberToIDMap.has(alternate)) {\n        fiberToIDMap.set(alternate, refinedID);\n      }\n    }\n\n    if (__DEBUG__) {\n      if (didGenerateID) {\n        debug('getOrGenerateFiberID()', fiber, fiber.return, 'Generated a new UID');\n      }\n    }\n\n    return refinedID;\n  } // Returns an ID if one has already been generated for the Fiber or throws.\n\n\n  function getFiberIDThrows(fiber) {\n    var maybeID = getFiberIDUnsafe(fiber);\n\n    if (maybeID !== null) {\n      return maybeID;\n    }\n\n    throw Error(\"Could not find ID for Fiber \\\"\".concat(getDisplayNameForFiber(fiber) || '', \"\\\"\"));\n  } // Returns an ID if one has already been generated for the Fiber or null if one has not been generated.\n  // Use this method while e.g. logging to avoid over-retaining Fibers.\n\n\n  function getFiberIDUnsafe(fiber) {\n    if (fiberToIDMap.has(fiber)) {\n      return fiberToIDMap.get(fiber);\n    } else {\n      var alternate = fiber.alternate;\n\n      if (alternate !== null && fiberToIDMap.has(alternate)) {\n        return fiberToIDMap.get(alternate);\n      }\n    }\n\n    return null;\n  } // Removes a Fiber (and its alternate) from the Maps used to track their id.\n  // This method should always be called when a Fiber is unmounting.\n\n\n  function untrackFiberID(fiber) {\n    if (__DEBUG__) {\n      debug('untrackFiberID()', fiber, fiber.return, 'schedule after delay');\n    } // Untrack Fibers after a slight delay in order to support a Fast Refresh edge case:\n    // 1. Component type is updated and Fast Refresh schedules an update+remount.\n    // 2. flushPendingErrorsAndWarningsAfterDelay() runs, sees the old Fiber is no longer mounted\n    //    (it's been disconnected by Fast Refresh), and calls untrackFiberID() to clear it from the Map.\n    // 3. React flushes pending passive effects before it runs the next render,\n    //    which logs an error or warning, which causes a new ID to be generated for this Fiber.\n    // 4. DevTools now tries to unmount the old Component with the new ID.\n    //\n    // The underlying problem here is the premature clearing of the Fiber ID,\n    // but DevTools has no way to detect that a given Fiber has been scheduled for Fast Refresh.\n    // (The \"_debugNeedsRemount\" flag won't necessarily be set.)\n    //\n    // The best we can do is to delay untracking by a small amount,\n    // and give React time to process the Fast Refresh delay.\n\n\n    untrackFibersSet.add(fiber); // React may detach alternate pointers during unmount;\n    // Since our untracking code is async, we should explicily track the pending alternate here as well.\n\n    var alternate = fiber.alternate;\n\n    if (alternate !== null) {\n      untrackFibersSet.add(alternate);\n    }\n\n    if (untrackFibersTimeoutID === null) {\n      untrackFibersTimeoutID = setTimeout(untrackFibers, 1000);\n    }\n  }\n\n  var untrackFibersSet = new Set();\n  var untrackFibersTimeoutID = null;\n\n  function untrackFibers() {\n    if (untrackFibersTimeoutID !== null) {\n      clearTimeout(untrackFibersTimeoutID);\n      untrackFibersTimeoutID = null;\n    }\n\n    untrackFibersSet.forEach(function (fiber) {\n      var fiberID = getFiberIDUnsafe(fiber);\n\n      if (fiberID !== null) {\n        idToArbitraryFiberMap.delete(fiberID); // Also clear any errors/warnings associated with this fiber.\n\n        clearErrorsForFiberID(fiberID);\n        clearWarningsForFiberID(fiberID);\n      }\n\n      fiberToIDMap.delete(fiber);\n      var alternate = fiber.alternate;\n\n      if (alternate !== null) {\n        fiberToIDMap.delete(alternate);\n      }\n\n      if (forceErrorForFiberIDs.has(fiberID)) {\n        forceErrorForFiberIDs.delete(fiberID);\n\n        if (forceErrorForFiberIDs.size === 0 && setErrorHandler != null) {\n          setErrorHandler(shouldErrorFiberAlwaysNull);\n        }\n      }\n    });\n    untrackFibersSet.clear();\n  }\n\n  function getChangeDescription(prevFiber, nextFiber) {\n    switch (getElementTypeForFiber(nextFiber)) {\n      case types_ElementTypeClass:\n      case types_ElementTypeFunction:\n      case types_ElementTypeMemo:\n      case types_ElementTypeForwardRef:\n        if (prevFiber === null) {\n          return {\n            context: null,\n            didHooksChange: false,\n            isFirstMount: true,\n            props: null,\n            state: null\n          };\n        } else {\n          var data = {\n            context: getContextChangedKeys(nextFiber),\n            didHooksChange: false,\n            isFirstMount: false,\n            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),\n            state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)\n          }; // Only traverse the hooks list once, depending on what info we're returning.\n\n          var indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);\n          data.hooks = indices;\n          data.didHooksChange = indices !== null && indices.length > 0;\n          return data;\n        }\n\n      default:\n        return null;\n    }\n  }\n\n  function updateContextsForFiber(fiber) {\n    switch (getElementTypeForFiber(fiber)) {\n      case types_ElementTypeClass:\n      case types_ElementTypeForwardRef:\n      case types_ElementTypeFunction:\n      case types_ElementTypeMemo:\n        if (idToContextsMap !== null) {\n          var id = getFiberIDThrows(fiber);\n          var contexts = getContextsForFiber(fiber);\n\n          if (contexts !== null) {\n            // $FlowFixMe[incompatible-use] found when upgrading Flow\n            idToContextsMap.set(id, contexts);\n          }\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  } // Differentiates between a null context value and no context.\n\n\n  var NO_CONTEXT = {};\n\n  function getContextsForFiber(fiber) {\n    var legacyContext = NO_CONTEXT;\n    var modernContext = NO_CONTEXT;\n\n    switch (getElementTypeForFiber(fiber)) {\n      case types_ElementTypeClass:\n        var instance = fiber.stateNode;\n\n        if (instance != null) {\n          if (instance.constructor && instance.constructor.contextType != null) {\n            modernContext = instance.context;\n          } else {\n            legacyContext = instance.context;\n\n            if (legacyContext && Object.keys(legacyContext).length === 0) {\n              legacyContext = NO_CONTEXT;\n            }\n          }\n        }\n\n        return [legacyContext, modernContext];\n\n      case types_ElementTypeForwardRef:\n      case types_ElementTypeFunction:\n      case types_ElementTypeMemo:\n        var dependencies = fiber.dependencies;\n\n        if (dependencies && dependencies.firstContext) {\n          modernContext = dependencies.firstContext;\n        }\n\n        return [legacyContext, modernContext];\n\n      default:\n        return null;\n    }\n  } // Record all contexts at the time profiling is started.\n  // Fibers only store the current context value,\n  // so we need to track them separately in order to determine changed keys.\n\n\n  function crawlToInitializeContextsMap(fiber) {\n    var id = getFiberIDUnsafe(fiber); // Not all Fibers in the subtree have mounted yet.\n    // For example, Offscreen (hidden) or Suspense (suspended) subtrees won't yet be tracked.\n    // We can safely skip these subtrees.\n\n    if (id !== null) {\n      updateContextsForFiber(fiber);\n      var current = fiber.child;\n\n      while (current !== null) {\n        crawlToInitializeContextsMap(current);\n        current = current.sibling;\n      }\n    }\n  }\n\n  function getContextChangedKeys(fiber) {\n    if (idToContextsMap !== null) {\n      var id = getFiberIDThrows(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      var prevContexts = idToContextsMap.has(id) ? // $FlowFixMe[incompatible-use] found when upgrading Flow\n      idToContextsMap.get(id) : null;\n      var nextContexts = getContextsForFiber(fiber);\n\n      if (prevContexts == null || nextContexts == null) {\n        return null;\n      }\n\n      var _prevContexts = renderer_slicedToArray(prevContexts, 2),\n          prevLegacyContext = _prevContexts[0],\n          prevModernContext = _prevContexts[1];\n\n      var _nextContexts = renderer_slicedToArray(nextContexts, 2),\n          nextLegacyContext = _nextContexts[0],\n          nextModernContext = _nextContexts[1];\n\n      switch (getElementTypeForFiber(fiber)) {\n        case types_ElementTypeClass:\n          if (prevContexts && nextContexts) {\n            if (nextLegacyContext !== NO_CONTEXT) {\n              return getChangedKeys(prevLegacyContext, nextLegacyContext);\n            } else if (nextModernContext !== NO_CONTEXT) {\n              return prevModernContext !== nextModernContext;\n            }\n          }\n\n          break;\n\n        case types_ElementTypeForwardRef:\n        case types_ElementTypeFunction:\n        case types_ElementTypeMemo:\n          if (nextModernContext !== NO_CONTEXT) {\n            var prevContext = prevModernContext;\n            var nextContext = nextModernContext;\n\n            while (prevContext && nextContext) {\n              // Note this only works for versions of React that support this key (e.v. 18+)\n              // For older versions, there's no good way to read the current context value after render has completed.\n              // This is because React maintains a stack of context values during render,\n              // but by the time DevTools is called, render has finished and the stack is empty.\n              if (!shared_objectIs(prevContext.memoizedValue, nextContext.memoizedValue)) {\n                return true;\n              }\n\n              prevContext = prevContext.next;\n              nextContext = nextContext.next;\n            }\n\n            return false;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return null;\n  }\n\n  function isHookThatCanScheduleUpdate(hookObject) {\n    var queue = hookObject.queue;\n\n    if (!queue) {\n      return false;\n    }\n\n    var boundHasOwnProperty = shared_hasOwnProperty.bind(queue); // Detect the shape of useState() / useReducer() / useTransition()\n    // using the attributes that are unique to these hooks\n    // but also stable (e.g. not tied to current Lanes implementation)\n    // We don't check for dispatch property, because useTransition doesn't have it\n\n    if (boundHasOwnProperty('pending')) {\n      return true;\n    } // Detect useSyncExternalStore()\n\n\n    return boundHasOwnProperty('value') && boundHasOwnProperty('getSnapshot') && typeof queue.getSnapshot === 'function';\n  }\n\n  function didStatefulHookChange(prev, next) {\n    var prevMemoizedState = prev.memoizedState;\n    var nextMemoizedState = next.memoizedState;\n\n    if (isHookThatCanScheduleUpdate(prev)) {\n      return prevMemoizedState !== nextMemoizedState;\n    }\n\n    return false;\n  }\n\n  function getChangedHooksIndices(prev, next) {\n    if (prev == null || next == null) {\n      return null;\n    }\n\n    var indices = [];\n    var index = 0;\n\n    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n      while (next !== null) {\n        if (didStatefulHookChange(prev, next)) {\n          indices.push(index);\n        }\n\n        next = next.next;\n        prev = prev.next;\n        index++;\n      }\n    }\n\n    return indices;\n  }\n\n  function getChangedKeys(prev, next) {\n    if (prev == null || next == null) {\n      return null;\n    } // We can't report anything meaningful for hooks changes.\n\n\n    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n      return null;\n    }\n\n    var keys = new Set([].concat(renderer_toConsumableArray(Object.keys(prev)), renderer_toConsumableArray(Object.keys(next))));\n    var changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n    var _iterator5 = _createForOfIteratorHelper(keys),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var key = _step5.value;\n\n        if (prev[key] !== next[key]) {\n          changedKeys.push(key);\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    return changedKeys;\n  } // eslint-disable-next-line no-unused-vars\n\n\n  function didFiberRender(prevFiber, nextFiber) {\n    switch (nextFiber.tag) {\n      case ClassComponent:\n      case FunctionComponent:\n      case ContextConsumer:\n      case MemoComponent:\n      case SimpleMemoComponent:\n      case ForwardRef:\n        // For types that execute user code, we check PerformedWork effect.\n        // We don't reflect bailouts (either referential or sCU) in DevTools.\n        // TODO: This flag is a leaked implementation detail. Once we start\n        // releasing DevTools in lockstep with React, we should import a\n        // function from the reconciler instead.\n        var PerformedWork = 1;\n        return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;\n      // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+\n      // so it won't get highlighted with React 16.3.0 to 16.3.2.\n\n      default:\n        // For host components and other types, we compare inputs\n        // to determine whether something is an update.\n        return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;\n    }\n  }\n\n  var pendingOperations = [];\n  var pendingRealUnmountedIDs = [];\n  var pendingSimulatedUnmountedIDs = [];\n  var pendingOperationsQueue = [];\n  var pendingStringTable = new Map();\n  var pendingStringTableLength = 0;\n  var pendingUnmountedRootID = null;\n\n  function pushOperation(op) {\n    if (false) {}\n\n    pendingOperations.push(op);\n  }\n\n  function shouldBailoutWithPendingOperations() {\n    if (isProfiling) {\n      if (currentCommitProfilingMetadata != null && currentCommitProfilingMetadata.durations.length > 0) {\n        return false;\n      }\n    }\n\n    return pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null;\n  }\n\n  function flushOrQueueOperations(operations) {\n    if (shouldBailoutWithPendingOperations()) {\n      return;\n    }\n\n    if (pendingOperationsQueue !== null) {\n      pendingOperationsQueue.push(operations);\n    } else {\n      hook.emit('operations', operations);\n    }\n  }\n\n  var flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n\n  function clearPendingErrorsAndWarningsAfterDelay() {\n    if (flushPendingErrorsAndWarningsAfterDelayTimeoutID !== null) {\n      clearTimeout(flushPendingErrorsAndWarningsAfterDelayTimeoutID);\n      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n    }\n  }\n\n  function flushPendingErrorsAndWarningsAfterDelay() {\n    clearPendingErrorsAndWarningsAfterDelay();\n    flushPendingErrorsAndWarningsAfterDelayTimeoutID = setTimeout(function () {\n      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n\n      if (pendingOperations.length > 0) {\n        // On the off chance that something else has pushed pending operations,\n        // we should bail on warnings; it's probably not safe to push midway.\n        return;\n      }\n\n      recordPendingErrorsAndWarnings();\n\n      if (shouldBailoutWithPendingOperations()) {\n        // No warnings or errors to flush; we can bail out early here too.\n        return;\n      } // We can create a smaller operations array than flushPendingEvents()\n      // because we only need to flush warning and error counts.\n      // Only a few pieces of fixed information are required up front.\n\n\n      var operations = new Array(3 + pendingOperations.length);\n      operations[0] = rendererID;\n      operations[1] = currentRootID;\n      operations[2] = 0; // String table size\n\n      for (var j = 0; j < pendingOperations.length; j++) {\n        operations[3 + j] = pendingOperations[j];\n      }\n\n      flushOrQueueOperations(operations);\n      pendingOperations.length = 0;\n    }, 1000);\n  }\n\n  function reevaluateErrorsAndWarnings() {\n    fibersWithChangedErrorOrWarningCounts.clear();\n    fiberIDToErrorsMap.forEach(function (countMap, fiberID) {\n      var fiber = idToArbitraryFiberMap.get(fiberID);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n      }\n    });\n    fiberIDToWarningsMap.forEach(function (countMap, fiberID) {\n      var fiber = idToArbitraryFiberMap.get(fiberID);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n      }\n    });\n    recordPendingErrorsAndWarnings();\n  }\n\n  function mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {\n    var newCount = 0;\n    var messageCountMap = fiberIDToMessageCountMap.get(fiberID);\n    var pendingMessageCountMap = pendingFiberToMessageCountMap.get(fiber);\n\n    if (pendingMessageCountMap != null) {\n      if (messageCountMap == null) {\n        messageCountMap = pendingMessageCountMap;\n        fiberIDToMessageCountMap.set(fiberID, pendingMessageCountMap);\n      } else {\n        // This Flow refinement should not be necessary and yet...\n        var refinedMessageCountMap = messageCountMap;\n        pendingMessageCountMap.forEach(function (pendingCount, message) {\n          var previousCount = refinedMessageCountMap.get(message) || 0;\n          refinedMessageCountMap.set(message, previousCount + pendingCount);\n        });\n      }\n    }\n\n    if (!shouldFilterFiber(fiber)) {\n      if (messageCountMap != null) {\n        messageCountMap.forEach(function (count) {\n          newCount += count;\n        });\n      }\n    }\n\n    pendingFiberToMessageCountMap.delete(fiber);\n    return newCount;\n  }\n\n  function recordPendingErrorsAndWarnings() {\n    clearPendingErrorsAndWarningsAfterDelay();\n    fibersWithChangedErrorOrWarningCounts.forEach(function (fiber) {\n      var fiberID = getFiberIDUnsafe(fiber);\n\n      if (fiberID === null) {// Don't send updates for Fibers that didn't mount due to e.g. Suspense or an error boundary.\n      } else {\n        var errorCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);\n        var warningCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);\n        pushOperation(TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS);\n        pushOperation(fiberID);\n        pushOperation(errorCount);\n        pushOperation(warningCount);\n      } // Always clean up so that we don't leak.\n\n\n      pendingFiberToErrorsMap.delete(fiber);\n      pendingFiberToWarningsMap.delete(fiber);\n    });\n    fibersWithChangedErrorOrWarningCounts.clear();\n  }\n\n  function flushPendingEvents(root) {\n    // Add any pending errors and warnings to the operations array.\n    // We do this just before flushing, so we can ignore errors for no-longer-mounted Fibers.\n    recordPendingErrorsAndWarnings();\n\n    if (shouldBailoutWithPendingOperations()) {\n      // If we aren't profiling, we can just bail out here.\n      // No use sending an empty update over the bridge.\n      //\n      // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:\n      // (1) an initial tree snapshot and\n      // (2) the operations array for each commit\n      // Because of this, it's important that the operations and metadata arrays align,\n      // So it's important not to omit even empty operations while profiling is active.\n      return;\n    }\n\n    var numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n    var operations = new Array( // Identify which renderer this update is coming from.\n    2 + // [rendererID, rootFiberID]\n    // How big is the string table?\n    1 + // [stringTableLength]\n    // Then goes the actual string table.\n    pendingStringTableLength + ( // All unmounts are batched in a single message.\n    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations\n    pendingOperations.length); // Identify which renderer this update is coming from.\n    // This enables roots to be mapped to renderers,\n    // Which in turn enables fiber props, states, and hooks to be inspected.\n\n    var i = 0;\n    operations[i++] = rendererID;\n    operations[i++] = currentRootID; // Now fill in the string table.\n    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n    operations[i++] = pendingStringTableLength;\n    pendingStringTable.forEach(function (entry, stringKey) {\n      var encodedString = entry.encodedString; // Don't use the string length.\n      // It won't work for multibyte characters (like emoji).\n\n      var length = encodedString.length;\n      operations[i++] = length;\n\n      for (var j = 0; j < length; j++) {\n        operations[i + j] = encodedString[j];\n      }\n\n      i += length;\n    });\n\n    if (numUnmountIDs > 0) {\n      // All unmounts except roots are batched in a single message.\n      operations[i++] = TREE_OPERATION_REMOVE; // The first number is how many unmounted IDs we're gonna send.\n\n      operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.\n      // They were inserted parents-first by React, but we want children-first.\n      // So we traverse our array backwards.\n\n      for (var j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {\n        operations[i++] = pendingRealUnmountedIDs[j];\n      } // Fill in the simulated unmounts (hidden Suspense subtrees) in their order.\n      // (We want children to go before parents.)\n      // They go *after* the real unmounts because we know for sure they won't be\n      // children of already pushed \"real\" IDs. If they were, we wouldn't be able\n      // to discover them during the traversal, as they would have been deleted.\n\n\n      for (var _j = 0; _j < pendingSimulatedUnmountedIDs.length; _j++) {\n        operations[i + _j] = pendingSimulatedUnmountedIDs[_j];\n      }\n\n      i += pendingSimulatedUnmountedIDs.length; // The root ID should always be unmounted last.\n\n      if (pendingUnmountedRootID !== null) {\n        operations[i] = pendingUnmountedRootID;\n        i++;\n      }\n    } // Fill in the rest of the operations.\n\n\n    for (var _j2 = 0; _j2 < pendingOperations.length; _j2++) {\n      operations[i + _j2] = pendingOperations[_j2];\n    }\n\n    i += pendingOperations.length; // Let the frontend know about tree operations.\n\n    flushOrQueueOperations(operations); // Reset all of the pending state now that we've told the frontend about it.\n\n    pendingOperations.length = 0;\n    pendingRealUnmountedIDs.length = 0;\n    pendingSimulatedUnmountedIDs.length = 0;\n    pendingUnmountedRootID = null;\n    pendingStringTable.clear();\n    pendingStringTableLength = 0;\n  }\n\n  function getStringID(string) {\n    if (string === null) {\n      return 0;\n    }\n\n    var existingEntry = pendingStringTable.get(string);\n\n    if (existingEntry !== undefined) {\n      return existingEntry.id;\n    }\n\n    var id = pendingStringTable.size + 1;\n    var encodedString = utfEncodeString(string);\n    pendingStringTable.set(string, {\n      encodedString: encodedString,\n      id: id\n    }); // The string table total length needs to account both for the string length,\n    // and for the array item that contains the length itself.\n    //\n    // Don't use string length for this table.\n    // It won't work for multibyte characters (like emoji).\n\n    pendingStringTableLength += encodedString.length + 1;\n    return id;\n  }\n\n  function recordMount(fiber, parentFiber) {\n    var isRoot = fiber.tag === HostRoot;\n    var id = getOrGenerateFiberID(fiber);\n\n    if (__DEBUG__) {\n      debug('recordMount()', fiber, parentFiber);\n    }\n\n    var hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner');\n    var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration'); // Adding a new field here would require a bridge protocol version bump (a backwads breaking change).\n    // Instead let's re-purpose a pre-existing field to carry more information.\n\n    var profilingFlags = 0;\n\n    if (isProfilingSupported) {\n      profilingFlags = PROFILING_FLAG_BASIC_SUPPORT;\n\n      if (typeof injectProfilingHooks === 'function') {\n        profilingFlags |= PROFILING_FLAG_TIMELINE_SUPPORT;\n      }\n    }\n\n    if (isRoot) {\n      pushOperation(TREE_OPERATION_ADD);\n      pushOperation(id);\n      pushOperation(ElementTypeRoot);\n      pushOperation((fiber.mode & StrictModeBits) !== 0 ? 1 : 0);\n      pushOperation(profilingFlags);\n      pushOperation(StrictModeBits !== 0 ? 1 : 0);\n      pushOperation(hasOwnerMetadata ? 1 : 0);\n\n      if (isProfiling) {\n        if (displayNamesByRootID !== null) {\n          displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));\n        }\n      }\n    } else {\n      var key = fiber.key;\n      var displayName = getDisplayNameForFiber(fiber);\n      var elementType = getElementTypeForFiber(fiber);\n      var _debugOwner = fiber._debugOwner; // Ideally we should call getFiberIDThrows() for _debugOwner,\n      // since owners are almost always higher in the tree (and so have already been processed),\n      // but in some (rare) instances reported in open source, a descendant mounts before an owner.\n      // Since this is a DEV only field it's probably okay to also just lazily generate and ID here if needed.\n      // See https://github.com/facebook/react/issues/21445\n\n      var ownerID = _debugOwner != null ? getOrGenerateFiberID(_debugOwner) : 0;\n      var parentID = parentFiber ? getFiberIDThrows(parentFiber) : 0;\n      var displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified\n      // in such a way as to bypass the default stringification of the \"key\" property.\n\n      var keyString = key === null ? null : String(key);\n      var keyStringID = getStringID(keyString);\n      pushOperation(TREE_OPERATION_ADD);\n      pushOperation(id);\n      pushOperation(elementType);\n      pushOperation(parentID);\n      pushOperation(ownerID);\n      pushOperation(displayNameStringID);\n      pushOperation(keyStringID); // If this subtree has a new mode, let the frontend know.\n\n      if ((fiber.mode & StrictModeBits) !== 0 && (parentFiber.mode & StrictModeBits) === 0) {\n        pushOperation(TREE_OPERATION_SET_SUBTREE_MODE);\n        pushOperation(id);\n        pushOperation(StrictMode);\n      }\n    }\n\n    if (isProfilingSupported) {\n      idToRootMap.set(id, currentRootID);\n      recordProfilingDurations(fiber);\n    }\n  }\n\n  function recordUnmount(fiber, isSimulated) {\n    if (__DEBUG__) {\n      debug('recordUnmount()', fiber, null, isSimulated ? 'unmount is simulated' : '');\n    }\n\n    if (trackedPathMatchFiber !== null) {\n      // We're in the process of trying to restore previous selection.\n      // If this fiber matched but is being unmounted, there's no use trying.\n      // Reset the state so we don't keep holding onto it.\n      if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {\n        setTrackedPath(null);\n      }\n    }\n\n    var unsafeID = getFiberIDUnsafe(fiber);\n\n    if (unsafeID === null) {\n      // If we've never seen this Fiber, it might be inside of a legacy render Suspense fragment (so the store is not even aware of it).\n      // In that case we can just ignore it or it will cause errors later on.\n      // One example of this is a Lazy component that never resolves before being unmounted.\n      //\n      // This also might indicate a Fast Refresh force-remount scenario.\n      //\n      // TODO: This is fragile and can obscure actual bugs.\n      return;\n    } // Flow refinement.\n\n\n    var id = unsafeID;\n    var isRoot = fiber.tag === HostRoot;\n\n    if (isRoot) {\n      // Roots must be removed only after all children (pending and simulated) have been removed.\n      // So we track it separately.\n      pendingUnmountedRootID = id;\n    } else if (!shouldFilterFiber(fiber)) {\n      // To maintain child-first ordering,\n      // we'll push it into one of these queues,\n      // and later arrange them in the correct order.\n      if (isSimulated) {\n        pendingSimulatedUnmountedIDs.push(id);\n      } else {\n        pendingRealUnmountedIDs.push(id);\n      }\n    }\n\n    if (!fiber._debugNeedsRemount) {\n      untrackFiberID(fiber);\n      var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');\n\n      if (isProfilingSupported) {\n        idToRootMap.delete(id);\n        idToTreeBaseDurationMap.delete(id);\n      }\n    }\n  }\n\n  function mountFiberRecursively(firstChild, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {\n    // Iterate over siblings rather than recursing.\n    // This reduces the chance of stack overflow for wide trees (e.g. lists with many items).\n    var fiber = firstChild;\n\n    while (fiber !== null) {\n      // Generate an ID even for filtered Fibers, in case it's needed later (e.g. for Profiling).\n      getOrGenerateFiberID(fiber);\n\n      if (__DEBUG__) {\n        debug('mountFiberRecursively()', fiber, parentFiber);\n      } // If we have the tree selection from previous reload, try to match this Fiber.\n      // Also remember whether to do the same for siblings.\n\n\n      var mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);\n      var shouldIncludeInTree = !shouldFilterFiber(fiber);\n\n      if (shouldIncludeInTree) {\n        recordMount(fiber, parentFiber);\n      }\n\n      if (traceUpdatesEnabled) {\n        if (traceNearestHostComponentUpdate) {\n          var elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n\n          if (elementType === ElementTypeHostComponent) {\n            traceUpdatesForNodes.add(fiber.stateNode);\n            traceNearestHostComponentUpdate = false;\n          }\n        } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,\n        // because we don't want to highlight every host node inside of a newly mounted subtree.\n\n      }\n\n      var isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;\n\n      if (isSuspense) {\n        var isTimedOut = fiber.memoizedState !== null;\n\n        if (isTimedOut) {\n          // Special case: if Suspense mounts in a timed-out state,\n          // get the fallback child from the inner fragment and mount\n          // it as if it was our own child. Updates handle this too.\n          var primaryChildFragment = fiber.child;\n          var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n          var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;\n\n          if (fallbackChild !== null) {\n            mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n          }\n        } else {\n          var primaryChild = null;\n          var areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;\n\n          if (areSuspenseChildrenConditionallyWrapped) {\n            primaryChild = fiber.child;\n          } else if (fiber.child !== null) {\n            primaryChild = fiber.child.child;\n          }\n\n          if (primaryChild !== null) {\n            mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n          }\n        }\n      } else {\n        if (fiber.child !== null) {\n          mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n        }\n      } // We're exiting this Fiber now, and entering its siblings.\n      // If we have selection to restore, we might need to re-activate tracking.\n\n\n      updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);\n      fiber = traverseSiblings ? fiber.sibling : null;\n    }\n  } // We use this to simulate unmounting for Suspense trees\n  // when we switch from primary to fallback.\n\n\n  function unmountFiberChildrenRecursively(fiber) {\n    if (__DEBUG__) {\n      debug('unmountFiberChildrenRecursively()', fiber);\n    } // We might meet a nested Suspense on our way.\n\n\n    var isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;\n    var child = fiber.child;\n\n    if (isTimedOutSuspense) {\n      // If it's showing fallback tree, let's traverse it instead.\n      var primaryChildFragment = fiber.child;\n      var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null; // Skip over to the real Fiber child.\n\n      child = fallbackChildFragment ? fallbackChildFragment.child : null;\n    }\n\n    while (child !== null) {\n      // Record simulated unmounts children-first.\n      // We skip nodes without return because those are real unmounts.\n      if (child.return !== null) {\n        unmountFiberChildrenRecursively(child);\n        recordUnmount(child, true);\n      }\n\n      child = child.sibling;\n    }\n  }\n\n  function recordProfilingDurations(fiber) {\n    var id = getFiberIDThrows(fiber);\n    var actualDuration = fiber.actualDuration,\n        treeBaseDuration = fiber.treeBaseDuration;\n    idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);\n\n    if (isProfiling) {\n      var alternate = fiber.alternate; // It's important to update treeBaseDuration even if the current Fiber did not render,\n      // because it's possible that one of its descendants did.\n\n      if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {\n        // Tree base duration updates are included in the operations typed array.\n        // So we have to convert them from milliseconds to microseconds so we can send them as ints.\n        var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);\n        pushOperation(TREE_OPERATION_UPDATE_TREE_BASE_DURATION);\n        pushOperation(id);\n        pushOperation(convertedTreeBaseDuration);\n      }\n\n      if (alternate == null || didFiberRender(alternate, fiber)) {\n        if (actualDuration != null) {\n          // The actual duration reported by React includes time spent working on children.\n          // This is useful information, but it's also useful to be able to exclude child durations.\n          // The frontend can't compute this, since the immediate children may have been filtered out.\n          // So we need to do this on the backend.\n          // Note that this calculated self duration is not the same thing as the base duration.\n          // The two are calculated differently (tree duration does not accumulate).\n          var selfDuration = actualDuration;\n          var child = fiber.child;\n\n          while (child !== null) {\n            selfDuration -= child.actualDuration || 0;\n            child = child.sibling;\n          } // If profiling is active, store durations for elements that were rendered during the commit.\n          // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.\n          // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)\n          // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we \"bailed out\".\n\n\n          var metadata = currentCommitProfilingMetadata;\n          metadata.durations.push(id, actualDuration, selfDuration);\n          metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);\n\n          if (recordChangeDescriptions) {\n            var changeDescription = getChangeDescription(alternate, fiber);\n\n            if (changeDescription !== null) {\n              if (metadata.changeDescriptions !== null) {\n                metadata.changeDescriptions.set(id, changeDescription);\n              }\n            }\n\n            updateContextsForFiber(fiber);\n          }\n        }\n      }\n    }\n  }\n\n  function recordResetChildren(fiber, childSet) {\n    if (__DEBUG__) {\n      debug('recordResetChildren()', childSet, fiber);\n    } // The frontend only really cares about the displayName, key, and children.\n    // The first two don't really change, so we are only concerned with the order of children here.\n    // This is trickier than a simple comparison though, since certain types of fibers are filtered.\n\n\n    var nextChildren = []; // This is a naive implementation that shallowly recourses children.\n    // We might want to revisit this if it proves to be too inefficient.\n\n    var child = childSet;\n\n    while (child !== null) {\n      findReorderedChildrenRecursively(child, nextChildren);\n      child = child.sibling;\n    }\n\n    var numChildren = nextChildren.length;\n\n    if (numChildren < 2) {\n      // No need to reorder.\n      return;\n    }\n\n    pushOperation(TREE_OPERATION_REORDER_CHILDREN);\n    pushOperation(getFiberIDThrows(fiber));\n    pushOperation(numChildren);\n\n    for (var i = 0; i < nextChildren.length; i++) {\n      pushOperation(nextChildren[i]);\n    }\n  }\n\n  function findReorderedChildrenRecursively(fiber, nextChildren) {\n    if (!shouldFilterFiber(fiber)) {\n      nextChildren.push(getFiberIDThrows(fiber));\n    } else {\n      var child = fiber.child;\n      var isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n\n      if (isTimedOutSuspense) {\n        // Special case: if Suspense mounts in a timed-out state,\n        // get the fallback child from the inner fragment,\n        // and skip over the primary child.\n        var primaryChildFragment = fiber.child;\n        var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n        var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;\n\n        if (fallbackChild !== null) {\n          child = fallbackChild;\n        }\n      }\n\n      while (child !== null) {\n        findReorderedChildrenRecursively(child, nextChildren);\n        child = child.sibling;\n      }\n    }\n  } // Returns whether closest unfiltered fiber parent needs to reset its child list.\n\n\n  function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {\n    var id = getOrGenerateFiberID(nextFiber);\n\n    if (__DEBUG__) {\n      debug('updateFiberRecursively()', nextFiber, parentFiber);\n    }\n\n    if (traceUpdatesEnabled) {\n      var elementType = getElementTypeForFiber(nextFiber);\n\n      if (traceNearestHostComponentUpdate) {\n        // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n        if (elementType === ElementTypeHostComponent) {\n          traceUpdatesForNodes.add(nextFiber.stateNode);\n          traceNearestHostComponentUpdate = false;\n        }\n      } else {\n        if (elementType === types_ElementTypeFunction || elementType === types_ElementTypeClass || elementType === ElementTypeContext || elementType === types_ElementTypeMemo || elementType === types_ElementTypeForwardRef) {\n          // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).\n          traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);\n        }\n      }\n    }\n\n    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && didFiberRender(prevFiber, nextFiber)) {\n      // If this Fiber has updated, clear cached inspected data.\n      // If it is inspected again, it may need to be re-run to obtain updated hooks values.\n      hasElementUpdatedSinceLastInspected = true;\n    }\n\n    var shouldIncludeInTree = !shouldFilterFiber(nextFiber);\n    var isSuspense = nextFiber.tag === SuspenseComponent;\n    var shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.\n    // Rather than unmount the timed out content (and possibly lose important state),\n    // React re-parents this content within a hidden Fragment while the fallback is showing.\n    // This behavior doesn't need to be observable in the DevTools though.\n    // It might even result in a bad user experience for e.g. node selection in the Elements panel.\n    // The easiest fix is to strip out the intermediate Fragment fibers,\n    // so the Elements panel and Profiler don't need to special case them.\n    // Suspense components only have a non-null memoizedState if they're timed-out.\n\n    var prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;\n    var nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()\n    // inside ReactFiberBeginWork in the React source code.\n\n    if (prevDidTimeout && nextDidTimeOut) {\n      // Fallback -> Fallback:\n      // 1. Reconcile fallback set.\n      var nextFiberChild = nextFiber.child;\n      var nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate\n      // because the set is special and alternate may not exist.\n\n      var prevFiberChild = prevFiber.child;\n      var prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;\n\n      if (prevFallbackChildSet == null && nextFallbackChildSet != null) {\n        mountFiberRecursively(nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);\n        shouldResetChildren = true;\n      }\n\n      if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {\n        shouldResetChildren = true;\n      }\n    } else if (prevDidTimeout && !nextDidTimeOut) {\n      // Fallback -> Primary:\n      // 1. Unmount fallback set\n      // Note: don't emulate fallback unmount because React actually did it.\n      // 2. Mount primary set\n      var nextPrimaryChildSet = nextFiber.child;\n\n      if (nextPrimaryChildSet !== null) {\n        mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);\n      }\n\n      shouldResetChildren = true;\n    } else if (!prevDidTimeout && nextDidTimeOut) {\n      // Primary -> Fallback:\n      // 1. Hide primary set\n      // This is not a real unmount, so it won't get reported by React.\n      // We need to manually walk the previous tree and record unmounts.\n      unmountFiberChildrenRecursively(prevFiber); // 2. Mount fallback set\n\n      var _nextFiberChild = nextFiber.child;\n\n      var _nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : null;\n\n      if (_nextFallbackChildSet != null) {\n        mountFiberRecursively(_nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);\n        shouldResetChildren = true;\n      }\n    } else {\n      // Common case: Primary -> Primary.\n      // This is the same code path as for non-Suspense fibers.\n      if (nextFiber.child !== prevFiber.child) {\n        // If the first child is different, we need to traverse them.\n        // Each next child will be either a new child (mount) or an alternate (update).\n        var nextChild = nextFiber.child;\n        var prevChildAtSameIndex = prevFiber.child;\n\n        while (nextChild) {\n          // We already know children will be referentially different because\n          // they are either new mounts or alternates of previous children.\n          // Schedule updates and mounts depending on whether alternates exist.\n          // We don't track deletions here because they are reported separately.\n          if (nextChild.alternate) {\n            var prevChild = nextChild.alternate;\n\n            if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {\n              // If a nested tree child order changed but it can't handle its own\n              // child order invalidation (e.g. because it's filtered out like host nodes),\n              // propagate the need to reset child order upwards to this Fiber.\n              shouldResetChildren = true;\n            } // However we also keep track if the order of the children matches\n            // the previous order. They are always different referentially, but\n            // if the instances line up conceptually we'll want to know that.\n\n\n            if (prevChild !== prevChildAtSameIndex) {\n              shouldResetChildren = true;\n            }\n          } else {\n            mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);\n            shouldResetChildren = true;\n          } // Try the next child.\n\n\n          nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can\n          // keep comparing if they line up.\n\n          if (!shouldResetChildren && prevChildAtSameIndex !== null) {\n            prevChildAtSameIndex = prevChildAtSameIndex.sibling;\n          }\n        } // If we have no more children, but used to, they don't line up.\n\n\n        if (prevChildAtSameIndex !== null) {\n          shouldResetChildren = true;\n        }\n      } else {\n        if (traceUpdatesEnabled) {\n          // If we're tracing updates and we've bailed out before reaching a host node,\n          // we should fall back to recursively marking the nearest host descendants for highlight.\n          if (traceNearestHostComponentUpdate) {\n            var hostFibers = findAllCurrentHostFibers(getFiberIDThrows(nextFiber));\n            hostFibers.forEach(function (hostFiber) {\n              traceUpdatesForNodes.add(hostFiber.stateNode);\n            });\n          }\n        }\n      }\n    }\n\n    if (shouldIncludeInTree) {\n      var isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');\n\n      if (isProfilingSupported) {\n        recordProfilingDurations(nextFiber);\n      }\n    }\n\n    if (shouldResetChildren) {\n      // We need to crawl the subtree for closest non-filtered Fibers\n      // so that we can display them in a flat children set.\n      if (shouldIncludeInTree) {\n        // Normally, search for children from the rendered child.\n        var nextChildSet = nextFiber.child;\n\n        if (nextDidTimeOut) {\n          // Special case: timed-out Suspense renders the fallback set.\n          var _nextFiberChild2 = nextFiber.child;\n          nextChildSet = _nextFiberChild2 ? _nextFiberChild2.sibling : null;\n        }\n\n        if (nextChildSet != null) {\n          recordResetChildren(nextFiber, nextChildSet);\n        } // We've handled the child order change for this Fiber.\n        // Since it's included, there's no need to invalidate parent child order.\n\n\n        return false;\n      } else {\n        // Let the closest unfiltered parent Fiber reset its child order instead.\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  function cleanup() {// We don't patch any methods so there is no cleanup.\n  }\n\n  function rootSupportsProfiling(root) {\n    if (root.memoizedInteractions != null) {\n      // v16 builds include this field for the scheduler/tracing API.\n      return true;\n    } else if (root.current != null && root.current.hasOwnProperty('treeBaseDuration')) {\n      // The scheduler/tracing API was removed in v17 though\n      // so we need to check a non-root Fiber.\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function flushInitialOperations() {\n    var localPendingOperationsQueue = pendingOperationsQueue;\n    pendingOperationsQueue = null;\n\n    if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {\n      // We may have already queued up some operations before the frontend connected\n      // If so, let the frontend know about them.\n      localPendingOperationsQueue.forEach(function (operations) {\n        hook.emit('operations', operations);\n      });\n    } else {\n      // Before the traversals, remember to start tracking\n      // our path in case we have selection to restore.\n      if (trackedPath !== null) {\n        mightBeOnTrackedPath = true;\n      } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.\n\n\n      hook.getFiberRoots(rendererID).forEach(function (root) {\n        currentRootID = getOrGenerateFiberID(root.current);\n        setRootPseudoKey(currentRootID, root.current); // Handle multi-renderer edge-case where only some v16 renderers support profiling.\n\n        if (isProfiling && rootSupportsProfiling(root)) {\n          // If profiling is active, store commit time and duration.\n          // The frontend may request this information after profiling has stopped.\n          currentCommitProfilingMetadata = {\n            changeDescriptions: recordChangeDescriptions ? new Map() : null,\n            durations: [],\n            commitTime: renderer_getCurrentTime() - profilingStartTime,\n            maxActualDuration: 0,\n            priorityLevel: null,\n            updaters: getUpdatersList(root),\n            effectDuration: null,\n            passiveEffectDuration: null\n          };\n        }\n\n        mountFiberRecursively(root.current, null, false, false);\n        flushPendingEvents(root);\n        currentRootID = -1;\n      });\n    }\n  }\n\n  function getUpdatersList(root) {\n    return root.memoizedUpdaters != null ? Array.from(root.memoizedUpdaters).filter(function (fiber) {\n      return getFiberIDUnsafe(fiber) !== null;\n    }).map(fiberToSerializedElement) : null;\n  }\n\n  function handleCommitFiberUnmount(fiber) {\n    // If the untrackFiberSet already has the unmounted Fiber, this means we've already\n    // recordedUnmount, so we don't need to do it again. If we don't do this, we might\n    // end up double-deleting Fibers in some cases (like Legacy Suspense).\n    if (!untrackFibersSet.has(fiber)) {\n      // This is not recursive.\n      // We can't traverse fibers after unmounting so instead\n      // we rely on React telling us about each unmount.\n      recordUnmount(fiber, false);\n    }\n  }\n\n  function handlePostCommitFiberRoot(root) {\n    if (isProfiling && rootSupportsProfiling(root)) {\n      if (currentCommitProfilingMetadata !== null) {\n        var _getEffectDurations = getEffectDurations(root),\n            effectDuration = _getEffectDurations.effectDuration,\n            passiveEffectDuration = _getEffectDurations.passiveEffectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentCommitProfilingMetadata.effectDuration = effectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n        currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;\n      }\n    }\n  }\n\n  function handleCommitFiberRoot(root, priorityLevel) {\n    var current = root.current;\n    var alternate = current.alternate; // Flush any pending Fibers that we are untracking before processing the new commit.\n    // If we don't do this, we might end up double-deleting Fibers in some cases (like Legacy Suspense).\n\n    untrackFibers();\n    currentRootID = getOrGenerateFiberID(current); // Before the traversals, remember to start tracking\n    // our path in case we have selection to restore.\n\n    if (trackedPath !== null) {\n      mightBeOnTrackedPath = true;\n    }\n\n    if (traceUpdatesEnabled) {\n      traceUpdatesForNodes.clear();\n    } // Handle multi-renderer edge-case where only some v16 renderers support profiling.\n\n\n    var isProfilingSupported = rootSupportsProfiling(root);\n\n    if (isProfiling && isProfilingSupported) {\n      // If profiling is active, store commit time and duration.\n      // The frontend may request this information after profiling has stopped.\n      currentCommitProfilingMetadata = {\n        changeDescriptions: recordChangeDescriptions ? new Map() : null,\n        durations: [],\n        commitTime: renderer_getCurrentTime() - profilingStartTime,\n        maxActualDuration: 0,\n        priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),\n        updaters: getUpdatersList(root),\n        // Initialize to null; if new enough React version is running,\n        // these values will be read during separate handlePostCommitFiberRoot() call.\n        effectDuration: null,\n        passiveEffectDuration: null\n      };\n    }\n\n    if (alternate) {\n      // TODO: relying on this seems a bit fishy.\n      var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && // A dehydrated root is not considered mounted\n      alternate.memoizedState.isDehydrated !== true;\n      var isMounted = current.memoizedState != null && current.memoizedState.element != null && // A dehydrated root is not considered mounted\n      current.memoizedState.isDehydrated !== true;\n\n      if (!wasMounted && isMounted) {\n        // Mount a new root.\n        setRootPseudoKey(currentRootID, current);\n        mountFiberRecursively(current, null, false, false);\n      } else if (wasMounted && isMounted) {\n        // Update an existing root.\n        updateFiberRecursively(current, alternate, null, false);\n      } else if (wasMounted && !isMounted) {\n        // Unmount an existing root.\n        removeRootPseudoKey(currentRootID);\n        recordUnmount(current, false);\n      }\n    } else {\n      // Mount a new root.\n      setRootPseudoKey(currentRootID, current);\n      mountFiberRecursively(current, null, false, false);\n    }\n\n    if (isProfiling && isProfilingSupported) {\n      if (!shouldBailoutWithPendingOperations()) {\n        var commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);\n\n        if (commitProfilingMetadata != null) {\n          commitProfilingMetadata.push(currentCommitProfilingMetadata);\n        } else {\n          rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);\n        }\n      }\n    } // We're done here.\n\n\n    flushPendingEvents(root);\n\n    if (traceUpdatesEnabled) {\n      hook.emit('traceUpdates', traceUpdatesForNodes);\n    }\n\n    currentRootID = -1;\n  }\n\n  function findAllCurrentHostFibers(id) {\n    var fibers = [];\n    var fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (!fiber) {\n      return fibers;\n    } // Next we'll drill down this component to find all HostComponent/Text.\n\n\n    var node = fiber;\n\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        fibers.push(node);\n      } else if (node.child) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return fibers;\n      }\n\n      while (!node.sibling) {\n        if (!node.return || node.return === fiber) {\n          return fibers;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    } // Flow needs the return here, but ESLint complains about it.\n    // eslint-disable-next-line no-unreachable\n\n\n    return fibers;\n  }\n\n  function findNativeNodesForFiberID(id) {\n    try {\n      var _fiber3 = findCurrentFiberUsingSlowPathById(id);\n\n      if (_fiber3 === null) {\n        return null;\n      }\n\n      var hostFibers = findAllCurrentHostFibers(id);\n      return hostFibers.map(function (hostFiber) {\n        return hostFiber.stateNode;\n      }).filter(Boolean);\n    } catch (err) {\n      // The fiber might have unmounted by now.\n      return null;\n    }\n  }\n\n  function getDisplayNameForFiberID(id) {\n    var fiber = idToArbitraryFiberMap.get(id);\n    return fiber != null ? getDisplayNameForFiber(fiber) : null;\n  }\n\n  function getFiberForNative(hostInstance) {\n    return renderer.findFiberByHostInstance(hostInstance);\n  }\n\n  function getFiberIDForNative(hostInstance) {\n    var findNearestUnfilteredAncestor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var fiber = renderer.findFiberByHostInstance(hostInstance);\n\n    if (fiber != null) {\n      if (findNearestUnfilteredAncestor) {\n        while (fiber !== null && shouldFilterFiber(fiber)) {\n          fiber = fiber.return;\n        }\n      }\n\n      return getFiberIDThrows(fiber);\n    }\n\n    return null;\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n\n\n  function assertIsMounted(fiber) {\n    if (getNearestMountedFiber(fiber) !== fiber) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n\n\n  function getNearestMountedFiber(fiber) {\n    var node = fiber;\n    var nearestMounted = fiber;\n\n    if (!fiber.alternate) {\n      // If there is no alternate, this might be a new tree that isn't inserted\n      // yet. If it is, then it will have a pending insertion effect on it.\n      var nextNode = node;\n\n      do {\n        node = nextNode; // TODO: This function, and these flags, are a leaked implementation\n        // detail. Once we start releasing DevTools in lockstep with React, we\n        // should import a function from the reconciler instead.\n\n        var Placement = 2;\n        var Hydrating = 4096;\n\n        if ((node.flags & (Placement | Hydrating)) !== 0) {\n          // This is an insertion or in-progress hydration. The nearest possible\n          // mounted fiber is the parent but we need to continue to figure out\n          // if that one is still mounted.\n          nearestMounted = node.return;\n        } // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n\n        nextNode = node.return;\n      } while (nextNode);\n    } else {\n      while (node.return) {\n        node = node.return;\n      }\n    }\n\n    if (node.tag === HostRoot) {\n      // TODO: Check if this was a nested HostRoot when used with\n      // renderContainerIntoSubtree.\n      return nearestMounted;\n    } // If we didn't hit the root, that means that we're in an disconnected tree\n    // that has been unmounted.\n\n\n    return null;\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n  // It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).\n  // BEGIN copied code\n\n\n  function findCurrentFiberUsingSlowPathById(id) {\n    var fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(\"Could not find Fiber with id \\\"\".concat(id, \"\\\"\"));\n      return null;\n    }\n\n    var alternate = fiber.alternate;\n\n    if (!alternate) {\n      // If there is no alternate, then we only need to check if it is mounted.\n      var nearestMounted = getNearestMountedFiber(fiber);\n\n      if (nearestMounted === null) {\n        throw new Error('Unable to find node on an unmounted component.');\n      }\n\n      if (nearestMounted !== fiber) {\n        return null;\n      }\n\n      return fiber;\n    } // If we have two possible branches, we'll walk backwards up to the root\n    // to see what path the root points to. On the way we may hit one of the\n    // special cases and we'll deal with them.\n\n\n    var a = fiber;\n    var b = alternate;\n\n    while (true) {\n      var parentA = a.return;\n\n      if (parentA === null) {\n        // We're at the root.\n        break;\n      }\n\n      var parentB = parentA.alternate;\n\n      if (parentB === null) {\n        // There is no alternate. This is an unusual case. Currently, it only\n        // happens when a Suspense component is hidden. An extra fragment fiber\n        // is inserted in between the Suspense fiber and its children. Skip\n        // over this extra fragment fiber and proceed to the next parent.\n        var nextParent = parentA.return;\n\n        if (nextParent !== null) {\n          a = b = nextParent;\n          continue;\n        } // If there's no parent, we're at the root.\n\n\n        break;\n      } // If both copies of the parent fiber point to the same child, we can\n      // assume that the child is current. This happens when we bailout on low\n      // priority: the bailed out fiber's child reuses the current child.\n\n\n      if (parentA.child === parentB.child) {\n        var child = parentA.child;\n\n        while (child) {\n          if (child === a) {\n            // We've determined that A is the current branch.\n            assertIsMounted(parentA);\n            return fiber;\n          }\n\n          if (child === b) {\n            // We've determined that B is the current branch.\n            assertIsMounted(parentA);\n            return alternate;\n          }\n\n          child = child.sibling;\n        } // We should never have an alternate for any mounting node. So the only\n        // way this could possibly happen is if this was unmounted, if at all.\n\n\n        throw new Error('Unable to find node on an unmounted component.');\n      }\n\n      if (a.return !== b.return) {\n        // The return pointer of A and the return pointer of B point to different\n        // fibers. We assume that return pointers never criss-cross, so A must\n        // belong to the child set of A.return, and B must belong to the child\n        // set of B.return.\n        a = parentA;\n        b = parentB;\n      } else {\n        // The return pointers point to the same fiber. We'll have to use the\n        // default, slow path: scan the child sets of each parent alternate to see\n        // which child belongs to which set.\n        //\n        // Search parent A's child set\n        var didFindChild = false;\n        var _child = parentA.child;\n\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentA;\n            b = parentB;\n            break;\n          }\n\n          if (_child === b) {\n            didFindChild = true;\n            b = parentA;\n            a = parentB;\n            break;\n          }\n\n          _child = _child.sibling;\n        }\n\n        if (!didFindChild) {\n          // Search parent B's child set\n          _child = parentB.child;\n\n          while (_child) {\n            if (_child === a) {\n              didFindChild = true;\n              a = parentB;\n              b = parentA;\n              break;\n            }\n\n            if (_child === b) {\n              didFindChild = true;\n              b = parentB;\n              a = parentA;\n              break;\n            }\n\n            _child = _child.sibling;\n          }\n\n          if (!didFindChild) {\n            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n          }\n        }\n      }\n\n      if (a.alternate !== b) {\n        throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // If the root is not a host container, we're in a disconnected tree. I.e.\n    // unmounted.\n\n\n    if (a.tag !== HostRoot) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.stateNode.current === a) {\n      // We've determined that A is the current branch.\n      return fiber;\n    } // Otherwise B has to be current branch.\n\n\n    return alternate;\n  } // END copied code\n\n\n  function prepareViewAttributeSource(id, path) {\n    if (isMostRecentlyInspectedElement(id)) {\n      window.$attribute = utils_getInObject(mostRecentlyInspectedElement, path);\n    }\n  }\n\n  function prepareViewElementSource(id) {\n    var fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(\"Could not find Fiber with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    var elementType = fiber.elementType,\n        tag = fiber.tag,\n        type = fiber.type;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IndeterminateComponent:\n      case FunctionComponent:\n        global.$type = type;\n        break;\n\n      case ForwardRef:\n        global.$type = type.render;\n        break;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        global.$type = elementType != null && elementType.type != null ? elementType.type : type;\n        break;\n\n      default:\n        global.$type = null;\n        break;\n    }\n  }\n\n  function fiberToSerializedElement(fiber) {\n    return {\n      displayName: getDisplayNameForFiber(fiber) || 'Anonymous',\n      id: getFiberIDThrows(fiber),\n      key: fiber.key,\n      type: getElementTypeForFiber(fiber)\n    };\n  }\n\n  function getOwnersList(id) {\n    var fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    var _debugOwner = fiber._debugOwner;\n    var owners = [fiberToSerializedElement(fiber)];\n\n    if (_debugOwner) {\n      var owner = _debugOwner;\n\n      while (owner !== null) {\n        owners.unshift(fiberToSerializedElement(owner));\n        owner = owner._debugOwner || null;\n      }\n    }\n\n    return owners;\n  } // Fast path props lookup for React Native style editor.\n  // Could use inspectElementRaw() but that would require shallow rendering hooks components,\n  // and could also mess with memoization.\n\n\n  function getInstanceAndStyle(id) {\n    var instance = null;\n    var style = null;\n    var fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      instance = fiber.stateNode;\n\n      if (fiber.memoizedProps !== null) {\n        style = fiber.memoizedProps.style;\n      }\n    }\n\n    return {\n      instance: instance,\n      style: style\n    };\n  }\n\n  function isErrorBoundary(fiber) {\n    var tag = fiber.tag,\n        type = fiber.type;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n        var instance = fiber.stateNode;\n        return typeof type.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function';\n\n      default:\n        return false;\n    }\n  }\n\n  function getNearestErrorBoundaryID(fiber) {\n    var parent = fiber.return;\n\n    while (parent !== null) {\n      if (isErrorBoundary(parent)) {\n        return getFiberIDUnsafe(parent);\n      }\n\n      parent = parent.return;\n    }\n\n    return null;\n  }\n\n  function inspectElementRaw(id) {\n    var fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    var _debugOwner = fiber._debugOwner,\n        _debugSource = fiber._debugSource,\n        stateNode = fiber.stateNode,\n        key = fiber.key,\n        memoizedProps = fiber.memoizedProps,\n        memoizedState = fiber.memoizedState,\n        dependencies = fiber.dependencies,\n        tag = fiber.tag,\n        type = fiber.type;\n    var elementType = getElementTypeForFiber(fiber);\n    var usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies); // TODO Show custom UI for Cache like we do for Suspense\n    // For now, just hide state data entirely since it's not meant to be inspected.\n\n    var showState = !usesHooks && tag !== CacheComponent;\n    var typeSymbol = getTypeSymbol(type);\n    var canViewSource = false;\n    var context = null;\n\n    if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {\n      canViewSource = true;\n\n      if (stateNode && stateNode.context != null) {\n        // Don't show an empty context object for class components that don't use the context API.\n        var shouldHideContext = elementType === types_ElementTypeClass && !(type.contextTypes || type.contextType);\n\n        if (!shouldHideContext) {\n          context = stateNode.context;\n        }\n      }\n    } else if (typeSymbol === CONTEXT_NUMBER || typeSymbol === CONTEXT_SYMBOL_STRING) {\n      // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n      // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n      // NOTE Keep in sync with getDisplayNameForFiber()\n      var consumerResolvedContext = type._context || type; // Global context value.\n\n      context = consumerResolvedContext._currentValue || null; // Look for overridden value.\n\n      var _current = fiber.return;\n\n      while (_current !== null) {\n        var currentType = _current.type;\n        var currentTypeSymbol = getTypeSymbol(currentType);\n\n        if (currentTypeSymbol === PROVIDER_NUMBER || currentTypeSymbol === PROVIDER_SYMBOL_STRING) {\n          // 16.3.0 exposed the context object as \"context\"\n          // PR #12501 changed it to \"_context\" for 16.3.1+\n          // NOTE Keep in sync with getDisplayNameForFiber()\n          var providerResolvedContext = currentType._context || currentType.context;\n\n          if (providerResolvedContext === consumerResolvedContext) {\n            context = _current.memoizedProps.value;\n            break;\n          }\n        }\n\n        _current = _current.return;\n      }\n    }\n\n    var hasLegacyContext = false;\n\n    if (context !== null) {\n      hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.\n      // Otherwise simple values (e.g. strings, booleans) become harder to handle.\n\n      context = {\n        value: context\n      };\n    }\n\n    var owners = null;\n\n    if (_debugOwner) {\n      owners = [];\n      var owner = _debugOwner;\n\n      while (owner !== null) {\n        owners.push(fiberToSerializedElement(owner));\n        owner = owner._debugOwner || null;\n      }\n    }\n\n    var isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;\n    var hooks = null;\n\n    if (usesHooks) {\n      var originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.\n\n      for (var method in console) {\n        try {\n          originalConsoleMethods[method] = console[method]; // $FlowFixMe[prop-missing]\n\n          console[method] = function () {};\n        } catch (error) {}\n      }\n\n      try {\n        hooks = (0,react_debug_tools.inspectHooksOfFiber)(fiber, renderer.currentDispatcherRef, true // Include source location info for hooks\n        );\n      } finally {\n        // Restore original console functionality.\n        for (var _method in originalConsoleMethods) {\n          try {\n            // $FlowFixMe[prop-missing]\n            console[_method] = originalConsoleMethods[_method];\n          } catch (error) {}\n        }\n      }\n    }\n\n    var rootType = null;\n    var current = fiber;\n\n    while (current.return !== null) {\n      current = current.return;\n    }\n\n    var fiberRoot = current.stateNode;\n\n    if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n      rootType = fiberRoot._debugRootType;\n    }\n\n    var errors = fiberIDToErrorsMap.get(id) || new Map();\n    var warnings = fiberIDToWarningsMap.get(id) || new Map();\n    var isErrored = false;\n    var targetErrorBoundaryID;\n\n    if (isErrorBoundary(fiber)) {\n      // if the current inspected element is an error boundary,\n      // either that we want to use it to toggle off error state\n      // or that we allow to force error state on it if it's within another\n      // error boundary\n      //\n      // TODO: This flag is a leaked implementation detail. Once we start\n      // releasing DevTools in lockstep with React, we should import a function\n      // from the reconciler instead.\n      var DidCapture = 128;\n      isErrored = (fiber.flags & DidCapture) !== 0 || forceErrorForFiberIDs.get(id) === true;\n      targetErrorBoundaryID = isErrored ? id : getNearestErrorBoundaryID(fiber);\n    } else {\n      targetErrorBoundaryID = getNearestErrorBoundaryID(fiber);\n    }\n\n    var plugins = {\n      stylex: null\n    };\n\n    if (enableStyleXFeatures) {\n      if (memoizedProps != null && memoizedProps.hasOwnProperty('xstyle')) {\n        plugins.stylex = getStyleXData(memoizedProps.xstyle);\n      }\n    }\n\n    return {\n      id: id,\n      // Does the current renderer support editable hooks and function props?\n      canEditHooks: typeof overrideHookState === 'function',\n      canEditFunctionProps: typeof overrideProps === 'function',\n      // Does the current renderer support advanced editing interface?\n      canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === 'function',\n      canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === 'function',\n      canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === 'function',\n      canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === 'function',\n      canToggleError: supportsTogglingError && targetErrorBoundaryID != null,\n      // Is this error boundary in error state.\n      isErrored: isErrored,\n      targetErrorBoundaryID: targetErrorBoundaryID,\n      canToggleSuspense: supportsTogglingSuspense && ( // If it's showing the real content, we can always flip fallback.\n      !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,\n      // allow toggling it back to remove the fallback override.\n      forceFallbackForSuspenseIDs.has(id)),\n      // Can view component source location.\n      canViewSource: canViewSource,\n      // Does the component have legacy context attached to it.\n      hasLegacyContext: hasLegacyContext,\n      key: key != null ? key : null,\n      displayName: getDisplayNameForFiber(fiber),\n      type: elementType,\n      // Inspectable properties.\n      // TODO Review sanitization approach for the below inspectable values.\n      context: context,\n      hooks: hooks,\n      props: memoizedProps,\n      state: showState ? memoizedState : null,\n      errors: Array.from(errors.entries()),\n      warnings: Array.from(warnings.entries()),\n      // List of owners\n      owners: owners,\n      // Location of component in source code.\n      source: _debugSource || null,\n      rootType: rootType,\n      rendererPackageName: renderer.rendererPackageName,\n      rendererVersion: renderer.version,\n      plugins: plugins\n    };\n  }\n\n  var mostRecentlyInspectedElement = null;\n  var hasElementUpdatedSinceLastInspected = false;\n  var currentlyInspectedPaths = {};\n\n  function isMostRecentlyInspectedElement(id) {\n    return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id;\n  }\n\n  function isMostRecentlyInspectedElementCurrent(id) {\n    return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;\n  } // Track the intersection of currently inspected paths,\n  // so that we can send their data along if the element is re-rendered.\n\n\n  function mergeInspectedPaths(path) {\n    var current = currentlyInspectedPaths;\n    path.forEach(function (key) {\n      if (!current[key]) {\n        current[key] = {};\n      }\n\n      current = current[key];\n    });\n  }\n\n  function createIsPathAllowed(key, secondaryCategory) {\n    // This function helps prevent previously-inspected paths from being dehydrated in updates.\n    // This is important to avoid a bad user experience where expanded toggles collapse on update.\n    return function isPathAllowed(path) {\n      switch (secondaryCategory) {\n        case 'hooks':\n          if (path.length === 1) {\n            // Never dehydrate the \"hooks\" object at the top levels.\n            return true;\n          }\n\n          if (path[path.length - 2] === 'hookSource' && path[path.length - 1] === 'fileName') {\n            // It's important to preserve the full file name (URL) for hook sources\n            // in case the user has enabled the named hooks feature.\n            // Otherwise the frontend may end up with a partial URL which it can't load.\n            return true;\n          }\n\n          if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {\n            // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,\n            // so it's easiest for now if we just don't break on this boundary.\n            // We can always dehydrate a level deeper (in the value object).\n            return true;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      var current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];\n\n      if (!current) {\n        return false;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        current = current[path[i]];\n\n        if (!current) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  }\n\n  function updateSelectedElement(inspectedElement) {\n    var hooks = inspectedElement.hooks,\n        id = inspectedElement.id,\n        props = inspectedElement.props;\n    var fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(\"Could not find Fiber with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    var elementType = fiber.elementType,\n        stateNode = fiber.stateNode,\n        tag = fiber.tag,\n        type = fiber.type;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IndeterminateComponent:\n        global.$r = stateNode;\n        break;\n\n      case FunctionComponent:\n        global.$r = {\n          hooks: hooks,\n          props: props,\n          type: type\n        };\n        break;\n\n      case ForwardRef:\n        global.$r = {\n          hooks: hooks,\n          props: props,\n          type: type.render\n        };\n        break;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        global.$r = {\n          hooks: hooks,\n          props: props,\n          type: elementType != null && elementType.type != null ? elementType.type : type\n        };\n        break;\n\n      default:\n        global.$r = null;\n        break;\n    }\n  }\n\n  function storeAsGlobal(id, path, count) {\n    if (isMostRecentlyInspectedElement(id)) {\n      var value = utils_getInObject(mostRecentlyInspectedElement, path);\n      var key = \"$reactTemp\".concat(count);\n      window[key] = value;\n      console.log(key);\n      console.log(value);\n    }\n  }\n\n  function getSerializedElementValueByPath(id, path) {\n    if (isMostRecentlyInspectedElement(id)) {\n      var valueToCopy = utils_getInObject(mostRecentlyInspectedElement, path);\n      return serializeToString(valueToCopy);\n    }\n  }\n\n  function inspectElement(requestID, id, path, forceFullData) {\n    if (path !== null) {\n      mergeInspectedPaths(path);\n    }\n\n    if (isMostRecentlyInspectedElement(id) && !forceFullData) {\n      if (!hasElementUpdatedSinceLastInspected) {\n        if (path !== null) {\n          var secondaryCategory = null;\n\n          if (path[0] === 'hooks') {\n            secondaryCategory = 'hooks';\n          } // If this element has not been updated since it was last inspected,\n          // we can just return the subset of data in the newly-inspected path.\n\n\n          return {\n            id: id,\n            responseID: requestID,\n            type: 'hydrated-path',\n            path: path,\n            value: cleanForBridge(utils_getInObject(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)\n          };\n        } else {\n          // If this element has not been updated since it was last inspected, we don't need to return it.\n          // Instead we can just return the ID to indicate that it has not changed.\n          return {\n            id: id,\n            responseID: requestID,\n            type: 'no-change'\n          };\n        }\n      }\n    } else {\n      currentlyInspectedPaths = {};\n    }\n\n    hasElementUpdatedSinceLastInspected = false;\n\n    try {\n      mostRecentlyInspectedElement = inspectElementRaw(id);\n    } catch (error) {\n      // the error name is synced with ReactDebugHooks\n      if (error.name === 'ReactDebugToolsRenderError') {\n        var message = 'Error rendering inspected element.';\n        var stack; // Log error & cause for user to debug\n\n        console.error(message + '\\n\\n', error);\n\n        if (error.cause != null) {\n          var _fiber4 = findCurrentFiberUsingSlowPathById(id);\n\n          var componentName = _fiber4 != null ? getDisplayNameForFiber(_fiber4) : null;\n          console.error('React DevTools encountered an error while trying to inspect hooks. ' + 'This is most likely caused by an error in current inspected component' + (componentName != null ? \": \\\"\".concat(componentName, \"\\\".\") : '.') + '\\nThe error thrown in the component is: \\n\\n', error.cause);\n\n          if (error.cause instanceof Error) {\n            message = error.cause.message || message;\n            stack = error.cause.stack;\n          }\n        }\n\n        return {\n          type: 'error',\n          errorType: 'user',\n          id: id,\n          responseID: requestID,\n          message: message,\n          stack: stack\n        };\n      } // the error name is synced with ReactDebugHooks\n\n\n      if (error.name === 'ReactDebugToolsUnsupportedHookError') {\n        return {\n          type: 'error',\n          errorType: 'unknown-hook',\n          id: id,\n          responseID: requestID,\n          message: 'Unsupported hook in the react-debug-tools package: ' + error.message\n        };\n      } // Log Uncaught Error\n\n\n      console.error('Error inspecting element.\\n\\n', error);\n      return {\n        type: 'error',\n        errorType: 'uncaught',\n        id: id,\n        responseID: requestID,\n        message: error.message,\n        stack: error.stack\n      };\n    }\n\n    if (mostRecentlyInspectedElement === null) {\n      return {\n        id: id,\n        responseID: requestID,\n        type: 'not-found'\n      };\n    } // Any time an inspected element has an update,\n    // we should update the selected $r value as wel.\n    // Do this before dehydration (cleanForBridge).\n\n\n    updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.\n    // This will enable us to send patches without re-inspecting if hydrated paths are requested.\n    // (Reducing how often we shallow-render is a better DX for function components that use hooks.)\n\n    var cleanedInspectedElement = renderer_objectSpread({}, mostRecentlyInspectedElement); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n    cleanedInspectedElement.context = cleanForBridge(cleanedInspectedElement.context, createIsPathAllowed('context', null)); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.hooks = cleanForBridge(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks')); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.props = cleanForBridge(cleanedInspectedElement.props, createIsPathAllowed('props', null)); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.state = cleanForBridge(cleanedInspectedElement.state, createIsPathAllowed('state', null));\n    return {\n      id: id,\n      responseID: requestID,\n      type: 'full-data',\n      // $FlowFixMe[prop-missing] found when upgrading Flow\n      value: cleanedInspectedElement\n    };\n  }\n\n  function logElementToConsole(id) {\n    var result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);\n\n    if (result === null) {\n      console.warn(\"Could not find Fiber with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    var supportsGroup = typeof console.groupCollapsed === 'function';\n\n    if (supportsGroup) {\n      console.groupCollapsed(\"[Click to expand] %c<\".concat(result.displayName || 'Component', \" />\"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n      'color: var(--dom-tag-name-color); font-weight: normal;');\n    }\n\n    if (result.props !== null) {\n      console.log('Props:', result.props);\n    }\n\n    if (result.state !== null) {\n      console.log('State:', result.state);\n    }\n\n    if (result.hooks !== null) {\n      console.log('Hooks:', result.hooks);\n    }\n\n    var nativeNodes = findNativeNodesForFiberID(id);\n\n    if (nativeNodes !== null) {\n      console.log('Nodes:', nativeNodes);\n    }\n\n    if (result.source !== null) {\n      console.log('Location:', result.source);\n    }\n\n    if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n      console.log('Right-click any value to save it as a global variable for further inspection.');\n    }\n\n    if (supportsGroup) {\n      console.groupEnd();\n    }\n  }\n\n  function deletePath(type, id, hookID, path) {\n    var fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      var instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          path = path.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (path.length === 0) {// Simple context value (noop)\n              } else {\n                deletePathInObject(instance.context, path);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookStateDeletePath === 'function') {\n            overrideHookStateDeletePath(fiber, hookID, path);\n          }\n\n          break;\n\n        case 'props':\n          if (instance === null) {\n            if (typeof overridePropsDeletePath === 'function') {\n              overridePropsDeletePath(fiber, path);\n            }\n          } else {\n            fiber.pendingProps = copyWithDelete(instance.props, path);\n            instance.forceUpdate();\n          }\n\n          break;\n\n        case 'state':\n          deletePathInObject(instance.state, path);\n          instance.forceUpdate();\n          break;\n      }\n    }\n  }\n\n  function renamePath(type, id, hookID, oldPath, newPath) {\n    var fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      var instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          oldPath = oldPath.slice(1);\n          newPath = newPath.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (oldPath.length === 0) {// Simple context value (noop)\n              } else {\n                renamePathInObject(instance.context, oldPath, newPath);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookStateRenamePath === 'function') {\n            overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);\n          }\n\n          break;\n\n        case 'props':\n          if (instance === null) {\n            if (typeof overridePropsRenamePath === 'function') {\n              overridePropsRenamePath(fiber, oldPath, newPath);\n            }\n          } else {\n            fiber.pendingProps = copyWithRename(instance.props, oldPath, newPath);\n            instance.forceUpdate();\n          }\n\n          break;\n\n        case 'state':\n          renamePathInObject(instance.state, oldPath, newPath);\n          instance.forceUpdate();\n          break;\n      }\n    }\n  }\n\n  function overrideValueAtPath(type, id, hookID, path, value) {\n    var fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      var instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          path = path.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (path.length === 0) {\n                // Simple context value\n                instance.context = value;\n              } else {\n                utils_setInObject(instance.context, path, value);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookState === 'function') {\n            overrideHookState(fiber, hookID, path, value);\n          }\n\n          break;\n\n        case 'props':\n          switch (fiber.tag) {\n            case ClassComponent:\n              fiber.pendingProps = copyWithSet(instance.props, path, value);\n              instance.forceUpdate();\n              break;\n\n            default:\n              if (typeof overrideProps === 'function') {\n                overrideProps(fiber, path, value);\n              }\n\n              break;\n          }\n\n          break;\n\n        case 'state':\n          switch (fiber.tag) {\n            case ClassComponent:\n              utils_setInObject(instance.state, path, value);\n              instance.forceUpdate();\n              break;\n          }\n\n          break;\n      }\n    }\n  }\n\n  var currentCommitProfilingMetadata = null;\n  var displayNamesByRootID = null;\n  var idToContextsMap = null;\n  var initialTreeBaseDurationsMap = null;\n  var initialIDToRootMap = null;\n  var isProfiling = false;\n  var profilingStartTime = 0;\n  var recordChangeDescriptions = false;\n  var rootToCommitProfilingMetadataMap = null;\n\n  function getProfilingData() {\n    var dataForRoots = [];\n\n    if (rootToCommitProfilingMetadataMap === null) {\n      throw Error('getProfilingData() called before any profiling data was recorded');\n    }\n\n    rootToCommitProfilingMetadataMap.forEach(function (commitProfilingMetadata, rootID) {\n      var commitData = [];\n      var initialTreeBaseDurations = [];\n      var displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';\n\n      if (initialTreeBaseDurationsMap != null) {\n        initialTreeBaseDurationsMap.forEach(function (treeBaseDuration, id) {\n          if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {\n            // We don't need to convert milliseconds to microseconds in this case,\n            // because the profiling summary is JSON serialized.\n            initialTreeBaseDurations.push([id, treeBaseDuration]);\n          }\n        });\n      }\n\n      commitProfilingMetadata.forEach(function (commitProfilingData, commitIndex) {\n        var changeDescriptions = commitProfilingData.changeDescriptions,\n            durations = commitProfilingData.durations,\n            effectDuration = commitProfilingData.effectDuration,\n            maxActualDuration = commitProfilingData.maxActualDuration,\n            passiveEffectDuration = commitProfilingData.passiveEffectDuration,\n            priorityLevel = commitProfilingData.priorityLevel,\n            commitTime = commitProfilingData.commitTime,\n            updaters = commitProfilingData.updaters;\n        var fiberActualDurations = [];\n        var fiberSelfDurations = [];\n\n        for (var i = 0; i < durations.length; i += 3) {\n          var fiberID = durations[i];\n          fiberActualDurations.push([fiberID, durations[i + 1]]);\n          fiberSelfDurations.push([fiberID, durations[i + 2]]);\n        }\n\n        commitData.push({\n          changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,\n          duration: maxActualDuration,\n          effectDuration: effectDuration,\n          fiberActualDurations: fiberActualDurations,\n          fiberSelfDurations: fiberSelfDurations,\n          passiveEffectDuration: passiveEffectDuration,\n          priorityLevel: priorityLevel,\n          timestamp: commitTime,\n          updaters: updaters\n        });\n      });\n      dataForRoots.push({\n        commitData: commitData,\n        displayName: displayName,\n        initialTreeBaseDurations: initialTreeBaseDurations,\n        rootID: rootID\n      });\n    });\n    var timelineData = null;\n\n    if (typeof getTimelineData === 'function') {\n      var currentTimelineData = getTimelineData();\n\n      if (currentTimelineData) {\n        var batchUIDToMeasuresMap = currentTimelineData.batchUIDToMeasuresMap,\n            internalModuleSourceToRanges = currentTimelineData.internalModuleSourceToRanges,\n            laneToLabelMap = currentTimelineData.laneToLabelMap,\n            laneToReactMeasureMap = currentTimelineData.laneToReactMeasureMap,\n            rest = _objectWithoutProperties(currentTimelineData, [\"batchUIDToMeasuresMap\", \"internalModuleSourceToRanges\", \"laneToLabelMap\", \"laneToReactMeasureMap\"]);\n\n        timelineData = renderer_objectSpread(renderer_objectSpread({}, rest), {}, {\n          // Most of the data is safe to parse as-is,\n          // but we need to convert the nested Arrays back to Maps.\n          // Most of the data is safe to serialize as-is,\n          // but we need to convert the Maps to nested Arrays.\n          batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),\n          internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),\n          laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),\n          laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries())\n        });\n      }\n    }\n\n    return {\n      dataForRoots: dataForRoots,\n      rendererID: rendererID,\n      timelineData: timelineData\n    };\n  }\n\n  function startProfiling(shouldRecordChangeDescriptions) {\n    if (isProfiling) {\n      return;\n    }\n\n    recordChangeDescriptions = shouldRecordChangeDescriptions; // Capture initial values as of the time profiling starts.\n    // It's important we snapshot both the durations and the id-to-root map,\n    // since either of these may change during the profiling session\n    // (e.g. when a fiber is re-rendered or when a fiber gets removed).\n\n    displayNamesByRootID = new Map();\n    initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);\n    initialIDToRootMap = new Map(idToRootMap);\n    idToContextsMap = new Map();\n    hook.getFiberRoots(rendererID).forEach(function (root) {\n      var rootID = getFiberIDThrows(root.current);\n      displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));\n\n      if (shouldRecordChangeDescriptions) {\n        // Record all contexts at the time profiling is started.\n        // Fibers only store the current context value,\n        // so we need to track them separately in order to determine changed keys.\n        crawlToInitializeContextsMap(root.current);\n      }\n    });\n    isProfiling = true;\n    profilingStartTime = renderer_getCurrentTime();\n    rootToCommitProfilingMetadataMap = new Map();\n\n    if (toggleProfilingStatus !== null) {\n      toggleProfilingStatus(true);\n    }\n  }\n\n  function stopProfiling() {\n    isProfiling = false;\n    recordChangeDescriptions = false;\n\n    if (toggleProfilingStatus !== null) {\n      toggleProfilingStatus(false);\n    }\n  } // Automatically start profiling so that we don't miss timing info from initial \"mount\".\n\n\n  if (sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === 'true') {\n    startProfiling(sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === 'true');\n  } // React will switch between these implementations depending on whether\n  // we have any manually suspended/errored-out Fibers or not.\n\n\n  function shouldErrorFiberAlwaysNull() {\n    return null;\n  } // Map of id and its force error status: true (error), false (toggled off),\n  // null (do nothing)\n\n\n  var forceErrorForFiberIDs = new Map();\n\n  function shouldErrorFiberAccordingToMap(fiber) {\n    if (typeof setErrorHandler !== 'function') {\n      throw new Error('Expected overrideError() to not get called for earlier React versions.');\n    }\n\n    var id = getFiberIDUnsafe(fiber);\n\n    if (id === null) {\n      return null;\n    }\n\n    var status = null;\n\n    if (forceErrorForFiberIDs.has(id)) {\n      status = forceErrorForFiberIDs.get(id);\n\n      if (status === false) {\n        // TRICKY overrideError adds entries to this Map,\n        // so ideally it would be the method that clears them too,\n        // but that would break the functionality of the feature,\n        // since DevTools needs to tell React to act differently than it normally would\n        // (don't just re-render the failed boundary, but reset its errored state too).\n        // So we can only clear it after telling React to reset the state.\n        // Technically this is premature and we should schedule it for later,\n        // since the render could always fail without committing the updated error boundary,\n        // but since this is a DEV-only feature, the simplicity is worth the trade off.\n        forceErrorForFiberIDs.delete(id);\n\n        if (forceErrorForFiberIDs.size === 0) {\n          // Last override is gone. Switch React back to fast path.\n          setErrorHandler(shouldErrorFiberAlwaysNull);\n        }\n      }\n    }\n\n    return status;\n  }\n\n  function overrideError(id, forceError) {\n    if (typeof setErrorHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n      throw new Error('Expected overrideError() to not get called for earlier React versions.');\n    }\n\n    forceErrorForFiberIDs.set(id, forceError);\n\n    if (forceErrorForFiberIDs.size === 1) {\n      // First override is added. Switch React to slower path.\n      setErrorHandler(shouldErrorFiberAccordingToMap);\n    }\n\n    var fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber != null) {\n      scheduleUpdate(fiber);\n    }\n  }\n\n  function shouldSuspendFiberAlwaysFalse() {\n    return false;\n  }\n\n  var forceFallbackForSuspenseIDs = new Set();\n\n  function shouldSuspendFiberAccordingToSet(fiber) {\n    var maybeID = getFiberIDUnsafe(fiber);\n    return maybeID !== null && forceFallbackForSuspenseIDs.has(maybeID);\n  }\n\n  function overrideSuspense(id, forceFallback) {\n    if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n      throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');\n    }\n\n    if (forceFallback) {\n      forceFallbackForSuspenseIDs.add(id);\n\n      if (forceFallbackForSuspenseIDs.size === 1) {\n        // First override is added. Switch React to slower path.\n        setSuspenseHandler(shouldSuspendFiberAccordingToSet);\n      }\n    } else {\n      forceFallbackForSuspenseIDs.delete(id);\n\n      if (forceFallbackForSuspenseIDs.size === 0) {\n        // Last override is gone. Switch React back to fast path.\n        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);\n      }\n    }\n\n    var fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber != null) {\n      scheduleUpdate(fiber);\n    }\n  } // Remember if we're trying to restore the selection after reload.\n  // In that case, we'll do some extra checks for matching mounts.\n\n\n  var trackedPath = null;\n  var trackedPathMatchFiber = null;\n  var trackedPathMatchDepth = -1;\n  var mightBeOnTrackedPath = false;\n\n  function setTrackedPath(path) {\n    if (path === null) {\n      trackedPathMatchFiber = null;\n      trackedPathMatchDepth = -1;\n      mightBeOnTrackedPath = false;\n    }\n\n    trackedPath = path;\n  } // We call this before traversing a new mount.\n  // It remembers whether this Fiber is the next best match for tracked path.\n  // The return value signals whether we should keep matching siblings or not.\n\n\n  function updateTrackedPathStateBeforeMount(fiber) {\n    if (trackedPath === null || !mightBeOnTrackedPath) {\n      // Fast path: there's nothing to track so do nothing and ignore siblings.\n      return false;\n    }\n\n    var returnFiber = fiber.return;\n    var returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.\n    // Is this newly mounted Fiber a direct child of the current best match?\n    // (This will also be true for new roots if we haven't matched anything yet.)\n\n    if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {\n      // Is this the next Fiber we should select? Let's compare the frames.\n      var actualFrame = getPathFrame(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      var expectedFrame = trackedPath[trackedPathMatchDepth + 1];\n\n      if (expectedFrame === undefined) {\n        throw new Error('Expected to see a frame at the next depth.');\n      }\n\n      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {\n        // We have our next match.\n        trackedPathMatchFiber = fiber;\n        trackedPathMatchDepth++; // Are we out of frames to match?\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n        if (trackedPathMatchDepth === trackedPath.length - 1) {\n          // There's nothing that can possibly match afterwards.\n          // Don't check the children.\n          mightBeOnTrackedPath = false;\n        } else {\n          // Check the children, as they might reveal the next match.\n          mightBeOnTrackedPath = true;\n        } // In either case, since we have a match, we don't need\n        // to check the siblings. They'll never match.\n\n\n        return false;\n      }\n    } // This Fiber's parent is on the path, but this Fiber itself isn't.\n    // There's no need to check its children--they won't be on the path either.\n\n\n    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.\n\n    return true;\n  }\n\n  function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {\n    // updateTrackedPathStateBeforeMount() told us whether to match siblings.\n    // Now that we're entering siblings, let's use that information.\n    mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;\n  } // Roots don't have a real persistent identity.\n  // A root's \"pseudo key\" is \"childDisplayName:indexWithThatName\".\n  // For example, \"App:0\" or, in case of similar roots, \"Story:0\", \"Story:1\", etc.\n  // We will use this to try to disambiguate roots when restoring selection between reloads.\n\n\n  var rootPseudoKeys = new Map();\n  var rootDisplayNameCounter = new Map();\n\n  function setRootPseudoKey(id, fiber) {\n    var name = getDisplayNameForRoot(fiber);\n    var counter = rootDisplayNameCounter.get(name) || 0;\n    rootDisplayNameCounter.set(name, counter + 1);\n    var pseudoKey = \"\".concat(name, \":\").concat(counter);\n    rootPseudoKeys.set(id, pseudoKey);\n  }\n\n  function removeRootPseudoKey(id) {\n    var pseudoKey = rootPseudoKeys.get(id);\n\n    if (pseudoKey === undefined) {\n      throw new Error('Expected root pseudo key to be known.');\n    }\n\n    var name = pseudoKey.slice(0, pseudoKey.lastIndexOf(':'));\n    var counter = rootDisplayNameCounter.get(name);\n\n    if (counter === undefined) {\n      throw new Error('Expected counter to be known.');\n    }\n\n    if (counter > 1) {\n      rootDisplayNameCounter.set(name, counter - 1);\n    } else {\n      rootDisplayNameCounter.delete(name);\n    }\n\n    rootPseudoKeys.delete(id);\n  }\n\n  function getDisplayNameForRoot(fiber) {\n    var preferredDisplayName = null;\n    var fallbackDisplayName = null;\n    var child = fiber.child; // Go at most three levels deep into direct children\n    // while searching for a child that has a displayName.\n\n    for (var i = 0; i < 3; i++) {\n      if (child === null) {\n        break;\n      }\n\n      var displayName = getDisplayNameForFiber(child);\n\n      if (displayName !== null) {\n        // Prefer display names that we get from user-defined components.\n        // We want to avoid using e.g. 'Suspense' unless we find nothing else.\n        if (typeof child.type === 'function') {\n          // There's a few user-defined tags, but we'll prefer the ones\n          // that are usually explicitly named (function or class components).\n          preferredDisplayName = displayName;\n        } else if (fallbackDisplayName === null) {\n          fallbackDisplayName = displayName;\n        }\n      }\n\n      if (preferredDisplayName !== null) {\n        break;\n      }\n\n      child = child.child;\n    }\n\n    return preferredDisplayName || fallbackDisplayName || 'Anonymous';\n  }\n\n  function getPathFrame(fiber) {\n    var key = fiber.key;\n    var displayName = getDisplayNameForFiber(fiber);\n    var index = fiber.index;\n\n    switch (fiber.tag) {\n      case HostRoot:\n        // Roots don't have a real displayName, index, or key.\n        // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).\n        var id = getFiberIDThrows(fiber);\n        var pseudoKey = rootPseudoKeys.get(id);\n\n        if (pseudoKey === undefined) {\n          throw new Error('Expected mounted root to have known pseudo key.');\n        }\n\n        displayName = pseudoKey;\n        break;\n\n      case HostComponent:\n        displayName = fiber.type;\n        break;\n\n      default:\n        break;\n    }\n\n    return {\n      displayName: displayName,\n      key: key,\n      index: index\n    };\n  } // Produces a serializable representation that does a best effort\n  // of identifying a particular Fiber between page reloads.\n  // The return path will contain Fibers that are \"invisible\" to the store\n  // because their keys and indexes are important to restoring the selection.\n\n\n  function getPathForElement(id) {\n    var fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    var keyPath = [];\n\n    while (fiber !== null) {\n      // $FlowFixMe[incompatible-call] found when upgrading Flow\n      keyPath.push(getPathFrame(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      fiber = fiber.return;\n    }\n\n    keyPath.reverse();\n    return keyPath;\n  }\n\n  function getBestMatchForTrackedPath() {\n    if (trackedPath === null) {\n      // Nothing to match.\n      return null;\n    }\n\n    if (trackedPathMatchFiber === null) {\n      // We didn't find anything.\n      return null;\n    } // Find the closest Fiber store is aware of.\n\n\n    var fiber = trackedPathMatchFiber;\n\n    while (fiber !== null && shouldFilterFiber(fiber)) {\n      fiber = fiber.return;\n    }\n\n    if (fiber === null) {\n      return null;\n    }\n\n    return {\n      id: getFiberIDThrows(fiber),\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      isFullMatch: trackedPathMatchDepth === trackedPath.length - 1\n    };\n  }\n\n  var formatPriorityLevel = function formatPriorityLevel(priorityLevel) {\n    if (priorityLevel == null) {\n      return 'Unknown';\n    }\n\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        return 'Immediate';\n\n      case UserBlockingPriority:\n        return 'User-Blocking';\n\n      case NormalPriority:\n        return 'Normal';\n\n      case LowPriority:\n        return 'Low';\n\n      case IdlePriority:\n        return 'Idle';\n\n      case NoPriority:\n      default:\n        return 'Unknown';\n    }\n  };\n\n  function setTraceUpdatesEnabled(isEnabled) {\n    traceUpdatesEnabled = isEnabled;\n  }\n\n  function hasFiberWithId(id) {\n    return idToArbitraryFiberMap.has(id);\n  }\n\n  return {\n    cleanup: cleanup,\n    clearErrorsAndWarnings: clearErrorsAndWarnings,\n    clearErrorsForFiberID: clearErrorsForFiberID,\n    clearWarningsForFiberID: clearWarningsForFiberID,\n    getSerializedElementValueByPath: getSerializedElementValueByPath,\n    deletePath: deletePath,\n    findNativeNodesForFiberID: findNativeNodesForFiberID,\n    flushInitialOperations: flushInitialOperations,\n    getBestMatchForTrackedPath: getBestMatchForTrackedPath,\n    getDisplayNameForFiberID: getDisplayNameForFiberID,\n    getFiberForNative: getFiberForNative,\n    getFiberIDForNative: getFiberIDForNative,\n    getInstanceAndStyle: getInstanceAndStyle,\n    getOwnersList: getOwnersList,\n    getPathForElement: getPathForElement,\n    getProfilingData: getProfilingData,\n    handleCommitFiberRoot: handleCommitFiberRoot,\n    handleCommitFiberUnmount: handleCommitFiberUnmount,\n    handlePostCommitFiberRoot: handlePostCommitFiberRoot,\n    hasFiberWithId: hasFiberWithId,\n    inspectElement: inspectElement,\n    logElementToConsole: logElementToConsole,\n    patchConsoleForStrictMode: patchForStrictMode,\n    prepareViewAttributeSource: prepareViewAttributeSource,\n    prepareViewElementSource: prepareViewElementSource,\n    overrideError: overrideError,\n    overrideSuspense: overrideSuspense,\n    overrideValueAtPath: overrideValueAtPath,\n    renamePath: renamePath,\n    renderer: renderer,\n    setTraceUpdatesEnabled: setTraceUpdatesEnabled,\n    setTrackedPath: setTrackedPath,\n    startProfiling: startProfiling,\n    stopProfiling: stopProfiling,\n    storeAsGlobal: storeAsGlobal,\n    unpatchConsoleForStrictMode: unpatchForStrictMode,\n    updateComponentFilters: updateComponentFilters\n  };\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/console.js\nfunction console_toConsumableArray(arr) { return console_arrayWithoutHoles(arr) || console_iterableToArray(arr) || console_unsupportedIterableToArray(arr) || console_nonIterableSpread(); }\n\nfunction console_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction console_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction console_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return console_arrayLikeToArray(arr); }\n\nfunction console_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = console_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction console_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return console_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return console_arrayLikeToArray(o, minLen); }\n\nfunction console_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\nvar OVERRIDE_CONSOLE_METHODS = ['error', 'trace', 'warn'];\nvar DIMMED_NODE_CONSOLE_COLOR = '\\x1b[2m%s\\x1b[0m'; // React's custom built component stack strings match \"\\s{4}in\"\n// Chrome's prefix matches \"\\s{4}at\"\n\nvar PREFIX_REGEX = /\\s{4}(in|at)\\s{1}/; // Firefox and Safari have no prefix (\"\")\n// but we can fallback to looking for location info (e.g. \"foo.js:12:345\")\n\nvar ROW_COLUMN_NUMBER_REGEX = /:\\d+:\\d+(\\n|$)/;\nfunction isStringComponentStack(text) {\n  return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);\n}\nvar STYLE_DIRECTIVE_REGEX = /^%c/; // This function tells whether or not the arguments for a console\n// method has been overridden by the patchForStrictMode function.\n// If it has we'll need to do some special formatting of the arguments\n// so the console color stays consistent\n\nfunction isStrictModeOverride(args, method) {\n  return args.length >= 2 && STYLE_DIRECTIVE_REGEX.test(args[0]) && args[1] === \"color: \".concat(getConsoleColor(method) || '');\n}\n\nfunction getConsoleColor(method) {\n  switch (method) {\n    case 'warn':\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(250, 180, 50, 0.75)\" : \"rgba(250, 180, 50, 0.5)\";\n\n    case 'error':\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(250, 123, 130, 0.75)\" : \"rgba(250, 123, 130, 0.5)\";\n\n    case 'log':\n    default:\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(125, 125, 125, 0.75)\" : \"rgba(125, 125, 125, 0.5)\";\n  }\n}\n\nvar injectedRenderers = new Map();\nvar targetConsole = console;\nvar targetConsoleMethods = {};\n\nfor (var method in console) {\n  targetConsoleMethods[method] = console[method];\n}\n\nvar unpatchFn = null;\nvar isNode = false;\n\ntry {\n  isNode = undefined === global;\n} catch (error) {} // Enables e.g. Jest tests to inject a mock console object.\n\n\nfunction dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {\n  targetConsole = targetConsoleForTesting;\n  targetConsoleMethods = {};\n\n  for (var _method in targetConsole) {\n    targetConsoleMethods[_method] = console[_method];\n  }\n} // v16 renderers should use this method to inject internals necessary to generate a component stack.\n// These internals will be used if the console is patched.\n// Injecting them separately allows the console to easily be patched or un-patched later (at runtime).\n\nfunction registerRenderer(renderer, onErrorOrWarning) {\n  var currentDispatcherRef = renderer.currentDispatcherRef,\n      getCurrentFiber = renderer.getCurrentFiber,\n      findFiberByHostInstance = renderer.findFiberByHostInstance,\n      version = renderer.version; // Ignore React v15 and older because they don't expose a component stack anyway.\n\n  if (typeof findFiberByHostInstance !== 'function') {\n    return;\n  } // currentDispatcherRef gets injected for v16.8+ to support hooks inspection.\n  // getCurrentFiber gets injected for v16.9+.\n\n\n  if (currentDispatcherRef != null && typeof getCurrentFiber === 'function') {\n    var _getInternalReactCons = getInternalReactConstants(version),\n        ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork;\n\n    injectedRenderers.set(renderer, {\n      currentDispatcherRef: currentDispatcherRef,\n      getCurrentFiber: getCurrentFiber,\n      workTagMap: ReactTypeOfWork,\n      onErrorOrWarning: onErrorOrWarning\n    });\n  }\n}\nvar consoleSettingsRef = {\n  appendComponentStack: false,\n  breakOnConsoleErrors: false,\n  showInlineWarningsAndErrors: false,\n  hideConsoleLogsInStrictMode: false,\n  browserTheme: 'dark'\n}; // Patches console methods to append component stack for the current fiber.\n// Call unpatch() to remove the injected behavior.\n\nfunction patch(_ref) {\n  var appendComponentStack = _ref.appendComponentStack,\n      breakOnConsoleErrors = _ref.breakOnConsoleErrors,\n      showInlineWarningsAndErrors = _ref.showInlineWarningsAndErrors,\n      hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode,\n      browserTheme = _ref.browserTheme;\n  // Settings may change after we've patched the console.\n  // Using a shared ref allows the patch function to read the latest values.\n  consoleSettingsRef.appendComponentStack = appendComponentStack;\n  consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;\n  consoleSettingsRef.showInlineWarningsAndErrors = showInlineWarningsAndErrors;\n  consoleSettingsRef.hideConsoleLogsInStrictMode = hideConsoleLogsInStrictMode;\n  consoleSettingsRef.browserTheme = browserTheme;\n\n  if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {\n    if (unpatchFn !== null) {\n      // Don't patch twice.\n      return;\n    }\n\n    var originalConsoleMethods = {};\n\n    unpatchFn = function unpatchFn() {\n      for (var _method2 in originalConsoleMethods) {\n        try {\n          targetConsole[_method2] = originalConsoleMethods[_method2];\n        } catch (error) {}\n      }\n    };\n\n    OVERRIDE_CONSOLE_METHODS.forEach(function (method) {\n      try {\n        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ : targetConsole[method]; // $FlowFixMe[missing-local-annot]\n\n        var overrideMethod = function overrideMethod() {\n          var shouldAppendWarningStack = false;\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          if (method !== 'log') {\n            if (consoleSettingsRef.appendComponentStack) {\n              var lastArg = args.length > 0 ? args[args.length - 1] : null;\n              var alreadyHasComponentStack = typeof lastArg === 'string' && isStringComponentStack(lastArg); // If we are ever called with a string that already has a component stack,\n              // e.g. a React error/warning, don't append a second stack.\n\n              shouldAppendWarningStack = !alreadyHasComponentStack;\n            }\n          }\n\n          var shouldShowInlineWarningsAndErrors = consoleSettingsRef.showInlineWarningsAndErrors && (method === 'error' || method === 'warn'); // Search for the first renderer that has a current Fiber.\n          // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)\n          // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n          var _iterator = console_createForOfIteratorHelper(injectedRenderers.values()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _step.value,\n                  currentDispatcherRef = _step$value.currentDispatcherRef,\n                  getCurrentFiber = _step$value.getCurrentFiber,\n                  onErrorOrWarning = _step$value.onErrorOrWarning,\n                  workTagMap = _step$value.workTagMap;\n              var current = getCurrentFiber();\n\n              if (current != null) {\n                try {\n                  if (shouldShowInlineWarningsAndErrors) {\n                    // patch() is called by two places: (1) the hook and (2) the renderer backend.\n                    // The backend is what implements a message queue, so it's the only one that injects onErrorOrWarning.\n                    if (typeof onErrorOrWarning === 'function') {\n                      onErrorOrWarning(current, method, // Copy args before we mutate them (e.g. adding the component stack)\n                      args.slice());\n                    }\n                  }\n\n                  if (shouldAppendWarningStack) {\n                    var componentStack = getStackByFiberInDevAndProd(workTagMap, current, currentDispatcherRef);\n\n                    if (componentStack !== '') {\n                      if (isStrictModeOverride(args, method)) {\n                        args[0] = \"\".concat(args[0], \" %s\");\n                        args.push(componentStack);\n                      } else {\n                        args.push(componentStack);\n                      }\n                    }\n                  }\n                } catch (error) {\n                  // Don't let a DevTools or React internal error interfere with logging.\n                  setTimeout(function () {\n                    throw error;\n                  }, 0);\n                } finally {\n                  break;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          if (consoleSettingsRef.breakOnConsoleErrors) {\n            // --- Welcome to debugging with React DevTools ---\n            // This debugger statement means that you've enabled the \"break on warnings\" feature.\n            // Use the browser's Call Stack panel to step out of this override function-\n            // to where the original warning or error was logged.\n            // eslint-disable-next-line no-debugger\n            debugger;\n          }\n\n          originalMethod.apply(void 0, args);\n        };\n\n        overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod;\n        originalMethod.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = overrideMethod;\n        targetConsole[method] = overrideMethod;\n      } catch (error) {}\n    });\n  } else {\n    unpatch();\n  }\n} // Removed component stack patch from console methods.\n\nfunction unpatch() {\n  if (unpatchFn !== null) {\n    unpatchFn();\n    unpatchFn = null;\n  }\n}\nvar unpatchForStrictModeFn = null; // NOTE: KEEP IN SYNC with src/hook.js:patchConsoleForInitialRenderInStrictMode\n\nfunction patchForStrictMode() {\n  if (consoleManagedByDevToolsDuringStrictMode) {\n    var overrideConsoleMethods = ['error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'];\n\n    if (unpatchForStrictModeFn !== null) {\n      // Don't patch twice.\n      return;\n    }\n\n    var originalConsoleMethods = {};\n\n    unpatchForStrictModeFn = function unpatchForStrictModeFn() {\n      for (var _method3 in originalConsoleMethods) {\n        try {\n          targetConsole[_method3] = originalConsoleMethods[_method3];\n        } catch (error) {}\n      }\n    };\n\n    overrideConsoleMethods.forEach(function (method) {\n      try {\n        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method]; // $FlowFixMe[missing-local-annot]\n\n        var overrideMethod = function overrideMethod() {\n          if (!consoleSettingsRef.hideConsoleLogsInStrictMode) {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            // Dim the text color of the double logs if we're not\n            // hiding them.\n            if (isNode) {\n              originalMethod(DIMMED_NODE_CONSOLE_COLOR, format.apply(void 0, args));\n            } else {\n              var color = getConsoleColor(method);\n\n              if (color) {\n                originalMethod.apply(void 0, console_toConsumableArray(formatWithStyles(args, \"color: \".concat(color))));\n              } else {\n                throw Error('Console color is not defined');\n              }\n            }\n          }\n        };\n\n        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;\n        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;\n        targetConsole[method] = overrideMethod;\n      } catch (error) {}\n    });\n  }\n} // NOTE: KEEP IN SYNC with src/hook.js:unpatchConsoleForInitialRenderInStrictMode\n\nfunction unpatchForStrictMode() {\n  if (consoleManagedByDevToolsDuringStrictMode) {\n    if (unpatchForStrictModeFn !== null) {\n      unpatchForStrictModeFn();\n      unpatchForStrictModeFn = null;\n    }\n  }\n}\nfunction patchConsoleUsingWindowValues() {\n  var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;\n\n  var appendComponentStack = (_castBool = castBool(window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__)) !== null && _castBool !== void 0 ? _castBool : true;\n  var breakOnConsoleErrors = (_castBool2 = castBool(window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__)) !== null && _castBool2 !== void 0 ? _castBool2 : false;\n  var showInlineWarningsAndErrors = (_castBool3 = castBool(window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__)) !== null && _castBool3 !== void 0 ? _castBool3 : true;\n  var hideConsoleLogsInStrictMode = (_castBool4 = castBool(window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__)) !== null && _castBool4 !== void 0 ? _castBool4 : false;\n  var browserTheme = (_castBrowserTheme = castBrowserTheme(window.__REACT_DEVTOOLS_BROWSER_THEME__)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : 'dark';\n  patch({\n    appendComponentStack: appendComponentStack,\n    breakOnConsoleErrors: breakOnConsoleErrors,\n    showInlineWarningsAndErrors: showInlineWarningsAndErrors,\n    hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,\n    browserTheme: browserTheme\n  });\n} // After receiving cached console patch settings from React Native, we set them on window.\n// When the console is initially patched (in renderer.js and hook.js), these values are read.\n// The browser extension (etc.) sets these values on window, but through another method.\n\nfunction writeConsolePatchSettingsToWindow(settings) {\n  window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = settings.appendComponentStack;\n  window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = settings.breakOnConsoleErrors;\n  window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = settings.showInlineWarningsAndErrors;\n  window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = settings.hideConsoleLogsInStrictMode;\n  window.__REACT_DEVTOOLS_BROWSER_THEME__ = settings.browserTheme;\n}\nfunction installConsoleFunctionsToWindow() {\n  window.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__ = {\n    patchConsoleUsingWindowValues: patchConsoleUsingWindowValues,\n    registerRendererWithConsole: registerRenderer\n  };\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/bridge.js\nfunction bridge_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { bridge_typeof = function _typeof(obj) { return typeof obj; }; } else { bridge_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return bridge_typeof(obj); }\n\nfunction bridge_toConsumableArray(arr) { return bridge_arrayWithoutHoles(arr) || bridge_iterableToArray(arr) || bridge_unsupportedIterableToArray(arr) || bridge_nonIterableSpread(); }\n\nfunction bridge_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction bridge_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return bridge_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bridge_arrayLikeToArray(o, minLen); }\n\nfunction bridge_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction bridge_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bridge_arrayLikeToArray(arr); }\n\nfunction bridge_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction bridge_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction bridge_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction bridge_createClass(Constructor, protoProps, staticProps) { if (protoProps) bridge_defineProperties(Constructor.prototype, protoProps); if (staticProps) bridge_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (bridge_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction bridge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar BATCH_DURATION = 100; // This message specifies the version of the DevTools protocol currently supported by the backend,\n// as well as the earliest NPM version (e.g. \"4.13.0\") that protocol is supported by on the frontend.\n// This enables an older frontend to display an upgrade message to users for a newer, unsupported backend.\n\n// Bump protocol version whenever a backwards breaking change is made\n// in the messages sent between BackendBridge and FrontendBridge.\n// This mapping is embedded in both frontend and backend builds.\n//\n// The backend protocol will always be the latest entry in the BRIDGE_PROTOCOL array.\n//\n// When an older frontend connects to a newer backend,\n// the backend can send the minNpmVersion and the frontend can display an NPM upgrade prompt.\n//\n// When a newer frontend connects with an older protocol version,\n// the frontend can use the embedded minNpmVersion/maxNpmVersion values to display a downgrade prompt.\nvar BRIDGE_PROTOCOL = [// This version technically never existed,\n// but a backwards breaking change was added in 4.11,\n// so the safest guess to downgrade the frontend would be to version 4.10.\n{\n  version: 0,\n  minNpmVersion: '\"<4.11.0\"',\n  maxNpmVersion: '\"<4.11.0\"'\n}, // Versions 4.11.x  4.12.x contained the backwards breaking change,\n// but we didn't add the \"fix\" of checking the protocol version until 4.13,\n// so we don't recommend downgrading to 4.11 or 4.12.\n{\n  version: 1,\n  minNpmVersion: '4.13.0',\n  maxNpmVersion: '4.21.0'\n}, // Version 2 adds a StrictMode-enabled and supports-StrictMode bits to add-root operation.\n{\n  version: 2,\n  minNpmVersion: '4.22.0',\n  maxNpmVersion: null\n}];\nvar currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];\n\nvar Bridge = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Bridge, _EventEmitter);\n\n  var _super = _createSuper(Bridge);\n\n  function Bridge(wall) {\n    var _this;\n\n    bridge_classCallCheck(this, Bridge);\n\n    _this = _super.call(this);\n\n    bridge_defineProperty(_assertThisInitialized(_this), \"_isShutdown\", false);\n\n    bridge_defineProperty(_assertThisInitialized(_this), \"_messageQueue\", []);\n\n    bridge_defineProperty(_assertThisInitialized(_this), \"_timeoutID\", null);\n\n    bridge_defineProperty(_assertThisInitialized(_this), \"_wallUnlisten\", null);\n\n    bridge_defineProperty(_assertThisInitialized(_this), \"_flush\", function () {\n      // This method is used after the bridge is marked as destroyed in shutdown sequence,\n      // so we do not bail out if the bridge marked as destroyed.\n      // It is a private method that the bridge ensures is only called at the right times.\n      if (_this._timeoutID !== null) {\n        clearTimeout(_this._timeoutID);\n        _this._timeoutID = null;\n      }\n\n      if (_this._messageQueue.length) {\n        for (var i = 0; i < _this._messageQueue.length; i += 2) {\n          var _this$_wall;\n\n          (_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(bridge_toConsumableArray(_this._messageQueue[i + 1])));\n        }\n\n        _this._messageQueue.length = 0; // Check again for queued messages in BATCH_DURATION ms. This will keep\n        // flushing in a loop as long as messages continue to be added. Once no\n        // more are, the timer expires.\n\n        _this._timeoutID = setTimeout(_this._flush, BATCH_DURATION);\n      }\n    });\n\n    bridge_defineProperty(_assertThisInitialized(_this), \"overrideValueAtPath\", function (_ref) {\n      var id = _ref.id,\n          path = _ref.path,\n          rendererID = _ref.rendererID,\n          type = _ref.type,\n          value = _ref.value;\n\n      switch (type) {\n        case 'context':\n          _this.send('overrideContext', {\n            id: id,\n            path: path,\n            rendererID: rendererID,\n            wasForwarded: true,\n            value: value\n          });\n\n          break;\n\n        case 'hooks':\n          _this.send('overrideHookState', {\n            id: id,\n            path: path,\n            rendererID: rendererID,\n            wasForwarded: true,\n            value: value\n          });\n\n          break;\n\n        case 'props':\n          _this.send('overrideProps', {\n            id: id,\n            path: path,\n            rendererID: rendererID,\n            wasForwarded: true,\n            value: value\n          });\n\n          break;\n\n        case 'state':\n          _this.send('overrideState', {\n            id: id,\n            path: path,\n            rendererID: rendererID,\n            wasForwarded: true,\n            value: value\n          });\n\n          break;\n      }\n    });\n\n    _this._wall = wall;\n    _this._wallUnlisten = wall.listen(function (message) {\n      if (message && message.event) {\n        _assertThisInitialized(_this).emit(message.event, message.payload);\n      }\n    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.\n    // We do this because React Native embeds the React DevTools backend,\n    // but cannot control which version of the frontend users use.\n\n    _this.addListener('overrideValueAtPath', _this.overrideValueAtPath);\n\n    return _this;\n  } // Listening directly to the wall isn't advised.\n  // It can be used to listen for legacy (v3) messages (since they use a different format).\n\n\n  bridge_createClass(Bridge, [{\n    key: \"send\",\n    value: function send(event) {\n      if (this._isShutdown) {\n        console.warn(\"Cannot send message \\\"\".concat(event, \"\\\" through a Bridge that has been shutdown.\"));\n        return;\n      } // When we receive a message:\n      // - we add it to our queue of messages to be sent\n      // - if there hasn't been a message recently, we set a timer for 0 ms in\n      //   the future, allowing all messages created in the same tick to be sent\n      //   together\n      // - if there *has* been a message flushed in the last BATCH_DURATION ms\n      //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will\n      //   be set, and we'll simply add to the queue and wait for that\n\n\n      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        payload[_key - 1] = arguments[_key];\n      }\n\n      this._messageQueue.push(event, payload);\n\n      if (!this._timeoutID) {\n        this._timeoutID = setTimeout(this._flush, 0);\n      }\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      if (this._isShutdown) {\n        console.warn('Bridge was already shutdown.');\n        return;\n      } // Queue the shutdown outgoing message for subscribers.\n\n\n      this.emit('shutdown');\n      this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.\n\n      this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.\n      // $FlowFixMe[cannot-write] This property is not writable.\n\n      this.addListener = function () {}; // $FlowFixMe[cannot-write] This property is not writable.\n\n\n      this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.\n      // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.\n\n\n      this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.\n\n      var wallUnlisten = this._wallUnlisten;\n\n      if (wallUnlisten) {\n        wallUnlisten();\n      } // Synchronously flush all queued outgoing messages.\n      // At this step the subscribers' code may run in this call stack.\n\n\n      do {\n        this._flush();\n      } while (this._messageQueue.length); // Make sure once again that there is no dangling timer.\n\n\n      if (this._timeoutID !== null) {\n        clearTimeout(this._timeoutID);\n        this._timeoutID = null;\n      }\n    }\n  }, {\n    key: \"wall\",\n    get: function get() {\n      return this._wall;\n    }\n  }]);\n\n  return Bridge;\n}(EventEmitter);\n\n/* harmony default export */ const src_bridge = (Bridge);\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/agent.js\nfunction agent_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { agent_typeof = function _typeof(obj) { return typeof obj; }; } else { agent_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return agent_typeof(obj); }\n\nfunction agent_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction agent_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction agent_createClass(Constructor, protoProps, staticProps) { if (protoProps) agent_defineProperties(Constructor.prototype, protoProps); if (staticProps) agent_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction agent_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) agent_setPrototypeOf(subClass, superClass); }\n\nfunction agent_setPrototypeOf(o, p) { agent_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return agent_setPrototypeOf(o, p); }\n\nfunction agent_createSuper(Derived) { var hasNativeReflectConstruct = agent_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = agent_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = agent_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return agent_possibleConstructorReturn(this, result); }; }\n\nfunction agent_possibleConstructorReturn(self, call) { if (call && (agent_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return agent_assertThisInitialized(self); }\n\nfunction agent_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction agent_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction agent_getPrototypeOf(o) { agent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return agent_getPrototypeOf(o); }\n\nfunction agent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\nvar debug = function debug(methodName) {\n  if (__DEBUG__) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, [\"%cAgent %c\".concat(methodName), 'color: purple; font-weight: bold;', 'font-weight: bold;'].concat(args));\n  }\n};\n\nvar Agent = /*#__PURE__*/function (_EventEmitter) {\n  agent_inherits(Agent, _EventEmitter);\n\n  var _super = agent_createSuper(Agent);\n\n  function Agent(bridge) {\n    var _this;\n\n    agent_classCallCheck(this, Agent);\n\n    _this = _super.call(this);\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"_isProfiling\", false);\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"_recordChangeDescriptions\", false);\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"_rendererInterfaces\", {});\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"_persistedSelection\", null);\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"_persistedSelectionMatch\", null);\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"_traceUpdatesEnabled\", false);\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"clearErrorsAndWarnings\", function (_ref) {\n      var rendererID = _ref.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n      } else {\n        renderer.clearErrorsAndWarnings();\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"clearErrorsForFiberID\", function (_ref2) {\n      var id = _ref2.id,\n          rendererID = _ref2.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n      } else {\n        renderer.clearErrorsForFiberID(id);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"clearWarningsForFiberID\", function (_ref3) {\n      var id = _ref3.id,\n          rendererID = _ref3.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n      } else {\n        renderer.clearWarningsForFiberID(id);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"copyElementPath\", function (_ref4) {\n      var id = _ref4.id,\n          path = _ref4.path,\n          rendererID = _ref4.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        var value = renderer.getSerializedElementValueByPath(id, path);\n\n        if (value != null) {\n          _this._bridge.send('saveToClipboard', value);\n        } else {\n          console.warn(\"Unable to obtain serialized value for element \\\"\".concat(id, \"\\\"\"));\n        }\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"deletePath\", function (_ref5) {\n      var hookID = _ref5.hookID,\n          id = _ref5.id,\n          path = _ref5.path,\n          rendererID = _ref5.rendererID,\n          type = _ref5.type;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.deletePath(type, id, hookID, path);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"getBackendVersion\", function () {\n      var version = \"4.28.5-ef8a840bd\";\n\n      if (version) {\n        _this._bridge.send('backendVersion', version);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"getBridgeProtocol\", function () {\n      _this._bridge.send('bridgeProtocol', currentBridgeProtocol);\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"getProfilingData\", function (_ref6) {\n      var rendererID = _ref6.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n      }\n\n      _this._bridge.send('profilingData', renderer.getProfilingData());\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"getProfilingStatus\", function () {\n      _this._bridge.send('profilingStatus', _this._isProfiling);\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"getOwnersList\", function (_ref7) {\n      var id = _ref7.id,\n          rendererID = _ref7.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        var owners = renderer.getOwnersList(id);\n\n        _this._bridge.send('ownersList', {\n          id: id,\n          owners: owners\n        });\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"inspectElement\", function (_ref8) {\n      var forceFullData = _ref8.forceFullData,\n          id = _ref8.id,\n          path = _ref8.path,\n          rendererID = _ref8.rendererID,\n          requestID = _ref8.requestID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        _this._bridge.send('inspectedElement', renderer.inspectElement(requestID, id, path, forceFullData)); // When user selects an element, stop trying to restore the selection,\n        // and instead remember the current selection for the next reload.\n\n\n        if (_this._persistedSelectionMatch === null || _this._persistedSelectionMatch.id !== id) {\n          _this._persistedSelection = null;\n          _this._persistedSelectionMatch = null;\n          renderer.setTrackedPath(null);\n\n          _this._throttledPersistSelection(rendererID, id);\n        } // TODO: If there was a way to change the selected DOM element\n        // in native Elements tab without forcing a switch to it, we'd do it here.\n        // For now, it doesn't seem like there is a way to do that:\n        // https://github.com/bvaughn/react-devtools-experimental/issues/102\n        // (Setting $0 doesn't work, and calling inspect() switches the tab.)\n\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"logElementToConsole\", function (_ref9) {\n      var id = _ref9.id,\n          rendererID = _ref9.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.logElementToConsole(id);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"overrideError\", function (_ref10) {\n      var id = _ref10.id,\n          rendererID = _ref10.rendererID,\n          forceError = _ref10.forceError;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.overrideError(id, forceError);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"overrideSuspense\", function (_ref11) {\n      var id = _ref11.id,\n          rendererID = _ref11.rendererID,\n          forceFallback = _ref11.forceFallback;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.overrideSuspense(id, forceFallback);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"overrideValueAtPath\", function (_ref12) {\n      var hookID = _ref12.hookID,\n          id = _ref12.id,\n          path = _ref12.path,\n          rendererID = _ref12.rendererID,\n          type = _ref12.type,\n          value = _ref12.value;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.overrideValueAtPath(type, id, hookID, path, value);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"overrideContext\", function (_ref13) {\n      var id = _ref13.id,\n          path = _ref13.path,\n          rendererID = _ref13.rendererID,\n          wasForwarded = _ref13.wasForwarded,\n          value = _ref13.value;\n\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        _this.overrideValueAtPath({\n          id: id,\n          path: path,\n          rendererID: rendererID,\n          type: 'context',\n          value: value\n        });\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"overrideHookState\", function (_ref14) {\n      var id = _ref14.id,\n          hookID = _ref14.hookID,\n          path = _ref14.path,\n          rendererID = _ref14.rendererID,\n          wasForwarded = _ref14.wasForwarded,\n          value = _ref14.value;\n\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        _this.overrideValueAtPath({\n          id: id,\n          path: path,\n          rendererID: rendererID,\n          type: 'hooks',\n          value: value\n        });\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"overrideProps\", function (_ref15) {\n      var id = _ref15.id,\n          path = _ref15.path,\n          rendererID = _ref15.rendererID,\n          wasForwarded = _ref15.wasForwarded,\n          value = _ref15.value;\n\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        _this.overrideValueAtPath({\n          id: id,\n          path: path,\n          rendererID: rendererID,\n          type: 'props',\n          value: value\n        });\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"overrideState\", function (_ref16) {\n      var id = _ref16.id,\n          path = _ref16.path,\n          rendererID = _ref16.rendererID,\n          wasForwarded = _ref16.wasForwarded,\n          value = _ref16.value;\n\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        _this.overrideValueAtPath({\n          id: id,\n          path: path,\n          rendererID: rendererID,\n          type: 'state',\n          value: value\n        });\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"reloadAndProfile\", function (recordChangeDescriptions) {\n      sessionStorageSetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, 'true');\n      sessionStorageSetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, recordChangeDescriptions ? 'true' : 'false'); // This code path should only be hit if the shell has explicitly told the Store that it supports profiling.\n      // In that case, the shell must also listen for this specific message to know when it needs to reload the app.\n      // The agent can't do this in a way that is renderer agnostic.\n\n      _this._bridge.send('reloadAppForProfiling');\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"renamePath\", function (_ref17) {\n      var hookID = _ref17.hookID,\n          id = _ref17.id,\n          newPath = _ref17.newPath,\n          oldPath = _ref17.oldPath,\n          rendererID = _ref17.rendererID,\n          type = _ref17.type;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.renamePath(type, id, hookID, oldPath, newPath);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"setTraceUpdatesEnabled\", function (traceUpdatesEnabled) {\n      _this._traceUpdatesEnabled = traceUpdatesEnabled;\n      toggleEnabled(traceUpdatesEnabled);\n\n      for (var rendererID in _this._rendererInterfaces) {\n        var renderer = _this._rendererInterfaces[rendererID];\n        renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"syncSelectionFromNativeElementsPanel\", function () {\n      var target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;\n\n      if (target == null) {\n        return;\n      }\n\n      _this.selectNode(target);\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"shutdown\", function () {\n      // Clean up the overlay if visible, and associated events.\n      _this.emit('shutdown');\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"startProfiling\", function (recordChangeDescriptions) {\n      _this._recordChangeDescriptions = recordChangeDescriptions;\n      _this._isProfiling = true;\n\n      for (var rendererID in _this._rendererInterfaces) {\n        var renderer = _this._rendererInterfaces[rendererID];\n        renderer.startProfiling(recordChangeDescriptions);\n      }\n\n      _this._bridge.send('profilingStatus', _this._isProfiling);\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"stopProfiling\", function () {\n      _this._isProfiling = false;\n      _this._recordChangeDescriptions = false;\n\n      for (var rendererID in _this._rendererInterfaces) {\n        var renderer = _this._rendererInterfaces[rendererID];\n        renderer.stopProfiling();\n      }\n\n      _this._bridge.send('profilingStatus', _this._isProfiling);\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"stopInspectingNative\", function (selected) {\n      _this._bridge.send('stopInspectingNative', selected);\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"storeAsGlobal\", function (_ref18) {\n      var count = _ref18.count,\n          id = _ref18.id,\n          path = _ref18.path,\n          rendererID = _ref18.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.storeAsGlobal(id, path, count);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"updateConsolePatchSettings\", function (_ref19) {\n      var appendComponentStack = _ref19.appendComponentStack,\n          breakOnConsoleErrors = _ref19.breakOnConsoleErrors,\n          showInlineWarningsAndErrors = _ref19.showInlineWarningsAndErrors,\n          hideConsoleLogsInStrictMode = _ref19.hideConsoleLogsInStrictMode,\n          browserTheme = _ref19.browserTheme;\n      // If the frontend preferences have changed,\n      // or in the case of React Native- if the backend is just finding out the preferences-\n      // then reinstall the console overrides.\n      // It's safe to call `patchConsole` multiple times.\n      patch({\n        appendComponentStack: appendComponentStack,\n        breakOnConsoleErrors: breakOnConsoleErrors,\n        showInlineWarningsAndErrors: showInlineWarningsAndErrors,\n        hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,\n        browserTheme: browserTheme\n      });\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"updateComponentFilters\", function (componentFilters) {\n      for (var rendererID in _this._rendererInterfaces) {\n        var renderer = _this._rendererInterfaces[rendererID];\n        renderer.updateComponentFilters(componentFilters);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"viewAttributeSource\", function (_ref20) {\n      var id = _ref20.id,\n          path = _ref20.path,\n          rendererID = _ref20.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.prepareViewAttributeSource(id, path);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"viewElementSource\", function (_ref21) {\n      var id = _ref21.id,\n          rendererID = _ref21.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.prepareViewElementSource(id);\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"onTraceUpdates\", function (nodes) {\n      _this.emit('traceUpdates', nodes);\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"onFastRefreshScheduled\", function () {\n      if (__DEBUG__) {\n        debug('onFastRefreshScheduled');\n      }\n\n      _this._bridge.send('fastRefreshScheduled');\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"onHookOperations\", function (operations) {\n      if (__DEBUG__) {\n        debug('onHookOperations', \"(\".concat(operations.length, \") [\").concat(operations.join(', '), \"]\"));\n      } // TODO:\n      // The chrome.runtime does not currently support transferables; it forces JSON serialization.\n      // See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134\n      //\n      // Regarding transferables, the postMessage doc states:\n      // If the ownership of an object is transferred, it becomes unusable (neutered)\n      // in the context it was sent from and becomes available only to the worker it was sent to.\n      //\n      // Even though Chrome is eventually JSON serializing the array buffer,\n      // using the transferable approach also sometimes causes it to throw:\n      //   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.\n      //\n      // See bug https://github.com/bvaughn/react-devtools-experimental/issues/25\n      //\n      // The Store has a fallback in place that parses the message as JSON if the type isn't an array.\n      // For now the simplest fix seems to be to not transfer the array.\n      // This will negatively impact performance on Firefox so it's unfortunate,\n      // but until we're able to fix the Chrome error mentioned above, it seems necessary.\n      //\n      // this._bridge.send('operations', operations, [operations.buffer]);\n\n\n      _this._bridge.send('operations', operations);\n\n      if (_this._persistedSelection !== null) {\n        var rendererID = operations[0];\n\n        if (_this._persistedSelection.rendererID === rendererID) {\n          // Check if we can select a deeper match for the persisted selection.\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n          } else {\n            var prevMatch = _this._persistedSelectionMatch;\n            var nextMatch = renderer.getBestMatchForTrackedPath();\n            _this._persistedSelectionMatch = nextMatch;\n            var prevMatchID = prevMatch !== null ? prevMatch.id : null;\n            var nextMatchID = nextMatch !== null ? nextMatch.id : null;\n\n            if (prevMatchID !== nextMatchID) {\n              if (nextMatchID !== null) {\n                // We moved forward, unlocking a deeper node.\n                _this._bridge.send('selectFiber', nextMatchID);\n              }\n            }\n\n            if (nextMatch !== null && nextMatch.isFullMatch) {\n              // We've just unlocked the innermost selected node.\n              // There's no point tracking it further.\n              _this._persistedSelection = null;\n              _this._persistedSelectionMatch = null;\n              renderer.setTrackedPath(null);\n            }\n          }\n        }\n      }\n    });\n\n    agent_defineProperty(agent_assertThisInitialized(_this), \"_throttledPersistSelection\", lodash_throttle_default()(function (rendererID, id) {\n      // This is throttled, so both renderer and selected ID\n      // might not be available by the time we read them.\n      // This is why we need the defensive checks here.\n      var renderer = _this._rendererInterfaces[rendererID];\n      var path = renderer != null ? renderer.getPathForElement(id) : null;\n\n      if (path !== null) {\n        sessionStorageSetItem(SESSION_STORAGE_LAST_SELECTION_KEY, JSON.stringify({\n          rendererID: rendererID,\n          path: path\n        }));\n      } else {\n        sessionStorageRemoveItem(SESSION_STORAGE_LAST_SELECTION_KEY);\n      }\n    }, 1000));\n\n    if (sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === 'true') {\n      _this._recordChangeDescriptions = sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === 'true';\n      _this._isProfiling = true;\n      sessionStorageRemoveItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY);\n      sessionStorageRemoveItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY);\n    }\n\n    var persistedSelectionString = sessionStorageGetItem(SESSION_STORAGE_LAST_SELECTION_KEY);\n\n    if (persistedSelectionString != null) {\n      _this._persistedSelection = JSON.parse(persistedSelectionString);\n    }\n\n    _this._bridge = bridge;\n    bridge.addListener('clearErrorsAndWarnings', _this.clearErrorsAndWarnings);\n    bridge.addListener('clearErrorsForFiberID', _this.clearErrorsForFiberID);\n    bridge.addListener('clearWarningsForFiberID', _this.clearWarningsForFiberID);\n    bridge.addListener('copyElementPath', _this.copyElementPath);\n    bridge.addListener('deletePath', _this.deletePath);\n    bridge.addListener('getBackendVersion', _this.getBackendVersion);\n    bridge.addListener('getBridgeProtocol', _this.getBridgeProtocol);\n    bridge.addListener('getProfilingData', _this.getProfilingData);\n    bridge.addListener('getProfilingStatus', _this.getProfilingStatus);\n    bridge.addListener('getOwnersList', _this.getOwnersList);\n    bridge.addListener('inspectElement', _this.inspectElement);\n    bridge.addListener('logElementToConsole', _this.logElementToConsole);\n    bridge.addListener('overrideError', _this.overrideError);\n    bridge.addListener('overrideSuspense', _this.overrideSuspense);\n    bridge.addListener('overrideValueAtPath', _this.overrideValueAtPath);\n    bridge.addListener('reloadAndProfile', _this.reloadAndProfile);\n    bridge.addListener('renamePath', _this.renamePath);\n    bridge.addListener('setTraceUpdatesEnabled', _this.setTraceUpdatesEnabled);\n    bridge.addListener('startProfiling', _this.startProfiling);\n    bridge.addListener('stopProfiling', _this.stopProfiling);\n    bridge.addListener('storeAsGlobal', _this.storeAsGlobal);\n    bridge.addListener('syncSelectionFromNativeElementsPanel', _this.syncSelectionFromNativeElementsPanel);\n    bridge.addListener('shutdown', _this.shutdown);\n    bridge.addListener('updateConsolePatchSettings', _this.updateConsolePatchSettings);\n    bridge.addListener('updateComponentFilters', _this.updateComponentFilters);\n    bridge.addListener('viewAttributeSource', _this.viewAttributeSource);\n    bridge.addListener('viewElementSource', _this.viewElementSource); // Temporarily support older standalone front-ends sending commands to newer embedded backends.\n    // We do this because React Native embeds the React DevTools backend,\n    // but cannot control which version of the frontend users use.\n\n    bridge.addListener('overrideContext', _this.overrideContext);\n    bridge.addListener('overrideHookState', _this.overrideHookState);\n    bridge.addListener('overrideProps', _this.overrideProps);\n    bridge.addListener('overrideState', _this.overrideState);\n\n    if (_this._isProfiling) {\n      bridge.send('profilingStatus', true);\n    } // Send the Bridge protocol and backend versions, after initialization, in case the frontend has already requested it.\n    // The Store may be instantiated beore the agent.\n\n\n    var _version = \"4.28.5-ef8a840bd\";\n\n    if (_version) {\n      _this._bridge.send('backendVersion', _version);\n    }\n\n    _this._bridge.send('bridgeProtocol', currentBridgeProtocol); // Notify the frontend if the backend supports the Storage API (e.g. localStorage).\n    // If not, features like reload-and-profile will not work correctly and must be disabled.\n\n\n    var isBackendStorageAPISupported = false;\n\n    try {\n      localStorage.getItem('test');\n      isBackendStorageAPISupported = true;\n    } catch (error) {}\n\n    bridge.send('isBackendStorageAPISupported', isBackendStorageAPISupported);\n    bridge.send('isSynchronousXHRSupported', isSynchronousXHRSupported());\n    setupHighlighter(bridge, agent_assertThisInitialized(_this));\n    TraceUpdates_initialize(agent_assertThisInitialized(_this));\n    return _this;\n  }\n\n  agent_createClass(Agent, [{\n    key: \"getInstanceAndStyle\",\n    value: function getInstanceAndStyle(_ref22) {\n      var id = _ref22.id,\n          rendererID = _ref22.rendererID;\n      var renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n        return null;\n      }\n\n      return renderer.getInstanceAndStyle(id);\n    }\n  }, {\n    key: \"getBestMatchingRendererInterface\",\n    value: function getBestMatchingRendererInterface(node) {\n      var bestMatch = null;\n\n      for (var rendererID in this._rendererInterfaces) {\n        var renderer = this._rendererInterfaces[rendererID];\n        var fiber = renderer.getFiberForNative(node);\n\n        if (fiber !== null) {\n          // check if fiber.stateNode is matching the original hostInstance\n          if (fiber.stateNode === node) {\n            return renderer;\n          } else if (bestMatch === null) {\n            bestMatch = renderer;\n          }\n        }\n      } // if an exact match is not found, return the first valid renderer as fallback\n\n\n      return bestMatch;\n    }\n  }, {\n    key: \"getIDForNode\",\n    value: function getIDForNode(node) {\n      var rendererInterface = this.getBestMatchingRendererInterface(node);\n\n      if (rendererInterface != null) {\n        try {\n          return rendererInterface.getFiberIDForNative(node, true);\n        } catch (error) {// Some old React versions might throw if they can't find a match.\n          // If so we should ignore it...\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"selectNode\",\n    value: function selectNode(target) {\n      var id = this.getIDForNode(target);\n\n      if (id !== null) {\n        this._bridge.send('selectFiber', id);\n      }\n    }\n  }, {\n    key: \"setRendererInterface\",\n    value: function setRendererInterface(rendererID, rendererInterface) {\n      this._rendererInterfaces[rendererID] = rendererInterface;\n\n      if (this._isProfiling) {\n        rendererInterface.startProfiling(this._recordChangeDescriptions);\n      }\n\n      rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled); // When the renderer is attached, we need to tell it whether\n      // we remember the previous selection that we'd like to restore.\n      // It'll start tracking mounts for matches to the last selection path.\n\n      var selection = this._persistedSelection;\n\n      if (selection !== null && selection.rendererID === rendererID) {\n        rendererInterface.setTrackedPath(selection.path);\n      }\n    }\n  }, {\n    key: \"onUnsupportedRenderer\",\n    value: function onUnsupportedRenderer(rendererID) {\n      this._bridge.send('unsupportedRendererVersion', rendererID);\n    }\n  }, {\n    key: \"rendererInterfaces\",\n    get: function get() {\n      return this._rendererInterfaces;\n    }\n  }]);\n\n  return Agent;\n}(EventEmitter);\n\n\n;// CONCATENATED MODULE: ../react-devtools-shared/src/hook.js\nfunction hook_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { hook_typeof = function _typeof(obj) { return typeof obj; }; } else { hook_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return hook_typeof(obj); }\n\nfunction hook_toConsumableArray(arr) { return hook_arrayWithoutHoles(arr) || hook_iterableToArray(arr) || hook_unsupportedIterableToArray(arr) || hook_nonIterableSpread(); }\n\nfunction hook_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction hook_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return hook_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hook_arrayLikeToArray(o, minLen); }\n\nfunction hook_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction hook_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return hook_arrayLikeToArray(arr); }\n\nfunction hook_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Install the hook on window, which is an event emitter.\n * Note: this global hook __REACT_DEVTOOLS_GLOBAL_HOOK__ is a de facto public API.\n * It's especially important to avoid creating direct dependency on the DevTools Backend.\n * That's why we still inline the whole event emitter implementation,\n * the string format implementation, and part of the console implementation here.\n *\n * \n */\nfunction installHook(target) {\n  if (target.hasOwnProperty('__REACT_DEVTOOLS_GLOBAL_HOOK__')) {\n    return null;\n  }\n\n  var targetConsole = console;\n  var targetConsoleMethods = {};\n\n  for (var method in console) {\n    targetConsoleMethods[method] = console[method];\n  }\n\n  function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {\n    targetConsole = targetConsoleForTesting;\n    targetConsoleMethods = {};\n\n    for (var _method in targetConsole) {\n      targetConsoleMethods[_method] = console[_method];\n    }\n  }\n\n  function detectReactBuildType(renderer) {\n    try {\n      if (typeof renderer.version === 'string') {\n        // React DOM Fiber (16+)\n        if (renderer.bundleType > 0) {\n          // This is not a production build.\n          // We are currently only using 0 (PROD) and 1 (DEV)\n          // but might add 2 (PROFILE) in the future.\n          return 'development';\n        } // React 16 uses flat bundles. If we report the bundle as production\n        // version, it means we also minified and envified it ourselves.\n\n\n        return 'production'; // Note: There is still a risk that the CommonJS entry point has not\n        // been envified or uglified. In this case the user would have *both*\n        // development and production bundle, but only the prod one would run.\n        // This would be really bad. We have a separate check for this because\n        // it happens *outside* of the renderer injection. See `checkDCE` below.\n      } // $FlowFixMe[method-unbinding]\n\n\n      var _toString = Function.prototype.toString;\n\n      if (renderer.Mount && renderer.Mount._renderNewRootComponent) {\n        // React DOM Stack\n        var renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent); // Filter out bad results (if that is even possible):\n\n\n        if (renderRootCode.indexOf('function') !== 0) {\n          // Hope for the best if we're not sure.\n          return 'production';\n        } // Check for React DOM Stack < 15.1.0 in development.\n        // If it contains \"storedMeasure\" call, it's wrapped in ReactPerf (DEV only).\n        // This would be true even if it's minified, as method name still matches.\n\n\n        if (renderRootCode.indexOf('storedMeasure') !== -1) {\n          return 'development';\n        } // For other versions (and configurations) it's not so easy.\n        // Let's quickly exclude proper production builds.\n        // If it contains a warning message, it's either a DEV build,\n        // or an PROD build without proper dead code elimination.\n\n\n        if (renderRootCode.indexOf('should be a pure function') !== -1) {\n          // Now how do we tell a DEV build from a bad PROD build?\n          // If we see NODE_ENV, we're going to assume this is a dev build\n          // because most likely it is referring to an empty shim.\n          if (renderRootCode.indexOf('NODE_ENV') !== -1) {\n            return 'development';\n          } // If we see \"development\", we're dealing with an envified DEV build\n          // (such as the official React DEV UMD).\n\n\n          if (renderRootCode.indexOf('development') !== -1) {\n            return 'development';\n          } // I've seen process.env.NODE_ENV !== 'production' being smartly\n          // replaced by `true` in DEV by Webpack. I don't know how that\n          // works but we can safely guard against it because `true` was\n          // never used in the function source since it was written.\n\n\n          if (renderRootCode.indexOf('true') !== -1) {\n            return 'development';\n          } // By now either it is a production build that has not been minified,\n          // or (worse) this is a minified development build using non-standard\n          // environment (e.g. \"staging\"). We're going to look at whether\n          // the function argument name is mangled:\n\n\n          if ( // 0.13 to 15\n          renderRootCode.indexOf('nextElement') !== -1 || // 0.12\n          renderRootCode.indexOf('nextComponent') !== -1) {\n            // We can't be certain whether this is a development build or not,\n            // but it is definitely unminified.\n            return 'unminified';\n          } else {\n            // This is likely a minified development build.\n            return 'development';\n          }\n        } // By now we know that it's envified and dead code elimination worked,\n        // but what if it's still not minified? (Is this even possible?)\n        // Let's check matches for the first argument name.\n\n\n        if ( // 0.13 to 15\n        renderRootCode.indexOf('nextElement') !== -1 || // 0.12\n        renderRootCode.indexOf('nextComponent') !== -1) {\n          return 'unminified';\n        } // Seems like we're using the production version.\n        // However, the branch above is Stack-only so this is 15 or earlier.\n\n\n        return 'outdated';\n      }\n    } catch (err) {// Weird environments may exist.\n      // This code needs a higher fault tolerance\n      // because it runs even with closed DevTools.\n      // TODO: should we catch errors in all injected code, and not just this part?\n    }\n\n    return 'production';\n  }\n\n  function checkDCE(fn) {\n    // This runs for production versions of React.\n    // Needs to be super safe.\n    try {\n      // $FlowFixMe[method-unbinding]\n      var _toString2 = Function.prototype.toString;\n\n      var code = _toString2.call(fn); // This is a string embedded in the passed function under DEV-only\n      // condition. However the function executes only in PROD. Therefore,\n      // if we see it, dead code elimination did not work.\n\n\n      if (code.indexOf('^_^') > -1) {\n        // Remember to report during next injection.\n        hasDetectedBadDCE = true; // Bonus: throw an exception hoping that it gets picked up by a reporting system.\n        // Not synchronously so that it doesn't break the calling code.\n\n        setTimeout(function () {\n          throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://reactjs.org/link/perf-use-production-build');\n        });\n      }\n    } catch (err) {}\n  } // NOTE: KEEP IN SYNC with src/backend/utils.js\n\n\n  function formatWithStyles(inputArgs, style) {\n    if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c\n    typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {\n      return inputArgs;\n    } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)\n\n\n    var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;\n\n    if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {\n      return [\"%c\".concat(inputArgs[0]), style].concat(hook_toConsumableArray(inputArgs.slice(1)));\n    } else {\n      var firstArg = inputArgs.reduce(function (formatStr, elem, i) {\n        if (i > 0) {\n          formatStr += ' ';\n        }\n\n        switch (hook_typeof(elem)) {\n          case 'string':\n          case 'boolean':\n          case 'symbol':\n            return formatStr += '%s';\n\n          case 'number':\n            var formatting = Number.isInteger(elem) ? '%i' : '%f';\n            return formatStr += formatting;\n\n          default:\n            return formatStr += '%o';\n        }\n      }, '%c');\n      return [firstArg, style].concat(hook_toConsumableArray(inputArgs));\n    }\n  }\n\n  var unpatchFn = null; // NOTE: KEEP IN SYNC with src/backend/console.js:patchForStrictMode\n  // This function hides or dims console logs during the initial double renderer\n  // in Strict Mode. We need this function because during initial render,\n  // React and DevTools are connecting and the renderer interface isn't avaiable\n  // and we want to be able to have consistent logging behavior for double logs\n  // during the initial renderer.\n\n  function patchConsoleForInitialRenderInStrictMode(_ref) {\n    var hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode,\n        browserTheme = _ref.browserTheme;\n    var overrideConsoleMethods = ['error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'];\n\n    if (unpatchFn !== null) {\n      // Don't patch twice.\n      return;\n    }\n\n    var originalConsoleMethods = {};\n\n    unpatchFn = function unpatchFn() {\n      for (var _method2 in originalConsoleMethods) {\n        try {\n          targetConsole[_method2] = originalConsoleMethods[_method2];\n        } catch (error) {}\n      }\n    };\n\n    overrideConsoleMethods.forEach(function (method) {\n      try {\n        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method];\n\n        var overrideMethod = function overrideMethod() {\n          if (!hideConsoleLogsInStrictMode) {\n            // Dim the text color of the double logs if we're not\n            // hiding them.\n            var color;\n\n            switch (method) {\n              case 'warn':\n                color = browserTheme === 'light' ? \"rgba(250, 180, 50, 0.75)\" : \"rgba(250, 180, 50, 0.5)\";\n                break;\n\n              case 'error':\n                color = browserTheme === 'light' ? \"rgba(250, 123, 130, 0.75)\" : \"rgba(250, 123, 130, 0.5)\";\n                break;\n\n              case 'log':\n              default:\n                color = browserTheme === 'light' ? \"rgba(125, 125, 125, 0.75)\" : \"rgba(125, 125, 125, 0.5)\";\n                break;\n            }\n\n            if (color) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              originalMethod.apply(void 0, hook_toConsumableArray(formatWithStyles(args, \"color: \".concat(color))));\n            } else {\n              throw Error('Console color is not defined');\n            }\n          }\n        };\n\n        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;\n        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;\n        targetConsole[method] = overrideMethod;\n      } catch (error) {}\n    });\n  } // NOTE: KEEP IN SYNC with src/backend/console.js:unpatchForStrictMode\n\n\n  function unpatchConsoleForInitialRenderInStrictMode() {\n    if (unpatchFn !== null) {\n      unpatchFn();\n      unpatchFn = null;\n    }\n  }\n\n  var uidCounter = 0;\n\n  function inject(renderer) {\n    var id = ++uidCounter;\n    renderers.set(id, renderer);\n    var reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer); // Patching the console enables DevTools to do a few useful things:\n    // * Append component stacks to warnings and error messages\n    // * Disabling or marking logs during a double render in Strict Mode\n    // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)\n    //\n    // Allow patching console early (during injection) to\n    // provide developers with components stacks even if they don't run DevTools.\n\n    if (target.hasOwnProperty('__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__')) {\n      var _target$__REACT_DEVTO = target.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__,\n          registerRendererWithConsole = _target$__REACT_DEVTO.registerRendererWithConsole,\n          patchConsoleUsingWindowValues = _target$__REACT_DEVTO.patchConsoleUsingWindowValues;\n\n      if (typeof registerRendererWithConsole === 'function' && typeof patchConsoleUsingWindowValues === 'function') {\n        registerRendererWithConsole(renderer);\n        patchConsoleUsingWindowValues();\n      }\n    } // If we have just reloaded to profile, we need to inject the renderer interface before the app loads.\n    // Otherwise the renderer won't yet exist and we can skip this step.\n\n\n    var attach = target.__REACT_DEVTOOLS_ATTACH__;\n\n    if (typeof attach === 'function') {\n      var rendererInterface = attach(hook, id, renderer, target);\n      hook.rendererInterfaces.set(id, rendererInterface);\n    }\n\n    hook.emit('renderer', {\n      id: id,\n      renderer: renderer,\n      reactBuildType: reactBuildType\n    });\n    return id;\n  }\n\n  var hasDetectedBadDCE = false;\n\n  function sub(event, fn) {\n    hook.on(event, fn);\n    return function () {\n      return hook.off(event, fn);\n    };\n  }\n\n  function on(event, fn) {\n    if (!listeners[event]) {\n      listeners[event] = [];\n    }\n\n    listeners[event].push(fn);\n  }\n\n  function off(event, fn) {\n    if (!listeners[event]) {\n      return;\n    }\n\n    var index = listeners[event].indexOf(fn);\n\n    if (index !== -1) {\n      listeners[event].splice(index, 1);\n    }\n\n    if (!listeners[event].length) {\n      delete listeners[event];\n    }\n  }\n\n  function emit(event, data) {\n    if (listeners[event]) {\n      listeners[event].map(function (fn) {\n        return fn(data);\n      });\n    }\n  }\n\n  function getFiberRoots(rendererID) {\n    var roots = fiberRoots;\n\n    if (!roots[rendererID]) {\n      roots[rendererID] = new Set();\n    }\n\n    return roots[rendererID];\n  }\n\n  function onCommitFiberUnmount(rendererID, fiber) {\n    var rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handleCommitFiberUnmount(fiber);\n    }\n  }\n\n  function onCommitFiberRoot(rendererID, root, priorityLevel) {\n    var mountedRoots = hook.getFiberRoots(rendererID);\n    var current = root.current;\n    var isKnownRoot = mountedRoots.has(root);\n    var isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.\n\n    if (!isKnownRoot && !isUnmounting) {\n      mountedRoots.add(root);\n    } else if (isKnownRoot && isUnmounting) {\n      mountedRoots.delete(root);\n    }\n\n    var rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handleCommitFiberRoot(root, priorityLevel);\n    }\n  }\n\n  function onPostCommitFiberRoot(rendererID, root) {\n    var rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handlePostCommitFiberRoot(root);\n    }\n  }\n\n  function setStrictMode(rendererID, isStrictMode) {\n    var rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      if (isStrictMode) {\n        rendererInterface.patchConsoleForStrictMode();\n      } else {\n        rendererInterface.unpatchConsoleForStrictMode();\n      }\n    } else {\n      // This should only happen during initial render in the extension before DevTools\n      // finishes its handshake with the injected renderer\n      if (isStrictMode) {\n        var hideConsoleLogsInStrictMode = window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ === true;\n        var browserTheme = window.__REACT_DEVTOOLS_BROWSER_THEME__;\n        patchConsoleForInitialRenderInStrictMode({\n          hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,\n          browserTheme: browserTheme\n        });\n      } else {\n        unpatchConsoleForInitialRenderInStrictMode();\n      }\n    }\n  }\n\n  var openModuleRangesStack = [];\n  var moduleRanges = [];\n\n  function getTopStackFrameString(error) {\n    var frames = error.stack.split('\\n');\n    var frame = frames.length > 1 ? frames[1] : null;\n    return frame;\n  }\n\n  function getInternalModuleRanges() {\n    return moduleRanges;\n  }\n\n  function registerInternalModuleStart(error) {\n    var startStackFrame = getTopStackFrameString(error);\n\n    if (startStackFrame !== null) {\n      openModuleRangesStack.push(startStackFrame);\n    }\n  }\n\n  function registerInternalModuleStop(error) {\n    if (openModuleRangesStack.length > 0) {\n      var startStackFrame = openModuleRangesStack.pop();\n      var stopStackFrame = getTopStackFrameString(error);\n\n      if (stopStackFrame !== null) {\n        moduleRanges.push([startStackFrame, stopStackFrame]);\n      }\n    }\n  } // TODO: More meaningful names for \"rendererInterfaces\" and \"renderers\".\n\n\n  var fiberRoots = {};\n  var rendererInterfaces = new Map();\n  var listeners = {};\n  var renderers = new Map();\n  var backends = new Map();\n  var hook = {\n    rendererInterfaces: rendererInterfaces,\n    listeners: listeners,\n    backends: backends,\n    // Fast Refresh for web relies on this.\n    renderers: renderers,\n    emit: emit,\n    getFiberRoots: getFiberRoots,\n    inject: inject,\n    on: on,\n    off: off,\n    sub: sub,\n    // This is a legacy flag.\n    // React v16 checks the hook for this to ensure DevTools is new enough.\n    supportsFiber: true,\n    // React calls these methods.\n    checkDCE: checkDCE,\n    onCommitFiberUnmount: onCommitFiberUnmount,\n    onCommitFiberRoot: onCommitFiberRoot,\n    onPostCommitFiberRoot: onPostCommitFiberRoot,\n    setStrictMode: setStrictMode,\n    // Schedule Profiler runtime helpers.\n    // These internal React modules to report their own boundaries\n    // which in turn enables the profiler to dim or filter internal frames.\n    getInternalModuleRanges: getInternalModuleRanges,\n    registerInternalModuleStart: registerInternalModuleStart,\n    registerInternalModuleStop: registerInternalModuleStop\n  };\n\n  if (false) {}\n\n  Object.defineProperty(target, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {\n    // This property needs to be configurable for the test environment,\n    // else we won't be able to delete and recreate it between tests.\n    configurable: false,\n    enumerable: false,\n    get: function get() {\n      return hook;\n    }\n  });\n  return hook;\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/utils.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction decorate(object, attr, fn) {\n  var old = object[attr]; // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations\n\n  object[attr] = function (instance) {\n    return fn.call(this, old, arguments);\n  };\n\n  return old;\n}\nfunction decorateMany(source, fns) {\n  var olds = {};\n\n  for (var name in fns) {\n    olds[name] = decorate(source, name, fns[name]);\n  }\n\n  return olds;\n}\nfunction restoreMany(source, olds) {\n  for (var name in olds) {\n    source[name] = olds[name];\n  }\n} // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations\n\nfunction forceUpdate(instance) {\n  if (typeof instance.forceUpdate === 'function') {\n    instance.forceUpdate();\n  } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === 'function') {\n    instance.updater.enqueueForceUpdate(this, function () {}, 'forceUpdate');\n  }\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/renderer.js\nfunction legacy_renderer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction legacy_renderer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { legacy_renderer_ownKeys(Object(source), true).forEach(function (key) { legacy_renderer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { legacy_renderer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction legacy_renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction legacy_renderer_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { legacy_renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { legacy_renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return legacy_renderer_typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\nfunction getData(internalInstance) {\n  var displayName = null;\n  var key = null; // != used deliberately here to catch undefined and null\n\n  if (internalInstance._currentElement != null) {\n    if (internalInstance._currentElement.key) {\n      key = String(internalInstance._currentElement.key);\n    }\n\n    var elementType = internalInstance._currentElement.type;\n\n    if (typeof elementType === 'string') {\n      displayName = elementType;\n    } else if (typeof elementType === 'function') {\n      displayName = getDisplayName(elementType);\n    }\n  }\n\n  return {\n    displayName: displayName,\n    key: key\n  };\n}\n\nfunction getElementType(internalInstance) {\n  // != used deliberately here to catch undefined and null\n  if (internalInstance._currentElement != null) {\n    var elementType = internalInstance._currentElement.type;\n\n    if (typeof elementType === 'function') {\n      var publicInstance = internalInstance.getPublicInstance();\n\n      if (publicInstance !== null) {\n        return types_ElementTypeClass;\n      } else {\n        return types_ElementTypeFunction;\n      }\n    } else if (typeof elementType === 'string') {\n      return ElementTypeHostComponent;\n    }\n  }\n\n  return ElementTypeOtherOrUnknown;\n}\n\nfunction getChildren(internalInstance) {\n  var children = []; // If the parent is a native node without rendered children, but with\n  // multiple string children, then the `element` that gets passed in here is\n  // a plain value -- a string or number.\n\n  if (legacy_renderer_typeof(internalInstance) !== 'object') {// No children\n  } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {// No children\n  } else if (internalInstance._renderedComponent) {\n    var child = internalInstance._renderedComponent;\n\n    if (getElementType(child) !== ElementTypeOtherOrUnknown) {\n      children.push(child);\n    }\n  } else if (internalInstance._renderedChildren) {\n    var renderedChildren = internalInstance._renderedChildren;\n\n    for (var name in renderedChildren) {\n      var _child = renderedChildren[name];\n\n      if (getElementType(_child) !== ElementTypeOtherOrUnknown) {\n        children.push(_child);\n      }\n    }\n  } // Note: we skip the case where children are just strings or numbers\n  // because the new DevTools skips over host text nodes anyway.\n\n\n  return children;\n}\n\nfunction renderer_attach(hook, rendererID, renderer, global) {\n  var idToInternalInstanceMap = new Map();\n  var internalInstanceToIDMap = new WeakMap();\n  var internalInstanceToRootIDMap = new WeakMap();\n  var getInternalIDForNative = null;\n  var findNativeNodeForInternalID;\n\n  var getFiberForNative = function getFiberForNative(node) {\n    // Not implemented.\n    return null;\n  };\n\n  if (renderer.ComponentTree) {\n    getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {\n      var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);\n      return internalInstanceToIDMap.get(internalInstance) || null;\n    };\n\n    findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {\n      var internalInstance = idToInternalInstanceMap.get(id);\n      return renderer.ComponentTree.getNodeFromInstance(internalInstance);\n    };\n\n    getFiberForNative = function getFiberForNative(node) {\n      return renderer.ComponentTree.getClosestInstanceFromNode(node);\n    };\n  } else if (renderer.Mount.getID && renderer.Mount.getNode) {\n    getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {\n      // Not implemented.\n      return null;\n    };\n\n    findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {\n      // Not implemented.\n      return null;\n    };\n  }\n\n  function getDisplayNameForFiberID(id) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n    return internalInstance ? getData(internalInstance).displayName : null;\n  }\n\n  function getID(internalInstance) {\n    if (legacy_renderer_typeof(internalInstance) !== 'object' || internalInstance === null) {\n      throw new Error('Invalid internal instance: ' + internalInstance);\n    }\n\n    if (!internalInstanceToIDMap.has(internalInstance)) {\n      var _id = getUID();\n\n      internalInstanceToIDMap.set(internalInstance, _id);\n      idToInternalInstanceMap.set(_id, internalInstance);\n    }\n\n    return internalInstanceToIDMap.get(internalInstance);\n  }\n\n  function areEqualArrays(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  } // This is shared mutable state that lets us keep track of where we are.\n\n\n  var parentIDStack = [];\n  var oldReconcilerMethods = null;\n\n  if (renderer.Reconciler) {\n    // React 15\n    oldReconcilerMethods = decorateMany(renderer.Reconciler, {\n      mountComponent: function mountComponent(fn, args) {\n        var internalInstance = args[0];\n        var hostContainerInfo = args[3];\n\n        if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        if (hostContainerInfo._topLevelWrapper === undefined) {\n          // SSR\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        var id = getID(internalInstance); // Push the operation.\n\n        var parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;\n        recordMount(internalInstance, id, parentID);\n        parentIDStack.push(id); // Remember the root.\n\n        internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          var result = fn.apply(this, args);\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n      performUpdateIfNecessary: function performUpdateIfNecessary(fn, args) {\n        var internalInstance = args[0];\n\n        if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        var id = getID(internalInstance);\n        parentIDStack.push(id);\n        var prevChildren = getChildren(internalInstance);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          var result = fn.apply(this, args);\n          var nextChildren = getChildren(internalInstance);\n\n          if (!areEqualArrays(prevChildren, nextChildren)) {\n            // Push the operation\n            recordReorder(internalInstance, id, nextChildren);\n          }\n\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n      receiveComponent: function receiveComponent(fn, args) {\n        var internalInstance = args[0];\n\n        if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        var id = getID(internalInstance);\n        parentIDStack.push(id);\n        var prevChildren = getChildren(internalInstance);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          var result = fn.apply(this, args);\n          var nextChildren = getChildren(internalInstance);\n\n          if (!areEqualArrays(prevChildren, nextChildren)) {\n            // Push the operation\n            recordReorder(internalInstance, id, nextChildren);\n          }\n\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n      unmountComponent: function unmountComponent(fn, args) {\n        var internalInstance = args[0];\n\n        if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        var id = getID(internalInstance);\n        parentIDStack.push(id);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          var result = fn.apply(this, args);\n          parentIDStack.pop(); // Push the operation.\n\n          recordUnmount(internalInstance, id);\n          return result;\n        } catch (err) {\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      }\n    });\n  }\n\n  function cleanup() {\n    if (oldReconcilerMethods !== null) {\n      if (renderer.Component) {\n        restoreMany(renderer.Component.Mixin, oldReconcilerMethods);\n      } else {\n        restoreMany(renderer.Reconciler, oldReconcilerMethods);\n      }\n    }\n\n    oldReconcilerMethods = null;\n  }\n\n  function recordMount(internalInstance, id, parentID) {\n    var isRoot = parentID === 0;\n\n    if (__DEBUG__) {\n      console.log('%crecordMount()', 'color: green; font-weight: bold;', id, getData(internalInstance).displayName);\n    }\n\n    if (isRoot) {\n      // TODO Is this right? For all versions?\n      var hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;\n      pushOperation(TREE_OPERATION_ADD);\n      pushOperation(id);\n      pushOperation(ElementTypeRoot);\n      pushOperation(0); // StrictMode compliant?\n\n      pushOperation(0); // Profiling flag\n\n      pushOperation(0); // StrictMode supported?\n\n      pushOperation(hasOwnerMetadata ? 1 : 0);\n    } else {\n      var type = getElementType(internalInstance);\n\n      var _getData = getData(internalInstance),\n          displayName = _getData.displayName,\n          key = _getData.key;\n\n      var ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;\n      var displayNameStringID = getStringID(displayName);\n      var keyStringID = getStringID(key);\n      pushOperation(TREE_OPERATION_ADD);\n      pushOperation(id);\n      pushOperation(type);\n      pushOperation(parentID);\n      pushOperation(ownerID);\n      pushOperation(displayNameStringID);\n      pushOperation(keyStringID);\n    }\n  }\n\n  function recordReorder(internalInstance, id, nextChildren) {\n    pushOperation(TREE_OPERATION_REORDER_CHILDREN);\n    pushOperation(id);\n    var nextChildIDs = nextChildren.map(getID);\n    pushOperation(nextChildIDs.length);\n\n    for (var i = 0; i < nextChildIDs.length; i++) {\n      pushOperation(nextChildIDs[i]);\n    }\n  }\n\n  function recordUnmount(internalInstance, id) {\n    pendingUnmountedIDs.push(id);\n    idToInternalInstanceMap.delete(id);\n  }\n\n  function crawlAndRecordInitialMounts(id, parentID, rootID) {\n    if (__DEBUG__) {\n      console.group('crawlAndRecordInitialMounts() id:', id);\n    }\n\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      internalInstanceToRootIDMap.set(internalInstance, rootID);\n      recordMount(internalInstance, id, parentID);\n      getChildren(internalInstance).forEach(function (child) {\n        return crawlAndRecordInitialMounts(getID(child), id, rootID);\n      });\n    }\n\n    if (__DEBUG__) {\n      console.groupEnd();\n    }\n  }\n\n  function flushInitialOperations() {\n    // Crawl roots though and register any nodes that mounted before we were injected.\n    var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;\n\n    for (var key in roots) {\n      var internalInstance = roots[key];\n\n      var _id2 = getID(internalInstance);\n\n      crawlAndRecordInitialMounts(_id2, 0, _id2);\n      flushPendingEvents(_id2);\n    }\n  }\n\n  var pendingOperations = [];\n  var pendingStringTable = new Map();\n  var pendingUnmountedIDs = [];\n  var pendingStringTableLength = 0;\n  var pendingUnmountedRootID = null;\n\n  function flushPendingEvents(rootID) {\n    if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {\n      return;\n    }\n\n    var numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n    var operations = new Array( // Identify which renderer this update is coming from.\n    2 + // [rendererID, rootFiberID]\n    // How big is the string table?\n    1 + // [stringTableLength]\n    // Then goes the actual string table.\n    pendingStringTableLength + ( // All unmounts are batched in a single message.\n    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations\n    pendingOperations.length); // Identify which renderer this update is coming from.\n    // This enables roots to be mapped to renderers,\n    // Which in turn enables fiber properations, states, and hooks to be inspected.\n\n    var i = 0;\n    operations[i++] = rendererID;\n    operations[i++] = rootID; // Now fill in the string table.\n    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n    operations[i++] = pendingStringTableLength;\n    pendingStringTable.forEach(function (value, key) {\n      operations[i++] = key.length;\n      var encodedKey = utfEncodeString(key);\n\n      for (var j = 0; j < encodedKey.length; j++) {\n        operations[i + j] = encodedKey[j];\n      }\n\n      i += key.length;\n    });\n\n    if (numUnmountIDs > 0) {\n      // All unmounts except roots are batched in a single message.\n      operations[i++] = TREE_OPERATION_REMOVE; // The first number is how many unmounted IDs we're gonna send.\n\n      operations[i++] = numUnmountIDs; // Fill in the unmounts\n\n      for (var j = 0; j < pendingUnmountedIDs.length; j++) {\n        operations[i++] = pendingUnmountedIDs[j];\n      } // The root ID should always be unmounted last.\n\n\n      if (pendingUnmountedRootID !== null) {\n        operations[i] = pendingUnmountedRootID;\n        i++;\n      }\n    } // Fill in the rest of the operations.\n\n\n    for (var _j = 0; _j < pendingOperations.length; _j++) {\n      operations[i + _j] = pendingOperations[_j];\n    }\n\n    i += pendingOperations.length;\n\n    if (__DEBUG__) {\n      printOperationsArray(operations);\n    } // If we've already connected to the frontend, just pass the operations through.\n\n\n    hook.emit('operations', operations);\n    pendingOperations.length = 0;\n    pendingUnmountedIDs = [];\n    pendingUnmountedRootID = null;\n    pendingStringTable.clear();\n    pendingStringTableLength = 0;\n  }\n\n  function pushOperation(op) {\n    if (false) {}\n\n    pendingOperations.push(op);\n  }\n\n  function getStringID(str) {\n    if (str === null) {\n      return 0;\n    }\n\n    var existingID = pendingStringTable.get(str);\n\n    if (existingID !== undefined) {\n      return existingID;\n    }\n\n    var stringID = pendingStringTable.size + 1;\n    pendingStringTable.set(str, stringID); // The string table total length needs to account\n    // both for the string length, and for the array item\n    // that contains the length itself. Hence + 1.\n\n    pendingStringTableLength += str.length + 1;\n    return stringID;\n  }\n\n  var currentlyInspectedElementID = null;\n  var currentlyInspectedPaths = {}; // Track the intersection of currently inspected paths,\n  // so that we can send their data along if the element is re-rendered.\n\n  function mergeInspectedPaths(path) {\n    var current = currentlyInspectedPaths;\n    path.forEach(function (key) {\n      if (!current[key]) {\n        current[key] = {};\n      }\n\n      current = current[key];\n    });\n  }\n\n  function createIsPathAllowed(key) {\n    // This function helps prevent previously-inspected paths from being dehydrated in updates.\n    // This is important to avoid a bad user experience where expanded toggles collapse on update.\n    return function isPathAllowed(path) {\n      var current = currentlyInspectedPaths[key];\n\n      if (!current) {\n        return false;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        current = current[path[i]];\n\n        if (!current) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  } // Fast path props lookup for React Native style editor.\n\n\n  function getInstanceAndStyle(id) {\n    var instance = null;\n    var style = null;\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      instance = internalInstance._instance || null;\n      var element = internalInstance._currentElement;\n\n      if (element != null && element.props != null) {\n        style = element.props.style || null;\n      }\n    }\n\n    return {\n      instance: instance,\n      style: style\n    };\n  }\n\n  function updateSelectedElement(id) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      console.warn(\"Could not find instance with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    switch (getElementType(internalInstance)) {\n      case types_ElementTypeClass:\n        global.$r = internalInstance._instance;\n        break;\n\n      case types_ElementTypeFunction:\n        var element = internalInstance._currentElement;\n\n        if (element == null) {\n          console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        global.$r = {\n          props: element.props,\n          type: element.type\n        };\n        break;\n\n      default:\n        global.$r = null;\n        break;\n    }\n  }\n\n  function storeAsGlobal(id, path, count) {\n    var inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      var value = utils_getInObject(inspectedElement, path);\n      var key = \"$reactTemp\".concat(count);\n      window[key] = value;\n      console.log(key);\n      console.log(value);\n    }\n  }\n\n  function getSerializedElementValueByPath(id, path) {\n    var inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      var valueToCopy = utils_getInObject(inspectedElement, path);\n      return serializeToString(valueToCopy);\n    }\n  }\n\n  function inspectElement(requestID, id, path, forceFullData) {\n    if (forceFullData || currentlyInspectedElementID !== id) {\n      currentlyInspectedElementID = id;\n      currentlyInspectedPaths = {};\n    }\n\n    var inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement === null) {\n      return {\n        id: id,\n        responseID: requestID,\n        type: 'not-found'\n      };\n    }\n\n    if (path !== null) {\n      mergeInspectedPaths(path);\n    } // Any time an inspected element has an update,\n    // we should update the selected $r value as wel.\n    // Do this before dehydration (cleanForBridge).\n\n\n    updateSelectedElement(id);\n    inspectedElement.context = cleanForBridge(inspectedElement.context, createIsPathAllowed('context'));\n    inspectedElement.props = cleanForBridge(inspectedElement.props, createIsPathAllowed('props'));\n    inspectedElement.state = cleanForBridge(inspectedElement.state, createIsPathAllowed('state'));\n    return {\n      id: id,\n      responseID: requestID,\n      type: 'full-data',\n      value: inspectedElement\n    };\n  }\n\n  function inspectElementRaw(id) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      return null;\n    }\n\n    var _getData2 = getData(internalInstance),\n        displayName = _getData2.displayName,\n        key = _getData2.key;\n\n    var type = getElementType(internalInstance);\n    var context = null;\n    var owners = null;\n    var props = null;\n    var state = null;\n    var source = null;\n    var element = internalInstance._currentElement;\n\n    if (element !== null) {\n      props = element.props;\n      source = element._source != null ? element._source : null;\n      var owner = element._owner;\n\n      if (owner) {\n        owners = [];\n\n        while (owner != null) {\n          owners.push({\n            displayName: getData(owner).displayName || 'Unknown',\n            id: getID(owner),\n            key: element.key,\n            type: getElementType(owner)\n          });\n\n          if (owner._currentElement) {\n            owner = owner._currentElement._owner;\n          }\n        }\n      }\n    }\n\n    var publicInstance = internalInstance._instance;\n\n    if (publicInstance != null) {\n      context = publicInstance.context || null;\n      state = publicInstance.state || null;\n    } // Not implemented\n\n\n    var errors = [];\n    var warnings = [];\n    return {\n      id: id,\n      // Does the current renderer support editable hooks and function props?\n      canEditHooks: false,\n      canEditFunctionProps: false,\n      // Does the current renderer support advanced editing interface?\n      canEditHooksAndDeletePaths: false,\n      canEditHooksAndRenamePaths: false,\n      canEditFunctionPropsDeletePaths: false,\n      canEditFunctionPropsRenamePaths: false,\n      // Toggle error boundary did not exist in legacy versions\n      canToggleError: false,\n      isErrored: false,\n      targetErrorBoundaryID: null,\n      // Suspense did not exist in legacy versions\n      canToggleSuspense: false,\n      // Can view component source location.\n      canViewSource: type === types_ElementTypeClass || type === types_ElementTypeFunction,\n      // Only legacy context exists in legacy versions.\n      hasLegacyContext: true,\n      displayName: displayName,\n      type: type,\n      key: key != null ? key : null,\n      // Inspectable properties.\n      context: context,\n      hooks: null,\n      props: props,\n      state: state,\n      errors: errors,\n      warnings: warnings,\n      // List of owners\n      owners: owners,\n      // Location of component in source code.\n      source: source,\n      rootType: null,\n      rendererPackageName: null,\n      rendererVersion: null,\n      plugins: {\n        stylex: null\n      }\n    };\n  }\n\n  function logElementToConsole(id) {\n    var result = inspectElementRaw(id);\n\n    if (result === null) {\n      console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    var supportsGroup = typeof console.groupCollapsed === 'function';\n\n    if (supportsGroup) {\n      console.groupCollapsed(\"[Click to expand] %c<\".concat(result.displayName || 'Component', \" />\"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n      'color: var(--dom-tag-name-color); font-weight: normal;');\n    }\n\n    if (result.props !== null) {\n      console.log('Props:', result.props);\n    }\n\n    if (result.state !== null) {\n      console.log('State:', result.state);\n    }\n\n    if (result.context !== null) {\n      console.log('Context:', result.context);\n    }\n\n    var nativeNode = findNativeNodeForInternalID(id);\n\n    if (nativeNode !== null) {\n      console.log('Node:', nativeNode);\n    }\n\n    if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n      console.log('Right-click any value to save it as a global variable for further inspection.');\n    }\n\n    if (supportsGroup) {\n      console.groupEnd();\n    }\n  }\n\n  function prepareViewAttributeSource(id, path) {\n    var inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      window.$attribute = utils_getInObject(inspectedElement, path);\n    }\n  }\n\n  function prepareViewElementSource(id) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      console.warn(\"Could not find instance with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    var element = internalInstance._currentElement;\n\n    if (element == null) {\n      console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    global.$type = element.type;\n  }\n\n  function deletePath(type, id, hookID, path) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      var publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            deletePathInObject(publicInstance.context, path);\n            forceUpdate(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            var element = internalInstance._currentElement;\n            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {\n              props: copyWithDelete(element.props, path)\n            });\n            forceUpdate(publicInstance);\n            break;\n\n          case 'state':\n            deletePathInObject(publicInstance.state, path);\n            forceUpdate(publicInstance);\n            break;\n        }\n      }\n    }\n  }\n\n  function renamePath(type, id, hookID, oldPath, newPath) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      var publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            renamePathInObject(publicInstance.context, oldPath, newPath);\n            forceUpdate(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            var element = internalInstance._currentElement;\n            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {\n              props: copyWithRename(element.props, oldPath, newPath)\n            });\n            forceUpdate(publicInstance);\n            break;\n\n          case 'state':\n            renamePathInObject(publicInstance.state, oldPath, newPath);\n            forceUpdate(publicInstance);\n            break;\n        }\n      }\n    }\n  }\n\n  function overrideValueAtPath(type, id, hookID, path, value) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      var publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            utils_setInObject(publicInstance.context, path, value);\n            forceUpdate(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            var element = internalInstance._currentElement;\n            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {\n              props: copyWithSet(element.props, path, value)\n            });\n            forceUpdate(publicInstance);\n            break;\n\n          case 'state':\n            utils_setInObject(publicInstance.state, path, value);\n            forceUpdate(publicInstance);\n            break;\n        }\n      }\n    }\n  } // v16+ only features\n\n\n  var getProfilingData = function getProfilingData() {\n    throw new Error('getProfilingData not supported by this renderer');\n  };\n\n  var handleCommitFiberRoot = function handleCommitFiberRoot() {\n    throw new Error('handleCommitFiberRoot not supported by this renderer');\n  };\n\n  var handleCommitFiberUnmount = function handleCommitFiberUnmount() {\n    throw new Error('handleCommitFiberUnmount not supported by this renderer');\n  };\n\n  var handlePostCommitFiberRoot = function handlePostCommitFiberRoot() {\n    throw new Error('handlePostCommitFiberRoot not supported by this renderer');\n  };\n\n  var overrideError = function overrideError() {\n    throw new Error('overrideError not supported by this renderer');\n  };\n\n  var overrideSuspense = function overrideSuspense() {\n    throw new Error('overrideSuspense not supported by this renderer');\n  };\n\n  var startProfiling = function startProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.\n  };\n\n  var stopProfiling = function stopProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.\n  };\n\n  function getBestMatchForTrackedPath() {\n    // Not implemented.\n    return null;\n  }\n\n  function getPathForElement(id) {\n    // Not implemented.\n    return null;\n  }\n\n  function updateComponentFilters(componentFilters) {// Not implemented.\n  }\n\n  function setTraceUpdatesEnabled(enabled) {// Not implemented.\n  }\n\n  function setTrackedPath(path) {// Not implemented.\n  }\n\n  function getOwnersList(id) {\n    // Not implemented.\n    return null;\n  }\n\n  function clearErrorsAndWarnings() {// Not implemented\n  }\n\n  function clearErrorsForFiberID(id) {// Not implemented\n  }\n\n  function clearWarningsForFiberID(id) {// Not implemented\n  }\n\n  function patchConsoleForStrictMode() {}\n\n  function unpatchConsoleForStrictMode() {}\n\n  function hasFiberWithId(id) {\n    return idToInternalInstanceMap.has(id);\n  }\n\n  return {\n    clearErrorsAndWarnings: clearErrorsAndWarnings,\n    clearErrorsForFiberID: clearErrorsForFiberID,\n    clearWarningsForFiberID: clearWarningsForFiberID,\n    cleanup: cleanup,\n    getSerializedElementValueByPath: getSerializedElementValueByPath,\n    deletePath: deletePath,\n    flushInitialOperations: flushInitialOperations,\n    getBestMatchForTrackedPath: getBestMatchForTrackedPath,\n    getDisplayNameForFiberID: getDisplayNameForFiberID,\n    getFiberForNative: getFiberForNative,\n    getFiberIDForNative: getInternalIDForNative,\n    getInstanceAndStyle: getInstanceAndStyle,\n    findNativeNodesForFiberID: function findNativeNodesForFiberID(id) {\n      var nativeNode = findNativeNodeForInternalID(id);\n      return nativeNode == null ? null : [nativeNode];\n    },\n    getOwnersList: getOwnersList,\n    getPathForElement: getPathForElement,\n    getProfilingData: getProfilingData,\n    handleCommitFiberRoot: handleCommitFiberRoot,\n    handleCommitFiberUnmount: handleCommitFiberUnmount,\n    handlePostCommitFiberRoot: handlePostCommitFiberRoot,\n    hasFiberWithId: hasFiberWithId,\n    inspectElement: inspectElement,\n    logElementToConsole: logElementToConsole,\n    overrideError: overrideError,\n    overrideSuspense: overrideSuspense,\n    overrideValueAtPath: overrideValueAtPath,\n    renamePath: renamePath,\n    patchConsoleForStrictMode: patchConsoleForStrictMode,\n    prepareViewAttributeSource: prepareViewAttributeSource,\n    prepareViewElementSource: prepareViewElementSource,\n    renderer: renderer,\n    setTraceUpdatesEnabled: setTraceUpdatesEnabled,\n    setTrackedPath: setTrackedPath,\n    startProfiling: startProfiling,\n    stopProfiling: stopProfiling,\n    storeAsGlobal: storeAsGlobal,\n    unpatchConsoleForStrictMode: unpatchConsoleForStrictMode,\n    updateComponentFilters: updateComponentFilters\n  };\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/index.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n// this is the backend that is compatible with all older React versions\nfunction isMatchingRender(version) {\n  return !hasAssignedBackend(version);\n}\n\nfunction initBackend(hook, agent, global) {\n  if (hook == null) {\n    // DevTools didn't get injected into this page (maybe b'c of the contentType).\n    return function () {};\n  }\n\n  var subs = [hook.sub('renderer-attached', function (_ref) {\n    var id = _ref.id,\n        renderer = _ref.renderer,\n        rendererInterface = _ref.rendererInterface;\n    agent.setRendererInterface(id, rendererInterface); // Now that the Store and the renderer interface are connected,\n    // it's time to flush the pending operation codes to the frontend.\n\n    rendererInterface.flushInitialOperations();\n  }), hook.sub('unsupported-renderer-version', function (id) {\n    agent.onUnsupportedRenderer(id);\n  }), hook.sub('fastRefreshScheduled', agent.onFastRefreshScheduled), hook.sub('operations', agent.onHookOperations), hook.sub('traceUpdates', agent.onTraceUpdates) // TODO Add additional subscriptions required for profiling mode\n  ];\n\n  var attachRenderer = function attachRenderer(id, renderer) {\n    // only attach if the renderer is compatible with the current version of the backend\n    if (!isMatchingRender(renderer.reconcilerVersion || renderer.version)) {\n      return;\n    }\n\n    var rendererInterface = hook.rendererInterfaces.get(id); // Inject any not-yet-injected renderers (if we didn't reload-and-profile)\n\n    if (rendererInterface == null) {\n      if (typeof renderer.findFiberByHostInstance === 'function') {\n        // react-reconciler v16+\n        rendererInterface = attach(hook, id, renderer, global);\n      } else if (renderer.ComponentTree) {\n        // react-dom v15\n        rendererInterface = renderer_attach(hook, id, renderer, global);\n      } else {// Older react-dom or other unsupported renderer version\n      }\n\n      if (rendererInterface != null) {\n        hook.rendererInterfaces.set(id, rendererInterface);\n      }\n    } // Notify the DevTools frontend about new renderers.\n    // This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).\n\n\n    if (rendererInterface != null) {\n      hook.emit('renderer-attached', {\n        id: id,\n        renderer: renderer,\n        rendererInterface: rendererInterface\n      });\n    } else {\n      hook.emit('unsupported-renderer-version', id);\n    }\n  }; // Connect renderers that have already injected themselves.\n\n\n  hook.renderers.forEach(function (renderer, id) {\n    attachRenderer(id, renderer);\n  }); // Connect any new renderers that injected themselves.\n\n  subs.push(hook.sub('renderer', function (_ref2) {\n    var id = _ref2.id,\n        renderer = _ref2.renderer;\n    attachRenderer(id, renderer);\n  }));\n  hook.emit('react-devtools', agent);\n  hook.reactDevtoolsAgent = agent;\n\n  var onAgentShutdown = function onAgentShutdown() {\n    subs.forEach(function (fn) {\n      return fn();\n    });\n    hook.rendererInterfaces.forEach(function (rendererInterface) {\n      rendererInterface.cleanup();\n    });\n    hook.reactDevtoolsAgent = null;\n  };\n\n  agent.addListener('shutdown', onAgentShutdown);\n  subs.push(function () {\n    agent.removeListener('shutdown', onAgentShutdown);\n  });\n  return function () {\n    subs.forEach(function (fn) {\n      return fn();\n    });\n  };\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support).\n *\n * Resolve a style property into it's component parts, e.g.\n *\n * resolveBoxStyle('margin', {margin: 5, marginBottom: 10})\n * -> {top: 5, left: 5, right: 5, bottom: 10}\n */\nfunction resolveBoxStyle(prefix, style) {\n  var hasParts = false;\n  var result = {\n    bottom: 0,\n    left: 0,\n    right: 0,\n    top: 0\n  };\n  var styleForAll = style[prefix];\n\n  if (styleForAll != null) {\n    // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n    for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n      result[key] = styleForAll;\n    }\n\n    hasParts = true;\n  }\n\n  var styleForHorizontal = style[prefix + 'Horizontal'];\n\n  if (styleForHorizontal != null) {\n    result.left = styleForHorizontal;\n    result.right = styleForHorizontal;\n    hasParts = true;\n  } else {\n    var styleForLeft = style[prefix + 'Left'];\n\n    if (styleForLeft != null) {\n      result.left = styleForLeft;\n      hasParts = true;\n    }\n\n    var styleForRight = style[prefix + 'Right'];\n\n    if (styleForRight != null) {\n      result.right = styleForRight;\n      hasParts = true;\n    }\n\n    var styleForEnd = style[prefix + 'End'];\n\n    if (styleForEnd != null) {\n      // TODO RTL support\n      result.right = styleForEnd;\n      hasParts = true;\n    }\n\n    var styleForStart = style[prefix + 'Start'];\n\n    if (styleForStart != null) {\n      // TODO RTL support\n      result.left = styleForStart;\n      hasParts = true;\n    }\n  }\n\n  var styleForVertical = style[prefix + 'Vertical'];\n\n  if (styleForVertical != null) {\n    result.bottom = styleForVertical;\n    result.top = styleForVertical;\n    hasParts = true;\n  } else {\n    var styleForBottom = style[prefix + 'Bottom'];\n\n    if (styleForBottom != null) {\n      result.bottom = styleForBottom;\n      hasParts = true;\n    }\n\n    var styleForTop = style[prefix + 'Top'];\n\n    if (styleForTop != null) {\n      result.top = styleForTop;\n      hasParts = true;\n    }\n  }\n\n  return hasParts ? result : null;\n}\n;// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js\nfunction setupNativeStyleEditor_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { setupNativeStyleEditor_typeof = function _typeof(obj) { return typeof obj; }; } else { setupNativeStyleEditor_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return setupNativeStyleEditor_typeof(obj); }\n\nfunction setupNativeStyleEditor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\nfunction setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {\n  bridge.addListener('NativeStyleEditor_measure', function (_ref) {\n    var id = _ref.id,\n        rendererID = _ref.rendererID;\n    measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n  });\n  bridge.addListener('NativeStyleEditor_renameAttribute', function (_ref2) {\n    var id = _ref2.id,\n        rendererID = _ref2.rendererID,\n        oldName = _ref2.oldName,\n        newName = _ref2.newName,\n        value = _ref2.value;\n    renameStyle(agent, id, rendererID, oldName, newName, value);\n    setTimeout(function () {\n      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n    });\n  });\n  bridge.addListener('NativeStyleEditor_setValue', function (_ref3) {\n    var id = _ref3.id,\n        rendererID = _ref3.rendererID,\n        name = _ref3.name,\n        value = _ref3.value;\n    setStyle(agent, id, rendererID, name, value);\n    setTimeout(function () {\n      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n    });\n  });\n  bridge.send('isNativeStyleEditorSupported', {\n    isSupported: true,\n    validAttributes: validAttributes\n  });\n}\nvar EMPTY_BOX_STYLE = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0\n};\nvar componentIDToStyleOverrides = new Map();\n\nfunction measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {\n  var data = agent.getInstanceAndStyle({\n    id: id,\n    rendererID: rendererID\n  });\n\n  if (!data || !data.style) {\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id: id,\n      layout: null,\n      style: null\n    });\n    return;\n  }\n\n  var instance = data.instance,\n      style = data.style;\n  var resolvedStyle = resolveNativeStyle(style); // If it's a host component we edited before, amend styles.\n\n  var styleOverrides = componentIDToStyleOverrides.get(id);\n\n  if (styleOverrides != null) {\n    resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);\n  }\n\n  if (!instance || typeof instance.measure !== 'function') {\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id: id,\n      layout: null,\n      style: resolvedStyle || null\n    });\n    return;\n  }\n\n  instance.measure(function (x, y, width, height, left, top) {\n    // RN Android sometimes returns undefined here. Don't send measurements in this case.\n    // https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817\n    if (typeof x !== 'number') {\n      bridge.send('NativeStyleEditor_styleAndLayout', {\n        id: id,\n        layout: null,\n        style: resolvedStyle || null\n      });\n      return;\n    }\n\n    var margin = resolvedStyle != null && resolveBoxStyle('margin', resolvedStyle) || EMPTY_BOX_STYLE;\n    var padding = resolvedStyle != null && resolveBoxStyle('padding', resolvedStyle) || EMPTY_BOX_STYLE;\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id: id,\n      layout: {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        left: left,\n        top: top,\n        margin: margin,\n        padding: padding\n      },\n      style: resolvedStyle || null\n    });\n  });\n}\n\nfunction shallowClone(object) {\n  var cloned = {};\n\n  for (var n in object) {\n    cloned[n] = object[n];\n  }\n\n  return cloned;\n}\n\nfunction renameStyle(agent, id, rendererID, oldName, newName, value) {\n  var _ref4;\n\n  var data = agent.getInstanceAndStyle({\n    id: id,\n    rendererID: rendererID\n  });\n\n  if (!data || !data.style) {\n    return;\n  }\n\n  var instance = data.instance,\n      style = data.style;\n  var newStyle = newName ? (_ref4 = {}, setupNativeStyleEditor_defineProperty(_ref4, oldName, undefined), setupNativeStyleEditor_defineProperty(_ref4, newName, value), _ref4) : setupNativeStyleEditor_defineProperty({}, oldName, undefined);\n  var customStyle; // TODO It would be nice if the renderer interface abstracted this away somehow.\n\n  if (instance !== null && typeof instance.setNativeProps === 'function') {\n    // In the case of a host component, we need to use setNativeProps().\n    // Remember to \"correct\" resolved styles when we read them next time.\n    var styleOverrides = componentIDToStyleOverrides.get(id);\n\n    if (!styleOverrides) {\n      componentIDToStyleOverrides.set(id, newStyle);\n    } else {\n      Object.assign(styleOverrides, newStyle);\n    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli\n\n\n    instance.setNativeProps({\n      style: newStyle\n    });\n  } else if (src_isArray(style)) {\n    var lastIndex = style.length - 1;\n\n    if (setupNativeStyleEditor_typeof(style[lastIndex]) === 'object' && !src_isArray(style[lastIndex])) {\n      customStyle = shallowClone(style[lastIndex]);\n      delete customStyle[oldName];\n\n      if (newName) {\n        customStyle[newName] = value;\n      } else {\n        customStyle[oldName] = undefined;\n      }\n\n      agent.overrideValueAtPath({\n        type: 'props',\n        id: id,\n        rendererID: rendererID,\n        path: ['style', lastIndex],\n        value: customStyle\n      });\n    } else {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id: id,\n        rendererID: rendererID,\n        path: ['style'],\n        value: style.concat([newStyle])\n      });\n    }\n  } else if (setupNativeStyleEditor_typeof(style) === 'object') {\n    customStyle = shallowClone(style);\n    delete customStyle[oldName];\n\n    if (newName) {\n      customStyle[newName] = value;\n    } else {\n      customStyle[oldName] = undefined;\n    }\n\n    agent.overrideValueAtPath({\n      type: 'props',\n      id: id,\n      rendererID: rendererID,\n      path: ['style'],\n      value: customStyle\n    });\n  } else {\n    agent.overrideValueAtPath({\n      type: 'props',\n      id: id,\n      rendererID: rendererID,\n      path: ['style'],\n      value: [style, newStyle]\n    });\n  }\n\n  agent.emit('hideNativeHighlight');\n}\n\nfunction setStyle(agent, id, rendererID, name, value) {\n  var data = agent.getInstanceAndStyle({\n    id: id,\n    rendererID: rendererID\n  });\n\n  if (!data || !data.style) {\n    return;\n  }\n\n  var instance = data.instance,\n      style = data.style;\n\n  var newStyle = setupNativeStyleEditor_defineProperty({}, name, value); // TODO It would be nice if the renderer interface abstracted this away somehow.\n\n\n  if (instance !== null && typeof instance.setNativeProps === 'function') {\n    // In the case of a host component, we need to use setNativeProps().\n    // Remember to \"correct\" resolved styles when we read them next time.\n    var styleOverrides = componentIDToStyleOverrides.get(id);\n\n    if (!styleOverrides) {\n      componentIDToStyleOverrides.set(id, newStyle);\n    } else {\n      Object.assign(styleOverrides, newStyle);\n    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli\n\n\n    instance.setNativeProps({\n      style: newStyle\n    });\n  } else if (src_isArray(style)) {\n    var lastLength = style.length - 1;\n\n    if (setupNativeStyleEditor_typeof(style[lastLength]) === 'object' && !src_isArray(style[lastLength])) {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id: id,\n        rendererID: rendererID,\n        path: ['style', lastLength, name],\n        value: value\n      });\n    } else {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id: id,\n        rendererID: rendererID,\n        path: ['style'],\n        value: style.concat([newStyle])\n      });\n    }\n  } else {\n    agent.overrideValueAtPath({\n      type: 'props',\n      id: id,\n      rendererID: rendererID,\n      path: ['style'],\n      value: [style, newStyle]\n    });\n  }\n\n  agent.emit('hideNativeHighlight');\n}\n;// CONCATENATED MODULE: ./src/cachedSettings.js\n/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n // Note: all keys should be optional in this type, because users can use newer\n// versions of React DevTools with older versions of React Native, and the object\n// provided by React Native may not include all of this type's fields.\n\nfunction initializeUsingCachedSettings(devToolsSettingsManager) {\n  initializeConsolePatchSettings(devToolsSettingsManager);\n}\n\nfunction initializeConsolePatchSettings(devToolsSettingsManager) {\n  if (devToolsSettingsManager.getConsolePatchSettings == null) {\n    return;\n  }\n\n  var consolePatchSettingsString = devToolsSettingsManager.getConsolePatchSettings();\n\n  if (consolePatchSettingsString == null) {\n    return;\n  }\n\n  var parsedConsolePatchSettings = parseConsolePatchSettings(consolePatchSettingsString);\n\n  if (parsedConsolePatchSettings == null) {\n    return;\n  }\n\n  writeConsolePatchSettingsToWindow(parsedConsolePatchSettings);\n}\n\nfunction parseConsolePatchSettings(consolePatchSettingsString) {\n  var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;\n\n  var parsedValue = JSON.parse(consolePatchSettingsString !== null && consolePatchSettingsString !== void 0 ? consolePatchSettingsString : '{}');\n  var appendComponentStack = parsedValue.appendComponentStack,\n      breakOnConsoleErrors = parsedValue.breakOnConsoleErrors,\n      showInlineWarningsAndErrors = parsedValue.showInlineWarningsAndErrors,\n      hideConsoleLogsInStrictMode = parsedValue.hideConsoleLogsInStrictMode,\n      browserTheme = parsedValue.browserTheme;\n  return {\n    appendComponentStack: (_castBool = castBool(appendComponentStack)) !== null && _castBool !== void 0 ? _castBool : true,\n    breakOnConsoleErrors: (_castBool2 = castBool(breakOnConsoleErrors)) !== null && _castBool2 !== void 0 ? _castBool2 : false,\n    showInlineWarningsAndErrors: (_castBool3 = castBool(showInlineWarningsAndErrors)) !== null && _castBool3 !== void 0 ? _castBool3 : true,\n    hideConsoleLogsInStrictMode: (_castBool4 = castBool(hideConsoleLogsInStrictMode)) !== null && _castBool4 !== void 0 ? _castBool4 : false,\n    browserTheme: (_castBrowserTheme = castBrowserTheme(browserTheme)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : 'dark'\n  };\n}\n\nfunction cacheConsolePatchSettings(devToolsSettingsManager, value) {\n  if (devToolsSettingsManager.setConsolePatchSettings == null) {\n    return;\n  }\n\n  devToolsSettingsManager.setConsolePatchSettings(JSON.stringify(value));\n}\n;// CONCATENATED MODULE: ./src/backend.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n// Install a global variable to allow patching console early (during injection).\n// This provides React Native developers with components stacks even if they don't run DevTools.\ninstallConsoleFunctionsToWindow();\ninstallHook(window);\nvar hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;\nvar savedComponentFilters = getDefaultComponentFilters();\n\nfunction backend_debug(methodName) {\n  if (__DEBUG__) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, [\"%c[core/backend] %c\".concat(methodName), 'color: teal; font-weight: bold;', 'font-weight: bold;'].concat(args));\n  }\n}\n\nfunction connectToDevTools(options) {\n  if (hook == null) {\n    // DevTools didn't get injected into this page (maybe b'c of the contentType).\n    return;\n  }\n\n  var _ref = options || {},\n      _ref$host = _ref.host,\n      host = _ref$host === void 0 ? 'localhost' : _ref$host,\n      nativeStyleEditorValidAttributes = _ref.nativeStyleEditorValidAttributes,\n      _ref$useHttps = _ref.useHttps,\n      useHttps = _ref$useHttps === void 0 ? false : _ref$useHttps,\n      _ref$port = _ref.port,\n      port = _ref$port === void 0 ? 8097 : _ref$port,\n      websocket = _ref.websocket,\n      _ref$resolveRNStyle = _ref.resolveRNStyle,\n      resolveRNStyle = _ref$resolveRNStyle === void 0 ? null : _ref$resolveRNStyle,\n      _ref$retryConnectionD = _ref.retryConnectionDelay,\n      retryConnectionDelay = _ref$retryConnectionD === void 0 ? 2000 : _ref$retryConnectionD,\n      _ref$isAppActive = _ref.isAppActive,\n      isAppActive = _ref$isAppActive === void 0 ? function () {\n    return true;\n  } : _ref$isAppActive,\n      devToolsSettingsManager = _ref.devToolsSettingsManager;\n\n  var protocol = useHttps ? 'wss' : 'ws';\n  var retryTimeoutID = null;\n\n  function scheduleRetry() {\n    if (retryTimeoutID === null) {\n      // Two seconds because RN had issues with quick retries.\n      retryTimeoutID = setTimeout(function () {\n        return connectToDevTools(options);\n      }, retryConnectionDelay);\n    }\n  }\n\n  if (devToolsSettingsManager != null) {\n    try {\n      initializeUsingCachedSettings(devToolsSettingsManager);\n    } catch (e) {\n      // If we call a method on devToolsSettingsManager that throws, or if\n      // is invalid data read out, don't throw and don't interrupt initialization\n      console.error(e);\n    }\n  }\n\n  if (!isAppActive()) {\n    // If the app is in background, maybe retry later.\n    // Don't actually attempt to connect until we're in foreground.\n    scheduleRetry();\n    return;\n  }\n\n  var bridge = null;\n  var messageListeners = [];\n  var uri = protocol + '://' + host + ':' + port; // If existing websocket is passed, use it.\n  // This is necessary to support our custom integrations.\n  // See D6251744.\n\n  var ws = websocket ? websocket : new window.WebSocket(uri);\n  ws.onclose = handleClose;\n  ws.onerror = handleFailed;\n  ws.onmessage = handleMessage;\n\n  ws.onopen = function () {\n    bridge = new src_bridge({\n      listen: function listen(fn) {\n        messageListeners.push(fn);\n        return function () {\n          var index = messageListeners.indexOf(fn);\n\n          if (index >= 0) {\n            messageListeners.splice(index, 1);\n          }\n        };\n      },\n      send: function send(event, payload, transferable) {\n        if (ws.readyState === ws.OPEN) {\n          if (__DEBUG__) {\n            backend_debug('wall.send()', event, payload);\n          }\n\n          ws.send(JSON.stringify({\n            event: event,\n            payload: payload\n          }));\n        } else {\n          if (__DEBUG__) {\n            backend_debug('wall.send()', 'Shutting down bridge because of closed WebSocket connection');\n          }\n\n          if (bridge !== null) {\n            bridge.shutdown();\n          }\n\n          scheduleRetry();\n        }\n      }\n    });\n    bridge.addListener('updateComponentFilters', function (componentFilters) {\n      // Save filter changes in memory, in case DevTools is reloaded.\n      // In that case, the renderer will already be using the updated values.\n      // We'll lose these in between backend reloads but that can't be helped.\n      savedComponentFilters = componentFilters;\n    });\n\n    if (devToolsSettingsManager != null && bridge != null) {\n      bridge.addListener('updateConsolePatchSettings', function (consolePatchSettings) {\n        return cacheConsolePatchSettings(devToolsSettingsManager, consolePatchSettings);\n      });\n    } // The renderer interface doesn't read saved component filters directly,\n    // because they are generally stored in localStorage within the context of the extension.\n    // Because of this it relies on the extension to pass filters.\n    // In the case of the standalone DevTools being used with a website,\n    // saved filters are injected along with the backend script tag so we shouldn't override them here.\n    // This injection strategy doesn't work for React Native though.\n    // Ideally the backend would save the filters itself, but RN doesn't provide a sync storage solution.\n    // So for now we just fall back to using the default filters...\n\n\n    if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      bridge.send('overrideComponentFilters', savedComponentFilters);\n    } // TODO (npm-packages) Warn if \"isBackendStorageAPISupported\"\n    // $FlowFixMe[incompatible-call] found when upgrading Flow\n\n\n    var agent = new Agent(bridge);\n    agent.addListener('shutdown', function () {\n      // If we received 'shutdown' from `agent`, we assume the `bridge` is already shutting down,\n      // and that caused the 'shutdown' event on the `agent`, so we don't need to call `bridge.shutdown()` here.\n      hook.emit('shutdown');\n    });\n    initBackend(hook, agent, window); // Setup React Native style editor if the environment supports it.\n\n    if (resolveRNStyle != null || hook.resolveRNStyle != null) {\n      setupNativeStyleEditor( // $FlowFixMe[incompatible-call] found when upgrading Flow\n      bridge, agent, resolveRNStyle || hook.resolveRNStyle, nativeStyleEditorValidAttributes || hook.nativeStyleEditorValidAttributes || null);\n    } else {\n      // Otherwise listen to detect if the environment later supports it.\n      // For example, Flipper does not eagerly inject these values.\n      // Instead it relies on the React Native Inspector to lazily inject them.\n      var lazyResolveRNStyle;\n      var lazyNativeStyleEditorValidAttributes;\n\n      var initAfterTick = function initAfterTick() {\n        if (bridge !== null) {\n          setupNativeStyleEditor(bridge, agent, lazyResolveRNStyle, lazyNativeStyleEditorValidAttributes);\n        }\n      };\n\n      if (!hook.hasOwnProperty('resolveRNStyle')) {\n        Object.defineProperty(hook, 'resolveRNStyle', {\n          enumerable: false,\n          get: function get() {\n            return lazyResolveRNStyle;\n          },\n          set: function set(value) {\n            lazyResolveRNStyle = value;\n            initAfterTick();\n          }\n        });\n      }\n\n      if (!hook.hasOwnProperty('nativeStyleEditorValidAttributes')) {\n        Object.defineProperty(hook, 'nativeStyleEditorValidAttributes', {\n          enumerable: false,\n          get: function get() {\n            return lazyNativeStyleEditorValidAttributes;\n          },\n          set: function set(value) {\n            lazyNativeStyleEditorValidAttributes = value;\n            initAfterTick();\n          }\n        });\n      }\n    }\n  };\n\n  function handleClose() {\n    if (__DEBUG__) {\n      backend_debug('WebSocket.onclose');\n    }\n\n    if (bridge !== null) {\n      bridge.emit('shutdown');\n    }\n\n    scheduleRetry();\n  }\n\n  function handleFailed() {\n    if (__DEBUG__) {\n      backend_debug('WebSocket.onerror');\n    }\n\n    scheduleRetry();\n  }\n\n  function handleMessage(event) {\n    var data;\n\n    try {\n      if (typeof event.data === 'string') {\n        data = JSON.parse(event.data);\n\n        if (__DEBUG__) {\n          backend_debug('WebSocket.onmessage', data);\n        }\n      } else {\n        throw Error();\n      }\n    } catch (e) {\n      console.error('[React DevTools] Failed to parse JSON: ' + event.data);\n      return;\n    }\n\n    messageListeners.forEach(function (fn) {\n      try {\n        fn(data);\n      } catch (error) {\n        // jsc doesn't play so well with tracebacks that go into eval'd code,\n        // so the stack trace here will stop at the `eval()` call. Getting the\n        // message that caused the error is the best we can do for now.\n        console.log('[React DevTools] Error calling listener', data);\n        console.log('error:', error);\n        throw error;\n      }\n    });\n  }\n}\n})();\n\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=backend.js.map\n\n//# sourceURL=webpack://spotify-tui/./node_modules/react-devtools-core/dist/backend.js?");

/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'bufferutil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/buffer-util.js?");

/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/constants.js?");

/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/event-target.js?");

/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/extension.js?");

/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/limiter.js?");

/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"./node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/permessage-deflate.js?");

/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/receiver.js?");

/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\n\n\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        if (randomPoolPointer === RANDOM_POOL_SIZE) {\n          /* istanbul ignore else  */\n          if (randomPool === undefined) {\n            //\n            // This is lazily initialized because server-sent frames must not\n            // be masked so it may never be used.\n            //\n            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n          }\n\n          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n          randomPoolPointer = 0;\n        }\n\n        mask[0] = randomPool[randomPoolPointer++];\n        mask[1] = randomPool[randomPoolPointer++];\n        mask[2] = randomPool[randomPoolPointer++];\n        mask[3] = randomPool[randomPoolPointer++];\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/sender.js?");

/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/stream.js?");

/***/ }),

/***/ "./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/subprotocol.js?");

/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = {\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'utf-8-validate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/validation.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst extension = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"./node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"./node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/websocket-server.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"./node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = __webpack_require__(/*! ./event-target */ \"./node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/lib/websocket.js?");

/***/ }),

/***/ "./node_modules/ink/build/devtools-window-polyfill.js":
/*!************************************************************!*\
  !*** ./node_modules/ink/build/devtools-window-polyfill.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"./node_modules/ws/wrapper.mjs\");\n// Ignoring missing types error to avoid adding another dependency for this hack to work\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nconst customGlobal = global;\n// These things must exist before importing `react-devtools-core`\ncustomGlobal.WebSocket ||= ws__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\ncustomGlobal.window ||= global;\ncustomGlobal.self ||= global;\n// Filter out Ink's internal components from devtools for a cleaner view.\n// Also, ince `react-devtools-shared` package isn't published on npm, we can't\n// use its types, that's why there are hard-coded values in `type` fields below.\n// See https://github.com/facebook/react/blob/edf6eac8a181860fd8a2d076a43806f1237495a1/packages/react-devtools-shared/src/types.js#L24\ncustomGlobal.window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = [\n    {\n        // ComponentFilterElementType\n        type: 1,\n        // ElementTypeHostComponent\n        value: 7,\n        isEnabled: true,\n    },\n    {\n        // ComponentFilterDisplayName\n        type: 2,\n        value: 'InternalApp',\n        isEnabled: true,\n        isValid: true,\n    },\n    {\n        // ComponentFilterDisplayName\n        type: 2,\n        value: 'InternalAppContext',\n        isEnabled: true,\n        isValid: true,\n    },\n    {\n        // ComponentFilterDisplayName\n        type: 2,\n        value: 'InternalStdoutContext',\n        isEnabled: true,\n        isValid: true,\n    },\n    {\n        // ComponentFilterDisplayName\n        type: 2,\n        value: 'InternalStderrContext',\n        isEnabled: true,\n        isValid: true,\n    },\n    {\n        // ComponentFilterDisplayName\n        type: 2,\n        value: 'InternalStdinContext',\n        isEnabled: true,\n        isValid: true,\n    },\n    {\n        // ComponentFilterDisplayName\n        type: 2,\n        value: 'InternalFocusContext',\n        isEnabled: true,\n        isValid: true,\n    },\n];\n//# sourceMappingURL=devtools-window-polyfill.js.map\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ink/build/devtools-window-polyfill.js?");

/***/ }),

/***/ "./node_modules/ink/build/devtools.js":
/*!********************************************!*\
  !*** ./node_modules/ink/build/devtools.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _devtools_window_polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./devtools-window-polyfill.js */ \"./node_modules/ink/build/devtools-window-polyfill.js\");\n/* harmony import */ var react_devtools_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-core */ \"./node_modules/react-devtools-core/dist/backend.js\");\n/* eslint-disable import/order */\n// eslint-disable-next-line import/no-unassigned-import\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-expect-error\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-call\nreact_devtools_core__WEBPACK_IMPORTED_MODULE_1__.connectToDevTools();\n//# sourceMappingURL=devtools.js.map\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ink/build/devtools.js?");

/***/ }),

/***/ "./node_modules/ws/wrapper.mjs":
/*!*************************************!*\
  !*** ./node_modules/ws/wrapper.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"./node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"./node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"./node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"./node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"./node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\n//# sourceURL=webpack://spotify-tui/./node_modules/ws/wrapper.mjs?");

/***/ })

};
;